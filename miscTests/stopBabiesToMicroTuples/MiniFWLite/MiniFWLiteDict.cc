//
// File generated by rootcint at Mon Sep  2 16:46:46 2013

// Do NOT change. Changes will be lost next time file is generated
//

#define R__DICTIONARY_FILENAME MiniFWLiteDict
#include "RConfig.h" //rootcint 4834
#if !defined(R__ACCESS_IN_SYMBOL)
//Break the privacy of classes -- Disabled for the moment
#define private public
#define protected public
#endif

// Since CINT ignores the std namespace, we need to do so in this file.
namespace std {} using namespace std;
#include "MiniFWLiteDict.h"

#include "TCollectionProxyInfo.h"
#include "TClass.h"
#include "TBuffer.h"
#include "TMemberInspector.h"
#include "TError.h"

#ifndef G__ROOT
#define G__ROOT
#endif

#include "RtypesImp.h"
#include "TIsAProxy.h"
#include "TFileMergeInfo.h"

// START OF SHADOWS

namespace ROOT {
   namespace Shadow {
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::EDProduct EDProduct;
      #else
      class EDProduct  {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~EDProduct() throw() {};
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::BranchKey BranchKey;
      #else
      class BranchKey  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::EventAuxiliary EventAuxiliary;
      #else
      class EventAuxiliary  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::FileFormatVersion FileFormatVersion;
      #else
      class FileFormatVersion  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::LuminosityBlockAuxiliary LuminosityBlockAuxiliary;
      #else
      class LuminosityBlockAuxiliary  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ParameterSetBlob ParameterSetBlob;
      #else
      class ParameterSetBlob  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::RunAuxiliary RunAuxiliary;
      #else
      class RunAuxiliary  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::BranchChildren BranchChildren;
      #else
      class BranchChildren  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::BranchDescription BranchDescription;
      #else
      class BranchDescription  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::BranchDescription::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::BranchID BranchID;
      #else
      class BranchID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::EventEntryDescription EventEntryDescription;
      #else
      class EventEntryDescription  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::EventEntryDescription::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::EventEntryInfo EventEntryInfo;
      #else
      class EventEntryInfo  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::EventEntryInfo::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::EventID EventID;
      #else
      class EventID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::FileID FileID;
      #else
      class FileID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::FileIndex FileIndex;
      #else
      class FileIndex  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::FileIndex::Element Element;
         #else
         class Element  {
            public:
            //friend XX;
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::FileIndex::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::History History;
      #else
      class History  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::LuminosityBlockID LuminosityBlockID;
      #else
      class LuminosityBlockID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ModuleDescription ModuleDescription;
      #else
      class ModuleDescription  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Parentage Parentage;
      #else
      class Parentage  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::Parentage::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ProcessConfiguration ProcessConfiguration;
      #else
      class ProcessConfiguration  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::ProcessConfiguration::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ProcessHistory ProcessHistory;
      #else
      class ProcessHistory  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::ProcessHistory::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ProductID ProductID;
      #else
      class ProductID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::StoredProductProvenance StoredProductProvenance;
      #else
      class StoredProductProvenance  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::StoredProductProvenance::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ProductProvenance ProductProvenance;
      #else
      class ProductProvenance  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::ProductProvenance::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::ProductRegistry ProductRegistry;
      #else
      class ProductRegistry  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::ProductRegistry::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::RunID RunID;
      #else
      class RunID  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Timestamp Timestamp;
      #else
      class Timestamp  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::IndexIntoFile IndexIntoFile;
      #else
      class IndexIntoFile  {
         public:
         //friend XX;
         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::IndexIntoFile::Transients Transients;
         #else
         class Transients  {
            public:
            //friend XX;
         };
         #endif

         #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
         typedef ::edm::IndexIntoFile::RunOrLumiEntry RunOrLumiEntry;
         #else
         class RunOrLumiEntry  {
            public:
            //friend XX;
         };
         #endif

      };
      #endif
      } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::PxPyPzE4D< float > PxPyPzE4DlEfloatgR;
      #else
      class PxPyPzE4DlEfloatgR  {
         public:
         //friend XX;
         typedef void* (*Scalar)() ;
         float fX; //
         float fY; //
         float fZ; //
         float fT; //
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  > LorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR;
      #else
      class LorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR  {
         public:
         //friend XX;
         typedef void* (*Scalar)() ;
         typedef ::ROOT::Math::PxPyPzE4D<float> CoordinateType;
         typedef ::ROOT::Math::Cartesian3D<float> Cartesian3D;
         typedef ::ROOT::Math::DisplacementVector3D< ::ROOT::Math::Cartesian3D<float>, ::ROOT::Math::DefaultCoordinateSystemTag> BetaVector;
         ::ROOT::Math::PxPyPzE4D< float > fCoordinates; //internal coordinate system
      };
      #endif
      } } 
      namespace ROOT {
         namespace Math {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag > PositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR;
      #else
      class PositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR  {
         public:
         //friend XX;
         typedef void* (*Scalar)() ;
         typedef ::ROOT::Math::Cartesian3D<float> CoordinateType;
         typedef ::ROOT::Math::DefaultCoordinateSystemTag CoordinateSystemTag;
         ::ROOT::Math::Cartesian3D< float > fCoordinates; //
      };
      #endif
      } } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::TString > WrapperlETStringgR;
      #else
      class WrapperlETStringgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlETStringgR() throw() {};
         bool present; //
         ::TString obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< double > WrapperlEdoublegR;
      #else
      class WrapperlEdoublegR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEdoublegR() throw() {};
         bool present; //
         double obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< float > WrapperlEfloatgR;
      #else
      class WrapperlEfloatgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEfloatgR() throw() {};
         bool present; //
         float obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< int > WrapperlEintgR;
      #else
      class WrapperlEintgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEintgR() throw() {};
         bool present; //
         int obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< unsigned int > WrapperlEunsignedsPintgR;
      #else
      class WrapperlEunsignedsPintgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEunsignedsPintgR() throw() {};
         bool present; //
         unsigned int obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  > WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR;
      #else
      class WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR() throw() {};
         bool present; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  > WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR;
      #else
      class WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR() throw() {};
         bool present; //
         ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  > WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR;
      #else
      class WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR() throw() {};
         bool present; //
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  > WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR;
      #else
      class WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR() throw() {};
         bool present; //
         ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< ::TString, allocator< ::TString >  >  > WrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR;
      #else
      class WrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR() throw() {};
         bool present; //
         vector< ::TString, allocator< ::TString >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< double, allocator< double >  >  > WrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR;
      #else
      class WrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR() throw() {};
         bool present; //
         vector< double, allocator< double >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< float, allocator< float >  >  > WrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR;
      #else
      class WrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR() throw() {};
         bool present; //
         vector< float, allocator< float >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< int, allocator< int >  >  > WrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR;
      #else
      class WrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR() throw() {};
         bool present; //
         vector< int, allocator< int >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< unsigned int, allocator< unsigned int >  >  > WrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR;
      #else
      class WrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR() throw() {};
         bool present; //
         vector< unsigned int, allocator< unsigned int >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  >  > WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  >  > WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  > WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  > WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< ::TString, allocator< ::TString >  >, allocator< vector< ::TString, allocator< ::TString >  >  >  >  > WrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< ::TString, allocator< ::TString >  >, allocator< vector< ::TString, allocator< ::TString >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< double, allocator< double >  >, allocator< vector< double, allocator< double >  >  >  >  > WrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< double, allocator< double >  >, allocator< vector< double, allocator< double >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< float, allocator< float >  >, allocator< vector< float, allocator< float >  >  >  >  > WrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< float, allocator< float >  >, allocator< vector< float, allocator< float >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< int, allocator< int >  >, allocator< vector< int, allocator< int >  >  >  >  > WrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< int, allocator< int >  >, allocator< vector< int, allocator< int >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< unsigned int, allocator< unsigned int >  >, allocator< vector< unsigned int, allocator< unsigned int >  >  >  >  > WrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< unsigned int, allocator< unsigned int >  >, allocator< vector< unsigned int, allocator< unsigned int >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  >, allocator< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  >  >  >  > WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  >, allocator< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< double >  >  >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  >, allocator< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  >  >  >  > WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  >, allocator< vector< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >, allocator< ::ROOT::Math::LorentzVector< ::ROOT::Math::PxPyPzE4D< float >  >  >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >, allocator< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  >  >  > WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >, allocator< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< double >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >, allocator< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  >  >  > WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR;
      #else
      class WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR() throw() {};
         bool present; //
         vector< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >, allocator< vector< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >, allocator< ::ROOT::Math::PositionVector3D< ::ROOT::Math::Cartesian3D< float >, ::ROOT::Math::DefaultCoordinateSystemTag >  >  >  >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 0 > HashlE0gR;
      #else
      class HashlE0gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 1 > HashlE1gR;
      #else
      class HashlE1gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 2 > HashlE2gR;
      #else
      class HashlE2gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 3 > HashlE3gR;
      #else
      class HashlE3gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 4 > HashlE4gR;
      #else
      class HashlE4gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Hash< 5 > HashlE5gR;
      #else
      class HashlE5gR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::BranchDescription::Transients > TransientlEedmcLcLBranchDescriptioncLcLTransientsgR;
      #else
      class TransientlEedmcLcLBranchDescriptioncLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::EventEntryDescription::Transients > TransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR;
      #else
      class TransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::EventEntryInfo::Transients > TransientlEedmcLcLEventEntryInfocLcLTransientsgR;
      #else
      class TransientlEedmcLcLEventEntryInfocLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::FileIndex::Transients > TransientlEedmcLcLFileIndexcLcLTransientsgR;
      #else
      class TransientlEedmcLcLFileIndexcLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::Parentage::Transients > TransientlEedmcLcLParentagecLcLTransientsgR;
      #else
      class TransientlEedmcLcLParentagecLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::ProcessConfiguration::Transients > TransientlEedmcLcLProcessConfigurationcLcLTransientsgR;
      #else
      class TransientlEedmcLcLProcessConfigurationcLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::ProcessHistory::Transients > TransientlEedmcLcLProcessHistorycLcLTransientsgR;
      #else
      class TransientlEedmcLcLProcessHistorycLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::ProductProvenance::Transients > TransientlEedmcLcLProductProvenancecLcLTransientsgR;
      #else
      class TransientlEedmcLcLProductProvenancecLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::ProductRegistry::Transients > TransientlEedmcLcLProductRegistrycLcLTransientsgR;
      #else
      class TransientlEedmcLcLProductRegistrycLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Transient< ::edm::IndexIntoFile::Transients > TransientlEedmcLcLIndexIntoFilecLcLTransientsgR;
      #else
      class TransientlEedmcLcLIndexIntoFilecLcLTransientsgR  {
         public:
         //friend XX;
      };
      #endif
      } 
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::edm::BranchKey, ::edm::BranchDescription > pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR;
      #else
      class pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR  {
         public:
         //friend XX;
         ::edm::BranchKey first; //
         ::edm::BranchDescription second; //
      };
      #endif

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::edm::Hash< 1 >, ::edm::ParameterSetBlob > pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR;
      #else
      class pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR  {
         public:
         //friend XX;
         ::edm::Hash< 1 > first; //
         ::edm::ParameterSetBlob second; //
      };
      #endif

      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< bool > WrapperlEboolgR;
      #else
      class WrapperlEboolgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEboolgR() throw() {};
         bool present; //
         bool obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< vector< bool, allocator< bool >  >  > WrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR;
      #else
      class WrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR() throw() {};
         bool present; //
         vector< bool, allocator< bool >  > obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< unsigned long long > WrapperlEunsignedsPlongsPlonggR;
      #else
      class WrapperlEunsignedsPlongsPlonggR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlEunsignedsPlongsPlonggR() throw() {};
         bool present; //
         G__uint64 obj; //
      };
      #endif
      } 
      namespace edm {

      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef ::edm::Wrapper< ::TBits > WrapperlETBitsgR;
      #else
      class WrapperlETBitsgR  :  public ::edm::EDProduct {
         public:
         //friend XX;
         // To force the creation of a virtual table, throw just in case.
         virtual ~WrapperlETBitsgR() throw() {};
         bool present; //
         ::TBits obj; //
      };
      #endif
      } 
      #if !(defined(R__ACCESS_IN_SYMBOL) || defined(R__USE_SHADOW_CLASS))
      typedef pair< ::edm::BranchID, set< ::edm::BranchID, ::less< ::edm::BranchID >, allocator< ::edm::BranchID >  >  > pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR;
      #else
      class pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR  {
         public:
         //friend XX;
         ::edm::BranchID first; //
         set< ::edm::BranchID, ::less< ::edm::BranchID >, allocator< ::edm::BranchID >  > second; //
      };
      #endif

   } // of namespace Shadow
} // of namespace ROOT
// END OF SHADOWS

namespace ROOT {
   void edmcLcLEDProduct_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEDProduct_Dictionary();
   static void *new_edmcLcLEDProduct(void *p = 0);
   static void *newArray_edmcLcLEDProduct(Long_t size, void *p);
   static void delete_edmcLcLEDProduct(void *p);
   static void deleteArray_edmcLcLEDProduct(void *p);
   static void destruct_edmcLcLEDProduct(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EDProduct*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EDProduct) == sizeof(::ROOT::Shadow::edm::EDProduct));
      ::edm::EDProduct *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EDProduct),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EDProduct", "./EDProduct.h", 6,
                  typeid(::edm::EDProduct), DefineBehavior(ptr, ptr),
                  &edmcLcLEDProduct_ShowMembers, &edmcLcLEDProduct_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EDProduct) );
      instance.SetNew(&new_edmcLcLEDProduct);
      instance.SetNewArray(&newArray_edmcLcLEDProduct);
      instance.SetDelete(&delete_edmcLcLEDProduct);
      instance.SetDeleteArray(&deleteArray_edmcLcLEDProduct);
      instance.SetDestructor(&destruct_edmcLcLEDProduct);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EDProduct*)
   {
      return GenerateInitInstanceLocal((::edm::EDProduct*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EDProduct*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEDProduct_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EDProduct*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLBranchKey_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLBranchKey_Dictionary();
   static void *new_edmcLcLBranchKey(void *p = 0);
   static void *newArray_edmcLcLBranchKey(Long_t size, void *p);
   static void delete_edmcLcLBranchKey(void *p);
   static void deleteArray_edmcLcLBranchKey(void *p);
   static void destruct_edmcLcLBranchKey(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::BranchKey*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::BranchKey) == sizeof(::ROOT::Shadow::edm::BranchKey));
      ::edm::BranchKey *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::BranchKey),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::BranchKey", "./DataFormats.h", 9,
                  typeid(::edm::BranchKey), DefineBehavior(ptr, ptr),
                  &edmcLcLBranchKey_ShowMembers, &edmcLcLBranchKey_Dictionary, isa_proxy, 4,
                  sizeof(::edm::BranchKey) );
      instance.SetNew(&new_edmcLcLBranchKey);
      instance.SetNewArray(&newArray_edmcLcLBranchKey);
      instance.SetDelete(&delete_edmcLcLBranchKey);
      instance.SetDeleteArray(&deleteArray_edmcLcLBranchKey);
      instance.SetDestructor(&destruct_edmcLcLBranchKey);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::BranchKey*)
   {
      return GenerateInitInstanceLocal((::edm::BranchKey*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::BranchKey*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLBranchKey_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchKey*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventAuxiliary_Dictionary();
   static void *new_edmcLcLEventAuxiliary(void *p = 0);
   static void *newArray_edmcLcLEventAuxiliary(Long_t size, void *p);
   static void delete_edmcLcLEventAuxiliary(void *p);
   static void deleteArray_edmcLcLEventAuxiliary(void *p);
   static void destruct_edmcLcLEventAuxiliary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventAuxiliary*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventAuxiliary) == sizeof(::ROOT::Shadow::edm::EventAuxiliary));
      ::edm::EventAuxiliary *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventAuxiliary),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventAuxiliary", "./DataFormats.h", 10,
                  typeid(::edm::EventAuxiliary), DefineBehavior(ptr, ptr),
                  &edmcLcLEventAuxiliary_ShowMembers, &edmcLcLEventAuxiliary_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventAuxiliary) );
      instance.SetNew(&new_edmcLcLEventAuxiliary);
      instance.SetNewArray(&newArray_edmcLcLEventAuxiliary);
      instance.SetDelete(&delete_edmcLcLEventAuxiliary);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventAuxiliary);
      instance.SetDestructor(&destruct_edmcLcLEventAuxiliary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventAuxiliary*)
   {
      return GenerateInitInstanceLocal((::edm::EventAuxiliary*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventAuxiliary*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventAuxiliary_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventAuxiliary*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLFileFormatVersion_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLFileFormatVersion_Dictionary();
   static void *new_edmcLcLFileFormatVersion(void *p = 0);
   static void *newArray_edmcLcLFileFormatVersion(Long_t size, void *p);
   static void delete_edmcLcLFileFormatVersion(void *p);
   static void deleteArray_edmcLcLFileFormatVersion(void *p);
   static void destruct_edmcLcLFileFormatVersion(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FileFormatVersion*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::FileFormatVersion) == sizeof(::ROOT::Shadow::edm::FileFormatVersion));
      ::edm::FileFormatVersion *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FileFormatVersion),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::FileFormatVersion", "./DataFormats.h", 11,
                  typeid(::edm::FileFormatVersion), DefineBehavior(ptr, ptr),
                  &edmcLcLFileFormatVersion_ShowMembers, &edmcLcLFileFormatVersion_Dictionary, isa_proxy, 4,
                  sizeof(::edm::FileFormatVersion) );
      instance.SetNew(&new_edmcLcLFileFormatVersion);
      instance.SetNewArray(&newArray_edmcLcLFileFormatVersion);
      instance.SetDelete(&delete_edmcLcLFileFormatVersion);
      instance.SetDeleteArray(&deleteArray_edmcLcLFileFormatVersion);
      instance.SetDestructor(&destruct_edmcLcLFileFormatVersion);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FileFormatVersion*)
   {
      return GenerateInitInstanceLocal((::edm::FileFormatVersion*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FileFormatVersion*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLFileFormatVersion_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::FileFormatVersion*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLLuminosityBlockAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLLuminosityBlockAuxiliary_Dictionary();
   static void *new_edmcLcLLuminosityBlockAuxiliary(void *p = 0);
   static void *newArray_edmcLcLLuminosityBlockAuxiliary(Long_t size, void *p);
   static void delete_edmcLcLLuminosityBlockAuxiliary(void *p);
   static void deleteArray_edmcLcLLuminosityBlockAuxiliary(void *p);
   static void destruct_edmcLcLLuminosityBlockAuxiliary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::LuminosityBlockAuxiliary*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::LuminosityBlockAuxiliary) == sizeof(::ROOT::Shadow::edm::LuminosityBlockAuxiliary));
      ::edm::LuminosityBlockAuxiliary *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::LuminosityBlockAuxiliary),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::LuminosityBlockAuxiliary", "./DataFormats.h", 12,
                  typeid(::edm::LuminosityBlockAuxiliary), DefineBehavior(ptr, ptr),
                  &edmcLcLLuminosityBlockAuxiliary_ShowMembers, &edmcLcLLuminosityBlockAuxiliary_Dictionary, isa_proxy, 4,
                  sizeof(::edm::LuminosityBlockAuxiliary) );
      instance.SetNew(&new_edmcLcLLuminosityBlockAuxiliary);
      instance.SetNewArray(&newArray_edmcLcLLuminosityBlockAuxiliary);
      instance.SetDelete(&delete_edmcLcLLuminosityBlockAuxiliary);
      instance.SetDeleteArray(&deleteArray_edmcLcLLuminosityBlockAuxiliary);
      instance.SetDestructor(&destruct_edmcLcLLuminosityBlockAuxiliary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::LuminosityBlockAuxiliary*)
   {
      return GenerateInitInstanceLocal((::edm::LuminosityBlockAuxiliary*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::LuminosityBlockAuxiliary*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLLuminosityBlockAuxiliary_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::LuminosityBlockAuxiliary*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLParameterSetBlob_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLParameterSetBlob_Dictionary();
   static void *new_edmcLcLParameterSetBlob(void *p = 0);
   static void *newArray_edmcLcLParameterSetBlob(Long_t size, void *p);
   static void delete_edmcLcLParameterSetBlob(void *p);
   static void deleteArray_edmcLcLParameterSetBlob(void *p);
   static void destruct_edmcLcLParameterSetBlob(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ParameterSetBlob*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ParameterSetBlob) == sizeof(::ROOT::Shadow::edm::ParameterSetBlob));
      ::edm::ParameterSetBlob *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ParameterSetBlob),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ParameterSetBlob", "./DataFormats.h", 13,
                  typeid(::edm::ParameterSetBlob), DefineBehavior(ptr, ptr),
                  &edmcLcLParameterSetBlob_ShowMembers, &edmcLcLParameterSetBlob_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ParameterSetBlob) );
      instance.SetNew(&new_edmcLcLParameterSetBlob);
      instance.SetNewArray(&newArray_edmcLcLParameterSetBlob);
      instance.SetDelete(&delete_edmcLcLParameterSetBlob);
      instance.SetDeleteArray(&deleteArray_edmcLcLParameterSetBlob);
      instance.SetDestructor(&destruct_edmcLcLParameterSetBlob);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ParameterSetBlob*)
   {
      return GenerateInitInstanceLocal((::edm::ParameterSetBlob*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ParameterSetBlob*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLParameterSetBlob_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ParameterSetBlob*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLRunAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLRunAuxiliary_Dictionary();
   static void *new_edmcLcLRunAuxiliary(void *p = 0);
   static void *newArray_edmcLcLRunAuxiliary(Long_t size, void *p);
   static void delete_edmcLcLRunAuxiliary(void *p);
   static void deleteArray_edmcLcLRunAuxiliary(void *p);
   static void destruct_edmcLcLRunAuxiliary(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RunAuxiliary*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::RunAuxiliary) == sizeof(::ROOT::Shadow::edm::RunAuxiliary));
      ::edm::RunAuxiliary *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RunAuxiliary),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::RunAuxiliary", "./DataFormats.h", 14,
                  typeid(::edm::RunAuxiliary), DefineBehavior(ptr, ptr),
                  &edmcLcLRunAuxiliary_ShowMembers, &edmcLcLRunAuxiliary_Dictionary, isa_proxy, 4,
                  sizeof(::edm::RunAuxiliary) );
      instance.SetNew(&new_edmcLcLRunAuxiliary);
      instance.SetNewArray(&newArray_edmcLcLRunAuxiliary);
      instance.SetDelete(&delete_edmcLcLRunAuxiliary);
      instance.SetDeleteArray(&deleteArray_edmcLcLRunAuxiliary);
      instance.SetDestructor(&destruct_edmcLcLRunAuxiliary);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RunAuxiliary*)
   {
      return GenerateInitInstanceLocal((::edm::RunAuxiliary*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RunAuxiliary*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLRunAuxiliary_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::RunAuxiliary*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLBranchChildren_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLBranchChildren_Dictionary();
   static void *new_edmcLcLBranchChildren(void *p = 0);
   static void *newArray_edmcLcLBranchChildren(Long_t size, void *p);
   static void delete_edmcLcLBranchChildren(void *p);
   static void deleteArray_edmcLcLBranchChildren(void *p);
   static void destruct_edmcLcLBranchChildren(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::BranchChildren*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::BranchChildren) == sizeof(::ROOT::Shadow::edm::BranchChildren));
      ::edm::BranchChildren *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::BranchChildren),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::BranchChildren", "./DataFormats.h", 16,
                  typeid(::edm::BranchChildren), DefineBehavior(ptr, ptr),
                  &edmcLcLBranchChildren_ShowMembers, &edmcLcLBranchChildren_Dictionary, isa_proxy, 4,
                  sizeof(::edm::BranchChildren) );
      instance.SetNew(&new_edmcLcLBranchChildren);
      instance.SetNewArray(&newArray_edmcLcLBranchChildren);
      instance.SetDelete(&delete_edmcLcLBranchChildren);
      instance.SetDeleteArray(&deleteArray_edmcLcLBranchChildren);
      instance.SetDestructor(&destruct_edmcLcLBranchChildren);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::BranchChildren*)
   {
      return GenerateInitInstanceLocal((::edm::BranchChildren*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::BranchChildren*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLBranchChildren_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchChildren*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLBranchDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLBranchDescription_Dictionary();
   static void *new_edmcLcLBranchDescription(void *p = 0);
   static void *newArray_edmcLcLBranchDescription(Long_t size, void *p);
   static void delete_edmcLcLBranchDescription(void *p);
   static void deleteArray_edmcLcLBranchDescription(void *p);
   static void destruct_edmcLcLBranchDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::BranchDescription*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::BranchDescription) == sizeof(::ROOT::Shadow::edm::BranchDescription));
      ::edm::BranchDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::BranchDescription),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::BranchDescription", "./DataFormats.h", 17,
                  typeid(::edm::BranchDescription), DefineBehavior(ptr, ptr),
                  &edmcLcLBranchDescription_ShowMembers, &edmcLcLBranchDescription_Dictionary, isa_proxy, 4,
                  sizeof(::edm::BranchDescription) );
      instance.SetNew(&new_edmcLcLBranchDescription);
      instance.SetNewArray(&newArray_edmcLcLBranchDescription);
      instance.SetDelete(&delete_edmcLcLBranchDescription);
      instance.SetDeleteArray(&deleteArray_edmcLcLBranchDescription);
      instance.SetDestructor(&destruct_edmcLcLBranchDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::BranchDescription*)
   {
      return GenerateInitInstanceLocal((::edm::BranchDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::BranchDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLBranchDescription_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchDescription*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLBranchDescriptioncLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLBranchDescriptioncLcLTransients_Dictionary();
   static void *new_edmcLcLBranchDescriptioncLcLTransients(void *p = 0);
   static void *newArray_edmcLcLBranchDescriptioncLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLBranchDescriptioncLcLTransients(void *p);
   static void deleteArray_edmcLcLBranchDescriptioncLcLTransients(void *p);
   static void destruct_edmcLcLBranchDescriptioncLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::BranchDescription::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::BranchDescription::Transients) == sizeof(::ROOT::Shadow::edm::BranchDescription::Transients));
      ::edm::BranchDescription::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::BranchDescription::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::BranchDescription::Transients", "./DataFormats.h", 19,
                  typeid(::edm::BranchDescription::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLBranchDescriptioncLcLTransients_ShowMembers, &edmcLcLBranchDescriptioncLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::BranchDescription::Transients) );
      instance.SetNew(&new_edmcLcLBranchDescriptioncLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLBranchDescriptioncLcLTransients);
      instance.SetDelete(&delete_edmcLcLBranchDescriptioncLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLBranchDescriptioncLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLBranchDescriptioncLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::BranchDescription::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::BranchDescription::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::BranchDescription::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLBranchDescriptioncLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchDescription::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLBranchID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLBranchID_Dictionary();
   static void *new_edmcLcLBranchID(void *p = 0);
   static void *newArray_edmcLcLBranchID(Long_t size, void *p);
   static void delete_edmcLcLBranchID(void *p);
   static void deleteArray_edmcLcLBranchID(void *p);
   static void destruct_edmcLcLBranchID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::BranchID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::BranchID) == sizeof(::ROOT::Shadow::edm::BranchID));
      ::edm::BranchID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::BranchID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::BranchID", "./DataFormats.h", 21,
                  typeid(::edm::BranchID), DefineBehavior(ptr, ptr),
                  &edmcLcLBranchID_ShowMembers, &edmcLcLBranchID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::BranchID) );
      instance.SetNew(&new_edmcLcLBranchID);
      instance.SetNewArray(&newArray_edmcLcLBranchID);
      instance.SetDelete(&delete_edmcLcLBranchID);
      instance.SetDeleteArray(&deleteArray_edmcLcLBranchID);
      instance.SetDestructor(&destruct_edmcLcLBranchID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::BranchID*)
   {
      return GenerateInitInstanceLocal((::edm::BranchID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::BranchID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLBranchID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventEntryDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventEntryDescription_Dictionary();
   static void *new_edmcLcLEventEntryDescription(void *p = 0);
   static void *newArray_edmcLcLEventEntryDescription(Long_t size, void *p);
   static void delete_edmcLcLEventEntryDescription(void *p);
   static void deleteArray_edmcLcLEventEntryDescription(void *p);
   static void destruct_edmcLcLEventEntryDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventEntryDescription*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventEntryDescription) == sizeof(::ROOT::Shadow::edm::EventEntryDescription));
      ::edm::EventEntryDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventEntryDescription),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventEntryDescription", "./DataFormats.h", 25,
                  typeid(::edm::EventEntryDescription), DefineBehavior(ptr, ptr),
                  &edmcLcLEventEntryDescription_ShowMembers, &edmcLcLEventEntryDescription_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventEntryDescription) );
      instance.SetNew(&new_edmcLcLEventEntryDescription);
      instance.SetNewArray(&newArray_edmcLcLEventEntryDescription);
      instance.SetDelete(&delete_edmcLcLEventEntryDescription);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventEntryDescription);
      instance.SetDestructor(&destruct_edmcLcLEventEntryDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventEntryDescription*)
   {
      return GenerateInitInstanceLocal((::edm::EventEntryDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventEntryDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventEntryDescription_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryDescription*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventEntryDescriptioncLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventEntryDescriptioncLcLTransients_Dictionary();
   static void *new_edmcLcLEventEntryDescriptioncLcLTransients(void *p = 0);
   static void *newArray_edmcLcLEventEntryDescriptioncLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLEventEntryDescriptioncLcLTransients(void *p);
   static void deleteArray_edmcLcLEventEntryDescriptioncLcLTransients(void *p);
   static void destruct_edmcLcLEventEntryDescriptioncLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventEntryDescription::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventEntryDescription::Transients) == sizeof(::ROOT::Shadow::edm::EventEntryDescription::Transients));
      ::edm::EventEntryDescription::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventEntryDescription::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventEntryDescription::Transients", "./DataFormats.h", 27,
                  typeid(::edm::EventEntryDescription::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLEventEntryDescriptioncLcLTransients_ShowMembers, &edmcLcLEventEntryDescriptioncLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventEntryDescription::Transients) );
      instance.SetNew(&new_edmcLcLEventEntryDescriptioncLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLEventEntryDescriptioncLcLTransients);
      instance.SetDelete(&delete_edmcLcLEventEntryDescriptioncLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventEntryDescriptioncLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLEventEntryDescriptioncLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventEntryDescription::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::EventEntryDescription::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventEntryDescription::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventEntryDescriptioncLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryDescription::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventEntryInfo_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventEntryInfo_Dictionary();
   static void *new_edmcLcLEventEntryInfo(void *p = 0);
   static void *newArray_edmcLcLEventEntryInfo(Long_t size, void *p);
   static void delete_edmcLcLEventEntryInfo(void *p);
   static void deleteArray_edmcLcLEventEntryInfo(void *p);
   static void destruct_edmcLcLEventEntryInfo(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventEntryInfo*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventEntryInfo) == sizeof(::ROOT::Shadow::edm::EventEntryInfo));
      ::edm::EventEntryInfo *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventEntryInfo),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventEntryInfo", "./DataFormats.h", 29,
                  typeid(::edm::EventEntryInfo), DefineBehavior(ptr, ptr),
                  &edmcLcLEventEntryInfo_ShowMembers, &edmcLcLEventEntryInfo_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventEntryInfo) );
      instance.SetNew(&new_edmcLcLEventEntryInfo);
      instance.SetNewArray(&newArray_edmcLcLEventEntryInfo);
      instance.SetDelete(&delete_edmcLcLEventEntryInfo);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventEntryInfo);
      instance.SetDestructor(&destruct_edmcLcLEventEntryInfo);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventEntryInfo*)
   {
      return GenerateInitInstanceLocal((::edm::EventEntryInfo*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventEntryInfo*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventEntryInfo_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryInfo*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventEntryInfocLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventEntryInfocLcLTransients_Dictionary();
   static void *new_edmcLcLEventEntryInfocLcLTransients(void *p = 0);
   static void *newArray_edmcLcLEventEntryInfocLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLEventEntryInfocLcLTransients(void *p);
   static void deleteArray_edmcLcLEventEntryInfocLcLTransients(void *p);
   static void destruct_edmcLcLEventEntryInfocLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventEntryInfo::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventEntryInfo::Transients) == sizeof(::ROOT::Shadow::edm::EventEntryInfo::Transients));
      ::edm::EventEntryInfo::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventEntryInfo::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventEntryInfo::Transients", "./DataFormats.h", 31,
                  typeid(::edm::EventEntryInfo::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLEventEntryInfocLcLTransients_ShowMembers, &edmcLcLEventEntryInfocLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventEntryInfo::Transients) );
      instance.SetNew(&new_edmcLcLEventEntryInfocLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLEventEntryInfocLcLTransients);
      instance.SetDelete(&delete_edmcLcLEventEntryInfocLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventEntryInfocLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLEventEntryInfocLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventEntryInfo::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::EventEntryInfo::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventEntryInfo::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventEntryInfocLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryInfo::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLEventID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLEventID_Dictionary();
   static void *new_edmcLcLEventID(void *p = 0);
   static void *newArray_edmcLcLEventID(Long_t size, void *p);
   static void delete_edmcLcLEventID(void *p);
   static void deleteArray_edmcLcLEventID(void *p);
   static void destruct_edmcLcLEventID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::EventID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::EventID) == sizeof(::ROOT::Shadow::edm::EventID));
      ::edm::EventID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::EventID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::EventID", "./DataFormats.h", 33,
                  typeid(::edm::EventID), DefineBehavior(ptr, ptr),
                  &edmcLcLEventID_ShowMembers, &edmcLcLEventID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::EventID) );
      instance.SetNew(&new_edmcLcLEventID);
      instance.SetNewArray(&newArray_edmcLcLEventID);
      instance.SetDelete(&delete_edmcLcLEventID);
      instance.SetDeleteArray(&deleteArray_edmcLcLEventID);
      instance.SetDestructor(&destruct_edmcLcLEventID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::EventID*)
   {
      return GenerateInitInstanceLocal((::edm::EventID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::EventID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLEventID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::EventID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLFileID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLFileID_Dictionary();
   static void *new_edmcLcLFileID(void *p = 0);
   static void *newArray_edmcLcLFileID(Long_t size, void *p);
   static void delete_edmcLcLFileID(void *p);
   static void deleteArray_edmcLcLFileID(void *p);
   static void destruct_edmcLcLFileID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FileID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::FileID) == sizeof(::ROOT::Shadow::edm::FileID));
      ::edm::FileID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FileID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::FileID", "./DataFormats.h", 34,
                  typeid(::edm::FileID), DefineBehavior(ptr, ptr),
                  &edmcLcLFileID_ShowMembers, &edmcLcLFileID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::FileID) );
      instance.SetNew(&new_edmcLcLFileID);
      instance.SetNewArray(&newArray_edmcLcLFileID);
      instance.SetDelete(&delete_edmcLcLFileID);
      instance.SetDeleteArray(&deleteArray_edmcLcLFileID);
      instance.SetDestructor(&destruct_edmcLcLFileID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FileID*)
   {
      return GenerateInitInstanceLocal((::edm::FileID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FileID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLFileID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::FileID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLFileIndex_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLFileIndex_Dictionary();
   static void *new_edmcLcLFileIndex(void *p = 0);
   static void *newArray_edmcLcLFileIndex(Long_t size, void *p);
   static void delete_edmcLcLFileIndex(void *p);
   static void deleteArray_edmcLcLFileIndex(void *p);
   static void destruct_edmcLcLFileIndex(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FileIndex*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::FileIndex) == sizeof(::ROOT::Shadow::edm::FileIndex));
      ::edm::FileIndex *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FileIndex),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::FileIndex", "./DataFormats.h", 35,
                  typeid(::edm::FileIndex), DefineBehavior(ptr, ptr),
                  &edmcLcLFileIndex_ShowMembers, &edmcLcLFileIndex_Dictionary, isa_proxy, 4,
                  sizeof(::edm::FileIndex) );
      instance.SetNew(&new_edmcLcLFileIndex);
      instance.SetNewArray(&newArray_edmcLcLFileIndex);
      instance.SetDelete(&delete_edmcLcLFileIndex);
      instance.SetDeleteArray(&deleteArray_edmcLcLFileIndex);
      instance.SetDestructor(&destruct_edmcLcLFileIndex);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FileIndex*)
   {
      return GenerateInitInstanceLocal((::edm::FileIndex*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FileIndex*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLFileIndex_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLFileIndexcLcLElement_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLFileIndexcLcLElement_Dictionary();
   static void *new_edmcLcLFileIndexcLcLElement(void *p = 0);
   static void *newArray_edmcLcLFileIndexcLcLElement(Long_t size, void *p);
   static void delete_edmcLcLFileIndexcLcLElement(void *p);
   static void deleteArray_edmcLcLFileIndexcLcLElement(void *p);
   static void destruct_edmcLcLFileIndexcLcLElement(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FileIndex::Element*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::FileIndex::Element) == sizeof(::ROOT::Shadow::edm::FileIndex::Element));
      ::edm::FileIndex::Element *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FileIndex::Element),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::FileIndex::Element", "./DataFormats.h", 37,
                  typeid(::edm::FileIndex::Element), DefineBehavior(ptr, ptr),
                  &edmcLcLFileIndexcLcLElement_ShowMembers, &edmcLcLFileIndexcLcLElement_Dictionary, isa_proxy, 4,
                  sizeof(::edm::FileIndex::Element) );
      instance.SetNew(&new_edmcLcLFileIndexcLcLElement);
      instance.SetNewArray(&newArray_edmcLcLFileIndexcLcLElement);
      instance.SetDelete(&delete_edmcLcLFileIndexcLcLElement);
      instance.SetDeleteArray(&deleteArray_edmcLcLFileIndexcLcLElement);
      instance.SetDestructor(&destruct_edmcLcLFileIndexcLcLElement);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FileIndex::Element*)
   {
      return GenerateInitInstanceLocal((::edm::FileIndex::Element*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FileIndex::Element*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLFileIndexcLcLElement_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex::Element*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLFileIndexcLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLFileIndexcLcLTransients_Dictionary();
   static void *new_edmcLcLFileIndexcLcLTransients(void *p = 0);
   static void *newArray_edmcLcLFileIndexcLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLFileIndexcLcLTransients(void *p);
   static void deleteArray_edmcLcLFileIndexcLcLTransients(void *p);
   static void destruct_edmcLcLFileIndexcLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::FileIndex::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::FileIndex::Transients) == sizeof(::ROOT::Shadow::edm::FileIndex::Transients));
      ::edm::FileIndex::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::FileIndex::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::FileIndex::Transients", "./DataFormats.h", 38,
                  typeid(::edm::FileIndex::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLFileIndexcLcLTransients_ShowMembers, &edmcLcLFileIndexcLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::FileIndex::Transients) );
      instance.SetNew(&new_edmcLcLFileIndexcLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLFileIndexcLcLTransients);
      instance.SetDelete(&delete_edmcLcLFileIndexcLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLFileIndexcLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLFileIndexcLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::FileIndex::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::FileIndex::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::FileIndex::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLFileIndexcLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHistory_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHistory_Dictionary();
   static void *new_edmcLcLHistory(void *p = 0);
   static void *newArray_edmcLcLHistory(Long_t size, void *p);
   static void delete_edmcLcLHistory(void *p);
   static void deleteArray_edmcLcLHistory(void *p);
   static void destruct_edmcLcLHistory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::History*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::History) == sizeof(::ROOT::Shadow::edm::History));
      ::edm::History *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::History),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::History", "./DataFormats.h", 41,
                  typeid(::edm::History), DefineBehavior(ptr, ptr),
                  &edmcLcLHistory_ShowMembers, &edmcLcLHistory_Dictionary, isa_proxy, 4,
                  sizeof(::edm::History) );
      instance.SetNew(&new_edmcLcLHistory);
      instance.SetNewArray(&newArray_edmcLcLHistory);
      instance.SetDelete(&delete_edmcLcLHistory);
      instance.SetDeleteArray(&deleteArray_edmcLcLHistory);
      instance.SetDestructor(&destruct_edmcLcLHistory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::History*)
   {
      return GenerateInitInstanceLocal((::edm::History*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::History*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHistory_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::History*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLLuminosityBlockID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLLuminosityBlockID_Dictionary();
   static void *new_edmcLcLLuminosityBlockID(void *p = 0);
   static void *newArray_edmcLcLLuminosityBlockID(Long_t size, void *p);
   static void delete_edmcLcLLuminosityBlockID(void *p);
   static void deleteArray_edmcLcLLuminosityBlockID(void *p);
   static void destruct_edmcLcLLuminosityBlockID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::LuminosityBlockID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::LuminosityBlockID) == sizeof(::ROOT::Shadow::edm::LuminosityBlockID));
      ::edm::LuminosityBlockID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::LuminosityBlockID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::LuminosityBlockID", "./DataFormats.h", 42,
                  typeid(::edm::LuminosityBlockID), DefineBehavior(ptr, ptr),
                  &edmcLcLLuminosityBlockID_ShowMembers, &edmcLcLLuminosityBlockID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::LuminosityBlockID) );
      instance.SetNew(&new_edmcLcLLuminosityBlockID);
      instance.SetNewArray(&newArray_edmcLcLLuminosityBlockID);
      instance.SetDelete(&delete_edmcLcLLuminosityBlockID);
      instance.SetDeleteArray(&deleteArray_edmcLcLLuminosityBlockID);
      instance.SetDestructor(&destruct_edmcLcLLuminosityBlockID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::LuminosityBlockID*)
   {
      return GenerateInitInstanceLocal((::edm::LuminosityBlockID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::LuminosityBlockID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLLuminosityBlockID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::LuminosityBlockID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLModuleDescription_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLModuleDescription_Dictionary();
   static void *new_edmcLcLModuleDescription(void *p = 0);
   static void *newArray_edmcLcLModuleDescription(Long_t size, void *p);
   static void delete_edmcLcLModuleDescription(void *p);
   static void deleteArray_edmcLcLModuleDescription(void *p);
   static void destruct_edmcLcLModuleDescription(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ModuleDescription*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ModuleDescription) == sizeof(::ROOT::Shadow::edm::ModuleDescription));
      ::edm::ModuleDescription *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ModuleDescription),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ModuleDescription", "./DataFormats.h", 43,
                  typeid(::edm::ModuleDescription), DefineBehavior(ptr, ptr),
                  &edmcLcLModuleDescription_ShowMembers, &edmcLcLModuleDescription_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ModuleDescription) );
      instance.SetNew(&new_edmcLcLModuleDescription);
      instance.SetNewArray(&newArray_edmcLcLModuleDescription);
      instance.SetDelete(&delete_edmcLcLModuleDescription);
      instance.SetDeleteArray(&deleteArray_edmcLcLModuleDescription);
      instance.SetDestructor(&destruct_edmcLcLModuleDescription);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ModuleDescription*)
   {
      return GenerateInitInstanceLocal((::edm::ModuleDescription*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ModuleDescription*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLModuleDescription_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ModuleDescription*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLParentage_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLParentage_Dictionary();
   static void *new_edmcLcLParentage(void *p = 0);
   static void *newArray_edmcLcLParentage(Long_t size, void *p);
   static void delete_edmcLcLParentage(void *p);
   static void deleteArray_edmcLcLParentage(void *p);
   static void destruct_edmcLcLParentage(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Parentage*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Parentage) == sizeof(::ROOT::Shadow::edm::Parentage));
      ::edm::Parentage *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Parentage),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Parentage", "./DataFormats.h", 44,
                  typeid(::edm::Parentage), DefineBehavior(ptr, ptr),
                  &edmcLcLParentage_ShowMembers, &edmcLcLParentage_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Parentage) );
      instance.SetNew(&new_edmcLcLParentage);
      instance.SetNewArray(&newArray_edmcLcLParentage);
      instance.SetDelete(&delete_edmcLcLParentage);
      instance.SetDeleteArray(&deleteArray_edmcLcLParentage);
      instance.SetDestructor(&destruct_edmcLcLParentage);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Parentage*)
   {
      return GenerateInitInstanceLocal((::edm::Parentage*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Parentage*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLParentage_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Parentage*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLParentagecLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLParentagecLcLTransients_Dictionary();
   static void *new_edmcLcLParentagecLcLTransients(void *p = 0);
   static void *newArray_edmcLcLParentagecLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLParentagecLcLTransients(void *p);
   static void deleteArray_edmcLcLParentagecLcLTransients(void *p);
   static void destruct_edmcLcLParentagecLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Parentage::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Parentage::Transients) == sizeof(::ROOT::Shadow::edm::Parentage::Transients));
      ::edm::Parentage::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Parentage::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Parentage::Transients", "./DataFormats.h", 46,
                  typeid(::edm::Parentage::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLParentagecLcLTransients_ShowMembers, &edmcLcLParentagecLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Parentage::Transients) );
      instance.SetNew(&new_edmcLcLParentagecLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLParentagecLcLTransients);
      instance.SetDelete(&delete_edmcLcLParentagecLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLParentagecLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLParentagecLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Parentage::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::Parentage::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Parentage::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLParentagecLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Parentage::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProcessConfiguration_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProcessConfiguration_Dictionary();
   static void *new_edmcLcLProcessConfiguration(void *p = 0);
   static void *newArray_edmcLcLProcessConfiguration(Long_t size, void *p);
   static void delete_edmcLcLProcessConfiguration(void *p);
   static void deleteArray_edmcLcLProcessConfiguration(void *p);
   static void destruct_edmcLcLProcessConfiguration(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProcessConfiguration*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProcessConfiguration) == sizeof(::ROOT::Shadow::edm::ProcessConfiguration));
      ::edm::ProcessConfiguration *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProcessConfiguration),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProcessConfiguration", "./DataFormats.h", 48,
                  typeid(::edm::ProcessConfiguration), DefineBehavior(ptr, ptr),
                  &edmcLcLProcessConfiguration_ShowMembers, &edmcLcLProcessConfiguration_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProcessConfiguration) );
      instance.SetNew(&new_edmcLcLProcessConfiguration);
      instance.SetNewArray(&newArray_edmcLcLProcessConfiguration);
      instance.SetDelete(&delete_edmcLcLProcessConfiguration);
      instance.SetDeleteArray(&deleteArray_edmcLcLProcessConfiguration);
      instance.SetDestructor(&destruct_edmcLcLProcessConfiguration);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProcessConfiguration*)
   {
      return GenerateInitInstanceLocal((::edm::ProcessConfiguration*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProcessConfiguration*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProcessConfiguration_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessConfiguration*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProcessConfigurationcLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProcessConfigurationcLcLTransients_Dictionary();
   static void *new_edmcLcLProcessConfigurationcLcLTransients(void *p = 0);
   static void *newArray_edmcLcLProcessConfigurationcLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLProcessConfigurationcLcLTransients(void *p);
   static void deleteArray_edmcLcLProcessConfigurationcLcLTransients(void *p);
   static void destruct_edmcLcLProcessConfigurationcLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProcessConfiguration::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProcessConfiguration::Transients) == sizeof(::ROOT::Shadow::edm::ProcessConfiguration::Transients));
      ::edm::ProcessConfiguration::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProcessConfiguration::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProcessConfiguration::Transients", "./DataFormats.h", 50,
                  typeid(::edm::ProcessConfiguration::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLProcessConfigurationcLcLTransients_ShowMembers, &edmcLcLProcessConfigurationcLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProcessConfiguration::Transients) );
      instance.SetNew(&new_edmcLcLProcessConfigurationcLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLProcessConfigurationcLcLTransients);
      instance.SetDelete(&delete_edmcLcLProcessConfigurationcLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLProcessConfigurationcLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLProcessConfigurationcLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProcessConfiguration::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::ProcessConfiguration::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProcessConfiguration::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProcessConfigurationcLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessConfiguration::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProcessHistory_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProcessHistory_Dictionary();
   static void *new_edmcLcLProcessHistory(void *p = 0);
   static void *newArray_edmcLcLProcessHistory(Long_t size, void *p);
   static void delete_edmcLcLProcessHistory(void *p);
   static void deleteArray_edmcLcLProcessHistory(void *p);
   static void destruct_edmcLcLProcessHistory(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProcessHistory*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProcessHistory) == sizeof(::ROOT::Shadow::edm::ProcessHistory));
      ::edm::ProcessHistory *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProcessHistory),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProcessHistory", "./DataFormats.h", 52,
                  typeid(::edm::ProcessHistory), DefineBehavior(ptr, ptr),
                  &edmcLcLProcessHistory_ShowMembers, &edmcLcLProcessHistory_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProcessHistory) );
      instance.SetNew(&new_edmcLcLProcessHistory);
      instance.SetNewArray(&newArray_edmcLcLProcessHistory);
      instance.SetDelete(&delete_edmcLcLProcessHistory);
      instance.SetDeleteArray(&deleteArray_edmcLcLProcessHistory);
      instance.SetDestructor(&destruct_edmcLcLProcessHistory);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProcessHistory*)
   {
      return GenerateInitInstanceLocal((::edm::ProcessHistory*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProcessHistory*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProcessHistory_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessHistory*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProcessHistorycLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProcessHistorycLcLTransients_Dictionary();
   static void *new_edmcLcLProcessHistorycLcLTransients(void *p = 0);
   static void *newArray_edmcLcLProcessHistorycLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLProcessHistorycLcLTransients(void *p);
   static void deleteArray_edmcLcLProcessHistorycLcLTransients(void *p);
   static void destruct_edmcLcLProcessHistorycLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProcessHistory::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProcessHistory::Transients) == sizeof(::ROOT::Shadow::edm::ProcessHistory::Transients));
      ::edm::ProcessHistory::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProcessHistory::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProcessHistory::Transients", "./DataFormats.h", 54,
                  typeid(::edm::ProcessHistory::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLProcessHistorycLcLTransients_ShowMembers, &edmcLcLProcessHistorycLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProcessHistory::Transients) );
      instance.SetNew(&new_edmcLcLProcessHistorycLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLProcessHistorycLcLTransients);
      instance.SetDelete(&delete_edmcLcLProcessHistorycLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLProcessHistorycLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLProcessHistorycLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProcessHistory::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::ProcessHistory::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProcessHistory::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProcessHistorycLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessHistory::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProductID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProductID_Dictionary();
   static void *new_edmcLcLProductID(void *p = 0);
   static void *newArray_edmcLcLProductID(Long_t size, void *p);
   static void delete_edmcLcLProductID(void *p);
   static void deleteArray_edmcLcLProductID(void *p);
   static void destruct_edmcLcLProductID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProductID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProductID) == sizeof(::ROOT::Shadow::edm::ProductID));
      ::edm::ProductID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProductID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProductID", "./DataFormats.h", 56,
                  typeid(::edm::ProductID), DefineBehavior(ptr, ptr),
                  &edmcLcLProductID_ShowMembers, &edmcLcLProductID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProductID) );
      instance.SetNew(&new_edmcLcLProductID);
      instance.SetNewArray(&newArray_edmcLcLProductID);
      instance.SetDelete(&delete_edmcLcLProductID);
      instance.SetDeleteArray(&deleteArray_edmcLcLProductID);
      instance.SetDestructor(&destruct_edmcLcLProductID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProductID*)
   {
      return GenerateInitInstanceLocal((::edm::ProductID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProductID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProductID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLStoredProductProvenance_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLStoredProductProvenance_Dictionary();
   static void *new_edmcLcLStoredProductProvenance(void *p = 0);
   static void *newArray_edmcLcLStoredProductProvenance(Long_t size, void *p);
   static void delete_edmcLcLStoredProductProvenance(void *p);
   static void deleteArray_edmcLcLStoredProductProvenance(void *p);
   static void destruct_edmcLcLStoredProductProvenance(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::StoredProductProvenance*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::StoredProductProvenance) == sizeof(::ROOT::Shadow::edm::StoredProductProvenance));
      ::edm::StoredProductProvenance *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::StoredProductProvenance),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::StoredProductProvenance", "./DataFormats.h", 57,
                  typeid(::edm::StoredProductProvenance), DefineBehavior(ptr, ptr),
                  &edmcLcLStoredProductProvenance_ShowMembers, &edmcLcLStoredProductProvenance_Dictionary, isa_proxy, 4,
                  sizeof(::edm::StoredProductProvenance) );
      instance.SetNew(&new_edmcLcLStoredProductProvenance);
      instance.SetNewArray(&newArray_edmcLcLStoredProductProvenance);
      instance.SetDelete(&delete_edmcLcLStoredProductProvenance);
      instance.SetDeleteArray(&deleteArray_edmcLcLStoredProductProvenance);
      instance.SetDestructor(&destruct_edmcLcLStoredProductProvenance);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::StoredProductProvenance*)
   {
      return GenerateInitInstanceLocal((::edm::StoredProductProvenance*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::StoredProductProvenance*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLStoredProductProvenance_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::StoredProductProvenance*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProductProvenance_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProductProvenance_Dictionary();
   static void *new_edmcLcLProductProvenance(void *p = 0);
   static void *newArray_edmcLcLProductProvenance(Long_t size, void *p);
   static void delete_edmcLcLProductProvenance(void *p);
   static void deleteArray_edmcLcLProductProvenance(void *p);
   static void destruct_edmcLcLProductProvenance(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProductProvenance*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProductProvenance) == sizeof(::ROOT::Shadow::edm::ProductProvenance));
      ::edm::ProductProvenance *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProductProvenance),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProductProvenance", "./DataFormats.h", 61,
                  typeid(::edm::ProductProvenance), DefineBehavior(ptr, ptr),
                  &edmcLcLProductProvenance_ShowMembers, &edmcLcLProductProvenance_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProductProvenance) );
      instance.SetNew(&new_edmcLcLProductProvenance);
      instance.SetNewArray(&newArray_edmcLcLProductProvenance);
      instance.SetDelete(&delete_edmcLcLProductProvenance);
      instance.SetDeleteArray(&deleteArray_edmcLcLProductProvenance);
      instance.SetDestructor(&destruct_edmcLcLProductProvenance);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProductProvenance*)
   {
      return GenerateInitInstanceLocal((::edm::ProductProvenance*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProductProvenance*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProductProvenance_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductProvenance*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProductRegistry_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProductRegistry_Dictionary();
   static void *new_edmcLcLProductRegistry(void *p = 0);
   static void *newArray_edmcLcLProductRegistry(Long_t size, void *p);
   static void delete_edmcLcLProductRegistry(void *p);
   static void deleteArray_edmcLcLProductRegistry(void *p);
   static void destruct_edmcLcLProductRegistry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProductRegistry*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProductRegistry) == sizeof(::ROOT::Shadow::edm::ProductRegistry));
      ::edm::ProductRegistry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProductRegistry),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProductRegistry", "./DataFormats.h", 65,
                  typeid(::edm::ProductRegistry), DefineBehavior(ptr, ptr),
                  &edmcLcLProductRegistry_ShowMembers, &edmcLcLProductRegistry_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProductRegistry) );
      instance.SetNew(&new_edmcLcLProductRegistry);
      instance.SetNewArray(&newArray_edmcLcLProductRegistry);
      instance.SetDelete(&delete_edmcLcLProductRegistry);
      instance.SetDeleteArray(&deleteArray_edmcLcLProductRegistry);
      instance.SetDestructor(&destruct_edmcLcLProductRegistry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProductRegistry*)
   {
      return GenerateInitInstanceLocal((::edm::ProductRegistry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProductRegistry*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProductRegistry_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductRegistry*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLProductRegistrycLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLProductRegistrycLcLTransients_Dictionary();
   static void *new_edmcLcLProductRegistrycLcLTransients(void *p = 0);
   static void *newArray_edmcLcLProductRegistrycLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLProductRegistrycLcLTransients(void *p);
   static void deleteArray_edmcLcLProductRegistrycLcLTransients(void *p);
   static void destruct_edmcLcLProductRegistrycLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::ProductRegistry::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::ProductRegistry::Transients) == sizeof(::ROOT::Shadow::edm::ProductRegistry::Transients));
      ::edm::ProductRegistry::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::ProductRegistry::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::ProductRegistry::Transients", "./DataFormats.h", 67,
                  typeid(::edm::ProductRegistry::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLProductRegistrycLcLTransients_ShowMembers, &edmcLcLProductRegistrycLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::ProductRegistry::Transients) );
      instance.SetNew(&new_edmcLcLProductRegistrycLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLProductRegistrycLcLTransients);
      instance.SetDelete(&delete_edmcLcLProductRegistrycLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLProductRegistrycLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLProductRegistrycLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::ProductRegistry::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::ProductRegistry::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::ProductRegistry::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLProductRegistrycLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductRegistry::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLRunID_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLRunID_Dictionary();
   static void *new_edmcLcLRunID(void *p = 0);
   static void *newArray_edmcLcLRunID(Long_t size, void *p);
   static void delete_edmcLcLRunID(void *p);
   static void deleteArray_edmcLcLRunID(void *p);
   static void destruct_edmcLcLRunID(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::RunID*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::RunID) == sizeof(::ROOT::Shadow::edm::RunID));
      ::edm::RunID *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::RunID),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::RunID", "./DataFormats.h", 69,
                  typeid(::edm::RunID), DefineBehavior(ptr, ptr),
                  &edmcLcLRunID_ShowMembers, &edmcLcLRunID_Dictionary, isa_proxy, 4,
                  sizeof(::edm::RunID) );
      instance.SetNew(&new_edmcLcLRunID);
      instance.SetNewArray(&newArray_edmcLcLRunID);
      instance.SetDelete(&delete_edmcLcLRunID);
      instance.SetDeleteArray(&deleteArray_edmcLcLRunID);
      instance.SetDestructor(&destruct_edmcLcLRunID);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::RunID*)
   {
      return GenerateInitInstanceLocal((::edm::RunID*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::RunID*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLRunID_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::RunID*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTimestamp_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTimestamp_Dictionary();
   static void *new_edmcLcLTimestamp(void *p = 0);
   static void *newArray_edmcLcLTimestamp(Long_t size, void *p);
   static void delete_edmcLcLTimestamp(void *p);
   static void deleteArray_edmcLcLTimestamp(void *p);
   static void destruct_edmcLcLTimestamp(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Timestamp*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Timestamp) == sizeof(::ROOT::Shadow::edm::Timestamp));
      ::edm::Timestamp *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Timestamp),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Timestamp", "./DataFormats.h", 70,
                  typeid(::edm::Timestamp), DefineBehavior(ptr, ptr),
                  &edmcLcLTimestamp_ShowMembers, &edmcLcLTimestamp_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Timestamp) );
      instance.SetNew(&new_edmcLcLTimestamp);
      instance.SetNewArray(&newArray_edmcLcLTimestamp);
      instance.SetDelete(&delete_edmcLcLTimestamp);
      instance.SetDeleteArray(&deleteArray_edmcLcLTimestamp);
      instance.SetDestructor(&destruct_edmcLcLTimestamp);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Timestamp*)
   {
      return GenerateInitInstanceLocal((::edm::Timestamp*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Timestamp*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTimestamp_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Timestamp*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLIndexIntoFile_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLIndexIntoFile_Dictionary();
   static void *new_edmcLcLIndexIntoFile(void *p = 0);
   static void *newArray_edmcLcLIndexIntoFile(Long_t size, void *p);
   static void delete_edmcLcLIndexIntoFile(void *p);
   static void deleteArray_edmcLcLIndexIntoFile(void *p);
   static void destruct_edmcLcLIndexIntoFile(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::IndexIntoFile*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::IndexIntoFile) == sizeof(::ROOT::Shadow::edm::IndexIntoFile));
      ::edm::IndexIntoFile *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::IndexIntoFile),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::IndexIntoFile", "./DataFormats.h", 71,
                  typeid(::edm::IndexIntoFile), DefineBehavior(ptr, ptr),
                  &edmcLcLIndexIntoFile_ShowMembers, &edmcLcLIndexIntoFile_Dictionary, isa_proxy, 4,
                  sizeof(::edm::IndexIntoFile) );
      instance.SetNew(&new_edmcLcLIndexIntoFile);
      instance.SetNewArray(&newArray_edmcLcLIndexIntoFile);
      instance.SetDelete(&delete_edmcLcLIndexIntoFile);
      instance.SetDeleteArray(&deleteArray_edmcLcLIndexIntoFile);
      instance.SetDestructor(&destruct_edmcLcLIndexIntoFile);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::IndexIntoFile*)
   {
      return GenerateInitInstanceLocal((::edm::IndexIntoFile*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::IndexIntoFile*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLIndexIntoFile_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLIndexIntoFilecLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLIndexIntoFilecLcLTransients_Dictionary();
   static void *new_edmcLcLIndexIntoFilecLcLTransients(void *p = 0);
   static void *newArray_edmcLcLIndexIntoFilecLcLTransients(Long_t size, void *p);
   static void delete_edmcLcLIndexIntoFilecLcLTransients(void *p);
   static void deleteArray_edmcLcLIndexIntoFilecLcLTransients(void *p);
   static void destruct_edmcLcLIndexIntoFilecLcLTransients(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::IndexIntoFile::Transients*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::IndexIntoFile::Transients) == sizeof(::ROOT::Shadow::edm::IndexIntoFile::Transients));
      ::edm::IndexIntoFile::Transients *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::IndexIntoFile::Transients),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::IndexIntoFile::Transients", "./DataFormats.h", 73,
                  typeid(::edm::IndexIntoFile::Transients), DefineBehavior(ptr, ptr),
                  &edmcLcLIndexIntoFilecLcLTransients_ShowMembers, &edmcLcLIndexIntoFilecLcLTransients_Dictionary, isa_proxy, 4,
                  sizeof(::edm::IndexIntoFile::Transients) );
      instance.SetNew(&new_edmcLcLIndexIntoFilecLcLTransients);
      instance.SetNewArray(&newArray_edmcLcLIndexIntoFilecLcLTransients);
      instance.SetDelete(&delete_edmcLcLIndexIntoFilecLcLTransients);
      instance.SetDeleteArray(&deleteArray_edmcLcLIndexIntoFilecLcLTransients);
      instance.SetDestructor(&destruct_edmcLcLIndexIntoFilecLcLTransients);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::IndexIntoFile::Transients*)
   {
      return GenerateInitInstanceLocal((::edm::IndexIntoFile::Transients*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::IndexIntoFile::Transients*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLIndexIntoFilecLcLTransients_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile::Transients*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLIndexIntoFilecLcLRunOrLumiEntry_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLIndexIntoFilecLcLRunOrLumiEntry_Dictionary();
   static void *new_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p = 0);
   static void *newArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(Long_t size, void *p);
   static void delete_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p);
   static void deleteArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p);
   static void destruct_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::IndexIntoFile::RunOrLumiEntry*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::IndexIntoFile::RunOrLumiEntry) == sizeof(::ROOT::Shadow::edm::IndexIntoFile::RunOrLumiEntry));
      ::edm::IndexIntoFile::RunOrLumiEntry *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::IndexIntoFile::RunOrLumiEntry),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::IndexIntoFile::RunOrLumiEntry", "./DataFormats.h", 74,
                  typeid(::edm::IndexIntoFile::RunOrLumiEntry), DefineBehavior(ptr, ptr),
                  &edmcLcLIndexIntoFilecLcLRunOrLumiEntry_ShowMembers, &edmcLcLIndexIntoFilecLcLRunOrLumiEntry_Dictionary, isa_proxy, 4,
                  sizeof(::edm::IndexIntoFile::RunOrLumiEntry) );
      instance.SetNew(&new_edmcLcLIndexIntoFilecLcLRunOrLumiEntry);
      instance.SetNewArray(&newArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry);
      instance.SetDelete(&delete_edmcLcLIndexIntoFilecLcLRunOrLumiEntry);
      instance.SetDeleteArray(&deleteArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry);
      instance.SetDestructor(&destruct_edmcLcLIndexIntoFilecLcLRunOrLumiEntry);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::IndexIntoFile::RunOrLumiEntry*)
   {
      return GenerateInitInstanceLocal((::edm::IndexIntoFile::RunOrLumiEntry*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::IndexIntoFile::RunOrLumiEntry*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLIndexIntoFilecLcLRunOrLumiEntry_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile::RunOrLumiEntry*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_Dictionary();
   static void *new_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p);
   static void destruct_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::PxPyPzE4D<float>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::PxPyPzE4D<float>) == sizeof(::ROOT::Shadow::ROOT::Math::PxPyPzE4DlEfloatgR));
      ::ROOT::Math::PxPyPzE4D<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::PxPyPzE4D<float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::PxPyPzE4D<float>", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/include/Math/GenVector/PxPyPzE4D.h", 46,
                  typeid(::ROOT::Math::PxPyPzE4D<float>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_ShowMembers, &ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::PxPyPzE4D<float>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::PxPyPzE4D<float>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::PxPyPzE4D<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::PxPyPzE4D<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::PxPyPzE4D<float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary();
   static void *new_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);
   static void destruct_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >) == sizeof(::ROOT::Shadow::ROOT::Math::LorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
      ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/include/Math/GenVector/LorentzVector.h", 54,
                  typeid(::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_ShowMembers, &ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >) );
      instance.SetNew(&new_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_Dictionary();
   static void *new_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p = 0);
   static void *newArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(Long_t size, void *p);
   static void delete_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p);
   static void deleteArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p);
   static void destruct_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>) == sizeof(::ROOT::Shadow::ROOT::Math::PositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
      ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>),0);
      static ::ROOT::TGenericClassInfo 
         instance("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/include/Math/GenVector/PositionVector3D.h", 63,
                  typeid(::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>), DefineBehavior(ptr, ptr),
                  &ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_ShowMembers, &ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_Dictionary, isa_proxy, 4,
                  sizeof(::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>) );
      instance.SetNew(&new_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
      instance.SetNewArray(&newArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
      instance.SetDelete(&delete_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
      instance.SetDeleteArray(&deleteArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
      instance.SetDestructor(&destruct_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)
   {
      return GenerateInitInstanceLocal((::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlETStringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlETStringgR_Dictionary();
   static void *new_edmcLcLWrapperlETStringgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlETStringgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlETStringgR(void *p);
   static void deleteArray_edmcLcLWrapperlETStringgR(void *p);
   static void destruct_edmcLcLWrapperlETStringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<TString>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<TString>) == sizeof(::ROOT::Shadow::edm::WrapperlETStringgR));
      ::edm::Wrapper<TString> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<TString>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<TString>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<TString>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlETStringgR_ShowMembers, &edmcLcLWrapperlETStringgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<TString>) );
      instance.SetNew(&new_edmcLcLWrapperlETStringgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlETStringgR);
      instance.SetDelete(&delete_edmcLcLWrapperlETStringgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlETStringgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlETStringgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<TString>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<TString>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<TString>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlETStringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<TString>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEdoublegR_Dictionary();
   static void *new_edmcLcLWrapperlEdoublegR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEdoublegR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEdoublegR(void *p);
   static void deleteArray_edmcLcLWrapperlEdoublegR(void *p);
   static void destruct_edmcLcLWrapperlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<double>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<double>) == sizeof(::ROOT::Shadow::edm::WrapperlEdoublegR));
      ::edm::Wrapper<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<double>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<double>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEdoublegR_ShowMembers, &edmcLcLWrapperlEdoublegR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<double>) );
      instance.SetNew(&new_edmcLcLWrapperlEdoublegR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEdoublegR);
      instance.SetDelete(&delete_edmcLcLWrapperlEdoublegR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEdoublegR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEdoublegR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<double>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<double>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEfloatgR_Dictionary();
   static void *new_edmcLcLWrapperlEfloatgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEfloatgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEfloatgR(void *p);
   static void deleteArray_edmcLcLWrapperlEfloatgR(void *p);
   static void destruct_edmcLcLWrapperlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<float>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<float>) == sizeof(::ROOT::Shadow::edm::WrapperlEfloatgR));
      ::edm::Wrapper<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<float>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<float>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEfloatgR_ShowMembers, &edmcLcLWrapperlEfloatgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<float>) );
      instance.SetNew(&new_edmcLcLWrapperlEfloatgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEfloatgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEfloatgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEfloatgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEfloatgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<float>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<float>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEintgR_Dictionary();
   static void *new_edmcLcLWrapperlEintgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEintgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEintgR(void *p);
   static void deleteArray_edmcLcLWrapperlEintgR(void *p);
   static void destruct_edmcLcLWrapperlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<int>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<int>) == sizeof(::ROOT::Shadow::edm::WrapperlEintgR));
      ::edm::Wrapper<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<int>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<int>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEintgR_ShowMembers, &edmcLcLWrapperlEintgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<int>) );
      instance.SetNew(&new_edmcLcLWrapperlEintgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEintgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEintgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEintgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<int>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEunsignedsPintgR_Dictionary();
   static void *new_edmcLcLWrapperlEunsignedsPintgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEunsignedsPintgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEunsignedsPintgR(void *p);
   static void deleteArray_edmcLcLWrapperlEunsignedsPintgR(void *p);
   static void destruct_edmcLcLWrapperlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<unsigned int>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<unsigned int>) == sizeof(::ROOT::Shadow::edm::WrapperlEunsignedsPintgR));
      ::edm::Wrapper<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<unsigned int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<unsigned int>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<unsigned int>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEunsignedsPintgR_ShowMembers, &edmcLcLWrapperlEunsignedsPintgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<unsigned int>) );
      instance.SetNew(&new_edmcLcLWrapperlEunsignedsPintgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEunsignedsPintgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEunsignedsPintgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEunsignedsPintgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<unsigned int>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<unsigned int>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEunsignedsPintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unsigned int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR));
      ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
      ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >) == sizeof(::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
      ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers, &edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >) );
      instance.SetNew(&new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >) == sizeof(::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
      ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers, &edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >) );
      instance.SetNew(&new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<TString,allocator<TString> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<TString,allocator<TString> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR));
      ::edm::Wrapper<vector<TString,allocator<TString> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<TString,allocator<TString> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<TString,allocator<TString> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<TString,allocator<TString> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<TString,allocator<TString> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<TString,allocator<TString> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<TString,allocator<TString> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<TString,allocator<TString> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<TString,allocator<TString> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<double,allocator<double> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<double,allocator<double> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR));
      ::edm::Wrapper<vector<double,allocator<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<double,allocator<double> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<double,allocator<double> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<double,allocator<double> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<double,allocator<double> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<double,allocator<double> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<double,allocator<double> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<double,allocator<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<double,allocator<double> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<float,allocator<float> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<float,allocator<float> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR));
      ::edm::Wrapper<vector<float,allocator<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<float,allocator<float> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<float,allocator<float> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<float,allocator<float> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<float,allocator<float> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<float,allocator<float> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<float,allocator<float> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<float,allocator<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<float,allocator<float> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<int,allocator<int> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<int,allocator<int> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR));
      ::edm::Wrapper<vector<int,allocator<int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<int,allocator<int> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<int,allocator<int> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<int,allocator<int> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<int,allocator<int> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<int,allocator<int> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<int,allocator<int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<int,allocator<int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<int,allocator<int> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR));
      ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
      ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE0gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE0gR_Dictionary();
   static void *new_edmcLcLHashlE0gR(void *p = 0);
   static void *newArray_edmcLcLHashlE0gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE0gR(void *p);
   static void deleteArray_edmcLcLHashlE0gR(void *p);
   static void destruct_edmcLcLHashlE0gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<0>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<0>) == sizeof(::ROOT::Shadow::edm::HashlE0gR));
      ::edm::Hash<0> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<0>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<0>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<0>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE0gR_ShowMembers, &edmcLcLHashlE0gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<0>) );
      instance.SetNew(&new_edmcLcLHashlE0gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE0gR);
      instance.SetDelete(&delete_edmcLcLHashlE0gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE0gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE0gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<0>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<0>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<0>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE0gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<0>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE1gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE1gR_Dictionary();
   static void *new_edmcLcLHashlE1gR(void *p = 0);
   static void *newArray_edmcLcLHashlE1gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE1gR(void *p);
   static void deleteArray_edmcLcLHashlE1gR(void *p);
   static void destruct_edmcLcLHashlE1gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<1>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<1>) == sizeof(::ROOT::Shadow::edm::HashlE1gR));
      ::edm::Hash<1> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<1>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<1>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<1>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE1gR_ShowMembers, &edmcLcLHashlE1gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<1>) );
      instance.SetNew(&new_edmcLcLHashlE1gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE1gR);
      instance.SetDelete(&delete_edmcLcLHashlE1gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE1gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE1gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<1>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<1>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<1>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE1gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<1>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE2gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE2gR_Dictionary();
   static void *new_edmcLcLHashlE2gR(void *p = 0);
   static void *newArray_edmcLcLHashlE2gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE2gR(void *p);
   static void deleteArray_edmcLcLHashlE2gR(void *p);
   static void destruct_edmcLcLHashlE2gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<2>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<2>) == sizeof(::ROOT::Shadow::edm::HashlE2gR));
      ::edm::Hash<2> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<2>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<2>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<2>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE2gR_ShowMembers, &edmcLcLHashlE2gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<2>) );
      instance.SetNew(&new_edmcLcLHashlE2gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE2gR);
      instance.SetDelete(&delete_edmcLcLHashlE2gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE2gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE2gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<2>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<2>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<2>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE2gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<2>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE3gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE3gR_Dictionary();
   static void *new_edmcLcLHashlE3gR(void *p = 0);
   static void *newArray_edmcLcLHashlE3gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE3gR(void *p);
   static void deleteArray_edmcLcLHashlE3gR(void *p);
   static void destruct_edmcLcLHashlE3gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<3>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<3>) == sizeof(::ROOT::Shadow::edm::HashlE3gR));
      ::edm::Hash<3> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<3>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<3>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<3>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE3gR_ShowMembers, &edmcLcLHashlE3gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<3>) );
      instance.SetNew(&new_edmcLcLHashlE3gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE3gR);
      instance.SetDelete(&delete_edmcLcLHashlE3gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE3gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE3gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<3>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<3>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<3>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE3gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<3>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE4gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE4gR_Dictionary();
   static void *new_edmcLcLHashlE4gR(void *p = 0);
   static void *newArray_edmcLcLHashlE4gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE4gR(void *p);
   static void deleteArray_edmcLcLHashlE4gR(void *p);
   static void destruct_edmcLcLHashlE4gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<4>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<4>) == sizeof(::ROOT::Shadow::edm::HashlE4gR));
      ::edm::Hash<4> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<4>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<4>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<4>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE4gR_ShowMembers, &edmcLcLHashlE4gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<4>) );
      instance.SetNew(&new_edmcLcLHashlE4gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE4gR);
      instance.SetDelete(&delete_edmcLcLHashlE4gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE4gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE4gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<4>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<4>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<4>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE4gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<4>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLHashlE5gR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLHashlE5gR_Dictionary();
   static void *new_edmcLcLHashlE5gR(void *p = 0);
   static void *newArray_edmcLcLHashlE5gR(Long_t size, void *p);
   static void delete_edmcLcLHashlE5gR(void *p);
   static void deleteArray_edmcLcLHashlE5gR(void *p);
   static void destruct_edmcLcLHashlE5gR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Hash<5>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Hash<5>) == sizeof(::ROOT::Shadow::edm::HashlE5gR));
      ::edm::Hash<5> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Hash<5>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Hash<5>", "./DataFormats.h", 40,
                  typeid(::edm::Hash<5>), DefineBehavior(ptr, ptr),
                  &edmcLcLHashlE5gR_ShowMembers, &edmcLcLHashlE5gR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Hash<5>) );
      instance.SetNew(&new_edmcLcLHashlE5gR);
      instance.SetNewArray(&newArray_edmcLcLHashlE5gR);
      instance.SetDelete(&delete_edmcLcLHashlE5gR);
      instance.SetDeleteArray(&deleteArray_edmcLcLHashlE5gR);
      instance.SetDestructor(&destruct_edmcLcLHashlE5gR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Hash<5>*)
   {
      return GenerateInitInstanceLocal((::edm::Hash<5>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Hash<5>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLHashlE5gR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<5>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::BranchDescription::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::BranchDescription::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLBranchDescriptioncLcLTransientsgR));
      ::edm::Transient<edm::BranchDescription::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::BranchDescription::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::BranchDescription::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::BranchDescription::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::BranchDescription::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::BranchDescription::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::BranchDescription::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::BranchDescription::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::BranchDescription::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::EventEntryDescription::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::EventEntryDescription::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR));
      ::edm::Transient<edm::EventEntryDescription::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::EventEntryDescription::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::EventEntryDescription::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::EventEntryDescription::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::EventEntryDescription::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::EventEntryDescription::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::EventEntryDescription::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryDescription::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryDescription::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::EventEntryInfo::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::EventEntryInfo::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLEventEntryInfocLcLTransientsgR));
      ::edm::Transient<edm::EventEntryInfo::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::EventEntryInfo::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::EventEntryInfo::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::EventEntryInfo::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::EventEntryInfo::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::EventEntryInfo::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::EventEntryInfo::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryInfo::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryInfo::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::FileIndex::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::FileIndex::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLFileIndexcLcLTransientsgR));
      ::edm::Transient<edm::FileIndex::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::FileIndex::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::FileIndex::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::FileIndex::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::FileIndex::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::FileIndex::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::FileIndex::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::FileIndex::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::FileIndex::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::Parentage::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::Parentage::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLParentagecLcLTransientsgR));
      ::edm::Transient<edm::Parentage::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::Parentage::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::Parentage::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::Parentage::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::Parentage::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::Parentage::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::Parentage::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::Parentage::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::Parentage::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::ProcessConfiguration::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::ProcessConfiguration::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLProcessConfigurationcLcLTransientsgR));
      ::edm::Transient<edm::ProcessConfiguration::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::ProcessConfiguration::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::ProcessConfiguration::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::ProcessConfiguration::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::ProcessConfiguration::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::ProcessConfiguration::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::ProcessConfiguration::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessConfiguration::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessConfiguration::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::ProcessHistory::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::ProcessHistory::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLProcessHistorycLcLTransientsgR));
      ::edm::Transient<edm::ProcessHistory::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::ProcessHistory::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::ProcessHistory::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::ProcessHistory::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::ProcessHistory::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::ProcessHistory::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::ProcessHistory::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessHistory::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessHistory::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::ProductProvenance::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::ProductProvenance::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLProductProvenancecLcLTransientsgR));
      ::edm::Transient<edm::ProductProvenance::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::ProductProvenance::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::ProductProvenance::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::ProductProvenance::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::ProductProvenance::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::ProductProvenance::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::ProductProvenance::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductProvenance::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductProvenance::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::ProductRegistry::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::ProductRegistry::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLProductRegistrycLcLTransientsgR));
      ::edm::Transient<edm::ProductRegistry::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::ProductRegistry::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::ProductRegistry::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::ProductRegistry::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::ProductRegistry::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::ProductRegistry::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::ProductRegistry::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductRegistry::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductRegistry::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_Dictionary();
   static void *new_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p = 0);
   static void *newArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(Long_t size, void *p);
   static void delete_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p);
   static void deleteArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p);
   static void destruct_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Transient<edm::IndexIntoFile::Transients>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Transient<edm::IndexIntoFile::Transients>) == sizeof(::ROOT::Shadow::edm::TransientlEedmcLcLIndexIntoFilecLcLTransientsgR));
      ::edm::Transient<edm::IndexIntoFile::Transients> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Transient<edm::IndexIntoFile::Transients>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Transient<edm::IndexIntoFile::Transients>", "./DataFormats.h", 76,
                  typeid(::edm::Transient<edm::IndexIntoFile::Transients>), DefineBehavior(ptr, ptr),
                  &edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_ShowMembers, &edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Transient<edm::IndexIntoFile::Transients>) );
      instance.SetNew(&new_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
      instance.SetNewArray(&newArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
      instance.SetDelete(&delete_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
      instance.SetDestructor(&destruct_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Transient<edm::IndexIntoFile::Transients>*)
   {
      return GenerateInitInstanceLocal((::edm::Transient<edm::IndexIntoFile::Transients>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Transient<edm::IndexIntoFile::Transients>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::IndexIntoFile::Transients>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_Dictionary();
   static void *new_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p = 0);
   static void *newArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(Long_t size, void *p);
   static void delete_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p);
   static void deleteArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p);
   static void destruct_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::BranchKey,edm::BranchDescription>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(pair<edm::BranchKey,edm::BranchDescription>) == sizeof(::ROOT::Shadow::pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
      pair<edm::BranchKey,edm::BranchDescription> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::BranchKey,edm::BranchDescription>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::BranchKey,edm::BranchDescription>", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/utility", 17,
                  typeid(pair<edm::BranchKey,edm::BranchDescription>), DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_ShowMembers, &pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::BranchKey,edm::BranchDescription>) );
      instance.SetNew(&new_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
      instance.SetNewArray(&newArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
      instance.SetDelete(&delete_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
      instance.SetDestructor(&destruct_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<edm::BranchKey,edm::BranchDescription>*)
   {
      return GenerateInitInstanceLocal((pair<edm::BranchKey,edm::BranchDescription>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<edm::BranchKey,edm::BranchDescription>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<edm::BranchKey,edm::BranchDescription>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_Dictionary();
   static void *new_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p = 0);
   static void *newArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(Long_t size, void *p);
   static void delete_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p);
   static void deleteArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p);
   static void destruct_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::Hash<1>,edm::ParameterSetBlob>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(pair<edm::Hash<1>,edm::ParameterSetBlob>) == sizeof(::ROOT::Shadow::pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
      pair<edm::Hash<1>,edm::ParameterSetBlob> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::Hash<1>,edm::ParameterSetBlob>),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::Hash<1>,edm::ParameterSetBlob>", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/utility", 17,
                  typeid(pair<edm::Hash<1>,edm::ParameterSetBlob>), DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_ShowMembers, &pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::Hash<1>,edm::ParameterSetBlob>) );
      instance.SetNew(&new_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
      instance.SetNewArray(&newArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
      instance.SetDelete(&delete_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
      instance.SetDestructor(&destruct_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<edm::Hash<1>,edm::ParameterSetBlob>*)
   {
      return GenerateInitInstanceLocal((pair<edm::Hash<1>,edm::ParameterSetBlob>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<edm::Hash<1>,edm::ParameterSetBlob>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<edm::Hash<1>,edm::ParameterSetBlob>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEboolgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEboolgR_Dictionary();
   static void *new_edmcLcLWrapperlEboolgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEboolgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEboolgR(void *p);
   static void deleteArray_edmcLcLWrapperlEboolgR(void *p);
   static void destruct_edmcLcLWrapperlEboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<bool>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<bool>) == sizeof(::ROOT::Shadow::edm::WrapperlEboolgR));
      ::edm::Wrapper<bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<bool>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<bool>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<bool>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEboolgR_ShowMembers, &edmcLcLWrapperlEboolgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<bool>) );
      instance.SetNew(&new_edmcLcLWrapperlEboolgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEboolgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEboolgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEboolgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEboolgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<bool>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<bool>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEboolgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<bool>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_Dictionary();
   static void *new_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p);
   static void deleteArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p);
   static void destruct_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<vector<bool,allocator<bool> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<vector<bool,allocator<bool> > >) == sizeof(::ROOT::Shadow::edm::WrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR));
      ::edm::Wrapper<vector<bool,allocator<bool> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<vector<bool,allocator<bool> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<vector<bool,allocator<bool> > >", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<vector<bool,allocator<bool> > >), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_ShowMembers, &edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<vector<bool,allocator<bool> > >) );
      instance.SetNew(&new_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<vector<bool,allocator<bool> > >*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<vector<bool,allocator<bool> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<vector<bool,allocator<bool> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<bool,allocator<bool> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlEULong64_tgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlEULong64_tgR_Dictionary();
   static void *new_edmcLcLWrapperlEULong64_tgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlEULong64_tgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlEULong64_tgR(void *p);
   static void deleteArray_edmcLcLWrapperlEULong64_tgR(void *p);
   static void destruct_edmcLcLWrapperlEULong64_tgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<ULong64_t>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<ULong64_t>) == sizeof(::ROOT::Shadow::edm::WrapperlEunsignedsPlongsPlonggR));
      ::edm::Wrapper<ULong64_t> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<ULong64_t>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<ULong64_t>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<ULong64_t>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlEULong64_tgR_ShowMembers, &edmcLcLWrapperlEULong64_tgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<ULong64_t>) );
      instance.SetNew(&new_edmcLcLWrapperlEULong64_tgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlEULong64_tgR);
      instance.SetDelete(&delete_edmcLcLWrapperlEULong64_tgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlEULong64_tgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlEULong64_tgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<ULong64_t>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<ULong64_t>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<ULong64_t>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlEULong64_tgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ULong64_t>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void edmcLcLWrapperlETBitsgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void edmcLcLWrapperlETBitsgR_Dictionary();
   static void *new_edmcLcLWrapperlETBitsgR(void *p = 0);
   static void *newArray_edmcLcLWrapperlETBitsgR(Long_t size, void *p);
   static void delete_edmcLcLWrapperlETBitsgR(void *p);
   static void deleteArray_edmcLcLWrapperlETBitsgR(void *p);
   static void destruct_edmcLcLWrapperlETBitsgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const ::edm::Wrapper<TBits>*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(::edm::Wrapper<TBits>) == sizeof(::ROOT::Shadow::edm::WrapperlETBitsgR));
      ::edm::Wrapper<TBits> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(::edm::Wrapper<TBits>),0);
      static ::ROOT::TGenericClassInfo 
         instance("edm::Wrapper<TBits>", "./Wrapper.h", 10,
                  typeid(::edm::Wrapper<TBits>), DefineBehavior(ptr, ptr),
                  &edmcLcLWrapperlETBitsgR_ShowMembers, &edmcLcLWrapperlETBitsgR_Dictionary, isa_proxy, 4,
                  sizeof(::edm::Wrapper<TBits>) );
      instance.SetNew(&new_edmcLcLWrapperlETBitsgR);
      instance.SetNewArray(&newArray_edmcLcLWrapperlETBitsgR);
      instance.SetDelete(&delete_edmcLcLWrapperlETBitsgR);
      instance.SetDeleteArray(&deleteArray_edmcLcLWrapperlETBitsgR);
      instance.SetDestructor(&destruct_edmcLcLWrapperlETBitsgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const ::edm::Wrapper<TBits>*)
   {
      return GenerateInitInstanceLocal((::edm::Wrapper<TBits>*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const ::edm::Wrapper<TBits>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void edmcLcLWrapperlETBitsgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<TBits>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   void pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_Dictionary();
   static void *new_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p = 0);
   static void *newArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(Long_t size, void *p);
   static void delete_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p);
   static void deleteArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p);
   static void destruct_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)
   {
      // Make sure the shadow class has the right sizeof
      R__ASSERT(sizeof(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >) == sizeof(::ROOT::Shadow::pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
      pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >", "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/utility", 17,
                  typeid(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >), DefineBehavior(ptr, ptr),
                  &pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_ShowMembers, &pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >) );
      instance.SetNew(&new_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
      instance.SetNewArray(&newArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
      instance.SetDelete(&delete_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
      instance.SetDestructor(&destruct_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
      return &instance;
   }
   TGenericClassInfo *GenerateInitInstance(const pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)
   {
      return GenerateInitInstanceLocal((pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)0);
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::PxPyPzE4D<float>.
      typedef ::ROOT::Shadow::ROOT::Math::PxPyPzE4DlEfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::PxPyPzE4D<float>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fX", &sobj->fX);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fY", &sobj->fY);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fZ", &sobj->fZ);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fT", &sobj->fT);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::PxPyPzE4D<float> : new ::ROOT::Math::PxPyPzE4D<float>;
   }
   static void *newArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::PxPyPzE4D<float>[nElements] : new ::ROOT::Math::PxPyPzE4D<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p) {
      delete ((::ROOT::Math::PxPyPzE4D<float>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p) {
      delete [] ((::ROOT::Math::PxPyPzE4D<float>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void *p) {
      typedef ::ROOT::Math::PxPyPzE4D<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::PxPyPzE4D<float>

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >.
      typedef ::ROOT::Shadow::ROOT::Math::LorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCoordinates", (void*)&sobj->fCoordinates);
      R__insp.InspectMember("ROOT::Math::PxPyPzE4D<float>", (void*)&sobj->fCoordinates, "fCoordinates.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > : new ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >;
   }
   static void *newArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >[nElements] : new ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      delete ((::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      delete [] ((::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)p);
   }
   static void destruct_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      typedef ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >

//______________________________________________________________________________
namespace ROOT {
   void ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>.
      typedef ::ROOT::Shadow::ROOT::Math::PositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "fCoordinates", (void*)&sobj->fCoordinates);
      R__insp.InspectMember("ROOT::Math::Cartesian3D<float>", (void*)&sobj->fCoordinates, "fCoordinates.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> : new ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>;
   }
   static void *newArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>[nElements] : new ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>[nElements];
   }
   // Wrapper around operator delete
   static void delete_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p) {
      delete ((::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)p);
   }
   static void deleteArray_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p) {
      delete [] ((::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)p);
   }
   static void destruct_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void *p) {
      typedef ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlETStringgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<TString>.
      typedef ::ROOT::Shadow::edm::WrapperlETStringgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<TString>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("TString", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<TString>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlETStringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<TString> : new ::edm::Wrapper<TString>;
   }
   static void *newArray_edmcLcLWrapperlETStringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<TString>[nElements] : new ::edm::Wrapper<TString>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlETStringgR(void *p) {
      delete ((::edm::Wrapper<TString>*)p);
   }
   static void deleteArray_edmcLcLWrapperlETStringgR(void *p) {
      delete [] ((::edm::Wrapper<TString>*)p);
   }
   static void destruct_edmcLcLWrapperlETStringgR(void *p) {
      typedef ::edm::Wrapper<TString> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<TString>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<double>.
      typedef ::ROOT::Shadow::edm::WrapperlEdoublegR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<double>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<double>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<double> : new ::edm::Wrapper<double>;
   }
   static void *newArray_edmcLcLWrapperlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<double>[nElements] : new ::edm::Wrapper<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEdoublegR(void *p) {
      delete ((::edm::Wrapper<double>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEdoublegR(void *p) {
      delete [] ((::edm::Wrapper<double>*)p);
   }
   static void destruct_edmcLcLWrapperlEdoublegR(void *p) {
      typedef ::edm::Wrapper<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<double>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<float>.
      typedef ::ROOT::Shadow::edm::WrapperlEfloatgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<float>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<float>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<float> : new ::edm::Wrapper<float>;
   }
   static void *newArray_edmcLcLWrapperlEfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<float>[nElements] : new ::edm::Wrapper<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEfloatgR(void *p) {
      delete ((::edm::Wrapper<float>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEfloatgR(void *p) {
      delete [] ((::edm::Wrapper<float>*)p);
   }
   static void destruct_edmcLcLWrapperlEfloatgR(void *p) {
      typedef ::edm::Wrapper<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<float>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<int>.
      typedef ::ROOT::Shadow::edm::WrapperlEintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<int>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<int>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<int> : new ::edm::Wrapper<int>;
   }
   static void *newArray_edmcLcLWrapperlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<int>[nElements] : new ::edm::Wrapper<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEintgR(void *p) {
      delete ((::edm::Wrapper<int>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEintgR(void *p) {
      delete [] ((::edm::Wrapper<int>*)p);
   }
   static void destruct_edmcLcLWrapperlEintgR(void *p) {
      typedef ::edm::Wrapper<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<int>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<unsigned int>.
      typedef ::ROOT::Shadow::edm::WrapperlEunsignedsPintgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unsigned int>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<unsigned int>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<unsigned int> : new ::edm::Wrapper<unsigned int>;
   }
   static void *newArray_edmcLcLWrapperlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<unsigned int>[nElements] : new ::edm::Wrapper<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEunsignedsPintgR(void *p) {
      delete ((::edm::Wrapper<unsigned int>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEunsignedsPintgR(void *p) {
      delete [] ((::edm::Wrapper<unsigned int>*)p);
   }
   static void destruct_edmcLcLWrapperlEunsignedsPintgR(void *p) {
      typedef ::edm::Wrapper<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<unsigned int>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > : new ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >;
   }
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[nElements] : new ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > : new ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >;
   }
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[nElements] : new ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >.
      typedef ::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > : new ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >;
   }
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements] : new ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete ((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete [] ((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      typedef ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >.
      typedef ::ROOT::Shadow::edm::WrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > : new ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >;
   }
   static void *newArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements] : new ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete ((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete [] ((::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void destruct_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      typedef ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<TString,allocator<TString> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<TString,allocator<TString> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<TString,allocator<TString> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<TString,allocator<TString> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<TString,allocator<TString> > > : new ::edm::Wrapper<vector<TString,allocator<TString> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<TString,allocator<TString> > >[nElements] : new ::edm::Wrapper<vector<TString,allocator<TString> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<TString,allocator<TString> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<TString,allocator<TString> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<TString,allocator<TString> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<TString,allocator<TString> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<double,allocator<double> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<double,allocator<double> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<double,allocator<double> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<double,allocator<double> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<double,allocator<double> > > : new ::edm::Wrapper<vector<double,allocator<double> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<double,allocator<double> > >[nElements] : new ::edm::Wrapper<vector<double,allocator<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<double,allocator<double> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<double,allocator<double> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<double,allocator<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<double,allocator<double> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<float,allocator<float> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<float,allocator<float> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<float,allocator<float> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<float,allocator<float> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<float,allocator<float> > > : new ::edm::Wrapper<vector<float,allocator<float> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<float,allocator<float> > >[nElements] : new ::edm::Wrapper<vector<float,allocator<float> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<float,allocator<float> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<float,allocator<float> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<float,allocator<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<float,allocator<float> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<int,allocator<int> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<int,allocator<int> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<int,allocator<int> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<int,allocator<int> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<int,allocator<int> > > : new ::edm::Wrapper<vector<int,allocator<int> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<int,allocator<int> > >[nElements] : new ::edm::Wrapper<vector<int,allocator<int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<int,allocator<int> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<int,allocator<int> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<int,allocator<int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<int,allocator<int> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<unsigned int,allocator<unsigned int> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > : new ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >[nElements] : new ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > : new ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >[nElements] : new ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > : new ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >[nElements] : new ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > : new ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >[nElements] : new ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > : new ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >[nElements] : new ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > : new ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >[nElements] : new ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > : new ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >[nElements] : new ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > : new ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >[nElements] : new ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLBranchChildren_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::BranchChildren.
      typedef ::ROOT::Shadow::edm::BranchChildren ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchChildren*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLBranchChildren(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchChildren : new ::edm::BranchChildren;
   }
   static void *newArray_edmcLcLBranchChildren(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchChildren[nElements] : new ::edm::BranchChildren[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLBranchChildren(void *p) {
      delete ((::edm::BranchChildren*)p);
   }
   static void deleteArray_edmcLcLBranchChildren(void *p) {
      delete [] ((::edm::BranchChildren*)p);
   }
   static void destruct_edmcLcLBranchChildren(void *p) {
      typedef ::edm::BranchChildren current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::BranchChildren

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLBranchDescription_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::BranchDescription.
      typedef ::ROOT::Shadow::edm::BranchDescription ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchDescription*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLBranchDescription(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchDescription : new ::edm::BranchDescription;
   }
   static void *newArray_edmcLcLBranchDescription(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchDescription[nElements] : new ::edm::BranchDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLBranchDescription(void *p) {
      delete ((::edm::BranchDescription*)p);
   }
   static void deleteArray_edmcLcLBranchDescription(void *p) {
      delete [] ((::edm::BranchDescription*)p);
   }
   static void destruct_edmcLcLBranchDescription(void *p) {
      typedef ::edm::BranchDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::BranchDescription

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLBranchDescriptioncLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::BranchDescription::Transients.
      typedef ::ROOT::Shadow::edm::BranchDescription::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchDescription::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLBranchDescriptioncLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchDescription::Transients : new ::edm::BranchDescription::Transients;
   }
   static void *newArray_edmcLcLBranchDescriptioncLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchDescription::Transients[nElements] : new ::edm::BranchDescription::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLBranchDescriptioncLcLTransients(void *p) {
      delete ((::edm::BranchDescription::Transients*)p);
   }
   static void deleteArray_edmcLcLBranchDescriptioncLcLTransients(void *p) {
      delete [] ((::edm::BranchDescription::Transients*)p);
   }
   static void destruct_edmcLcLBranchDescriptioncLcLTransients(void *p) {
      typedef ::edm::BranchDescription::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::BranchDescription::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLBranchID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::BranchID.
      typedef ::ROOT::Shadow::edm::BranchID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLBranchID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchID : new ::edm::BranchID;
   }
   static void *newArray_edmcLcLBranchID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchID[nElements] : new ::edm::BranchID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLBranchID(void *p) {
      delete ((::edm::BranchID*)p);
   }
   static void deleteArray_edmcLcLBranchID(void *p) {
      delete [] ((::edm::BranchID*)p);
   }
   static void destruct_edmcLcLBranchID(void *p) {
      typedef ::edm::BranchID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::BranchID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLBranchKey_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::BranchKey.
      typedef ::ROOT::Shadow::edm::BranchKey ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::BranchKey*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLBranchKey(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchKey : new ::edm::BranchKey;
   }
   static void *newArray_edmcLcLBranchKey(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::BranchKey[nElements] : new ::edm::BranchKey[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLBranchKey(void *p) {
      delete ((::edm::BranchKey*)p);
   }
   static void deleteArray_edmcLcLBranchKey(void *p) {
      delete [] ((::edm::BranchKey*)p);
   }
   static void destruct_edmcLcLBranchKey(void *p) {
      typedef ::edm::BranchKey current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::BranchKey

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEDProduct_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EDProduct.
      typedef ::ROOT::Shadow::edm::EDProduct ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EDProduct*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEDProduct(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EDProduct : new ::edm::EDProduct;
   }
   static void *newArray_edmcLcLEDProduct(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EDProduct[nElements] : new ::edm::EDProduct[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEDProduct(void *p) {
      delete ((::edm::EDProduct*)p);
   }
   static void deleteArray_edmcLcLEDProduct(void *p) {
      delete [] ((::edm::EDProduct*)p);
   }
   static void destruct_edmcLcLEDProduct(void *p) {
      typedef ::edm::EDProduct current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EDProduct

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventAuxiliary.
      typedef ::ROOT::Shadow::edm::EventAuxiliary ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventAuxiliary*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventAuxiliary(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventAuxiliary : new ::edm::EventAuxiliary;
   }
   static void *newArray_edmcLcLEventAuxiliary(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventAuxiliary[nElements] : new ::edm::EventAuxiliary[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventAuxiliary(void *p) {
      delete ((::edm::EventAuxiliary*)p);
   }
   static void deleteArray_edmcLcLEventAuxiliary(void *p) {
      delete [] ((::edm::EventAuxiliary*)p);
   }
   static void destruct_edmcLcLEventAuxiliary(void *p) {
      typedef ::edm::EventAuxiliary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventAuxiliary

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventEntryDescription_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventEntryDescription.
      typedef ::ROOT::Shadow::edm::EventEntryDescription ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryDescription*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventEntryDescription(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryDescription : new ::edm::EventEntryDescription;
   }
   static void *newArray_edmcLcLEventEntryDescription(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryDescription[nElements] : new ::edm::EventEntryDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventEntryDescription(void *p) {
      delete ((::edm::EventEntryDescription*)p);
   }
   static void deleteArray_edmcLcLEventEntryDescription(void *p) {
      delete [] ((::edm::EventEntryDescription*)p);
   }
   static void destruct_edmcLcLEventEntryDescription(void *p) {
      typedef ::edm::EventEntryDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventEntryDescription

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventEntryDescriptioncLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventEntryDescription::Transients.
      typedef ::ROOT::Shadow::edm::EventEntryDescription::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryDescription::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventEntryDescriptioncLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryDescription::Transients : new ::edm::EventEntryDescription::Transients;
   }
   static void *newArray_edmcLcLEventEntryDescriptioncLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryDescription::Transients[nElements] : new ::edm::EventEntryDescription::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventEntryDescriptioncLcLTransients(void *p) {
      delete ((::edm::EventEntryDescription::Transients*)p);
   }
   static void deleteArray_edmcLcLEventEntryDescriptioncLcLTransients(void *p) {
      delete [] ((::edm::EventEntryDescription::Transients*)p);
   }
   static void destruct_edmcLcLEventEntryDescriptioncLcLTransients(void *p) {
      typedef ::edm::EventEntryDescription::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventEntryDescription::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventEntryInfo_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventEntryInfo.
      typedef ::ROOT::Shadow::edm::EventEntryInfo ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryInfo*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventEntryInfo(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryInfo : new ::edm::EventEntryInfo;
   }
   static void *newArray_edmcLcLEventEntryInfo(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryInfo[nElements] : new ::edm::EventEntryInfo[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventEntryInfo(void *p) {
      delete ((::edm::EventEntryInfo*)p);
   }
   static void deleteArray_edmcLcLEventEntryInfo(void *p) {
      delete [] ((::edm::EventEntryInfo*)p);
   }
   static void destruct_edmcLcLEventEntryInfo(void *p) {
      typedef ::edm::EventEntryInfo current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventEntryInfo

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventEntryInfocLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventEntryInfo::Transients.
      typedef ::ROOT::Shadow::edm::EventEntryInfo::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventEntryInfo::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventEntryInfocLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryInfo::Transients : new ::edm::EventEntryInfo::Transients;
   }
   static void *newArray_edmcLcLEventEntryInfocLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventEntryInfo::Transients[nElements] : new ::edm::EventEntryInfo::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventEntryInfocLcLTransients(void *p) {
      delete ((::edm::EventEntryInfo::Transients*)p);
   }
   static void deleteArray_edmcLcLEventEntryInfocLcLTransients(void *p) {
      delete [] ((::edm::EventEntryInfo::Transients*)p);
   }
   static void destruct_edmcLcLEventEntryInfocLcLTransients(void *p) {
      typedef ::edm::EventEntryInfo::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventEntryInfo::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLEventID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::EventID.
      typedef ::ROOT::Shadow::edm::EventID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::EventID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLEventID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventID : new ::edm::EventID;
   }
   static void *newArray_edmcLcLEventID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::EventID[nElements] : new ::edm::EventID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLEventID(void *p) {
      delete ((::edm::EventID*)p);
   }
   static void deleteArray_edmcLcLEventID(void *p) {
      delete [] ((::edm::EventID*)p);
   }
   static void destruct_edmcLcLEventID(void *p) {
      typedef ::edm::EventID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::EventID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLFileFormatVersion_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::FileFormatVersion.
      typedef ::ROOT::Shadow::edm::FileFormatVersion ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::FileFormatVersion*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFileFormatVersion(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileFormatVersion : new ::edm::FileFormatVersion;
   }
   static void *newArray_edmcLcLFileFormatVersion(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileFormatVersion[nElements] : new ::edm::FileFormatVersion[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFileFormatVersion(void *p) {
      delete ((::edm::FileFormatVersion*)p);
   }
   static void deleteArray_edmcLcLFileFormatVersion(void *p) {
      delete [] ((::edm::FileFormatVersion*)p);
   }
   static void destruct_edmcLcLFileFormatVersion(void *p) {
      typedef ::edm::FileFormatVersion current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FileFormatVersion

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLFileID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::FileID.
      typedef ::ROOT::Shadow::edm::FileID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::FileID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFileID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileID : new ::edm::FileID;
   }
   static void *newArray_edmcLcLFileID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileID[nElements] : new ::edm::FileID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFileID(void *p) {
      delete ((::edm::FileID*)p);
   }
   static void deleteArray_edmcLcLFileID(void *p) {
      delete [] ((::edm::FileID*)p);
   }
   static void destruct_edmcLcLFileID(void *p) {
      typedef ::edm::FileID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FileID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLFileIndex_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::FileIndex.
      typedef ::ROOT::Shadow::edm::FileIndex ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFileIndex(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex : new ::edm::FileIndex;
   }
   static void *newArray_edmcLcLFileIndex(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex[nElements] : new ::edm::FileIndex[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFileIndex(void *p) {
      delete ((::edm::FileIndex*)p);
   }
   static void deleteArray_edmcLcLFileIndex(void *p) {
      delete [] ((::edm::FileIndex*)p);
   }
   static void destruct_edmcLcLFileIndex(void *p) {
      typedef ::edm::FileIndex current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FileIndex

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLFileIndexcLcLElement_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::FileIndex::Element.
      typedef ::ROOT::Shadow::edm::FileIndex::Element ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex::Element*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFileIndexcLcLElement(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex::Element : new ::edm::FileIndex::Element;
   }
   static void *newArray_edmcLcLFileIndexcLcLElement(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex::Element[nElements] : new ::edm::FileIndex::Element[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFileIndexcLcLElement(void *p) {
      delete ((::edm::FileIndex::Element*)p);
   }
   static void deleteArray_edmcLcLFileIndexcLcLElement(void *p) {
      delete [] ((::edm::FileIndex::Element*)p);
   }
   static void destruct_edmcLcLFileIndexcLcLElement(void *p) {
      typedef ::edm::FileIndex::Element current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FileIndex::Element

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLFileIndexcLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::FileIndex::Transients.
      typedef ::ROOT::Shadow::edm::FileIndex::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::FileIndex::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLFileIndexcLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex::Transients : new ::edm::FileIndex::Transients;
   }
   static void *newArray_edmcLcLFileIndexcLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::FileIndex::Transients[nElements] : new ::edm::FileIndex::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLFileIndexcLcLTransients(void *p) {
      delete ((::edm::FileIndex::Transients*)p);
   }
   static void deleteArray_edmcLcLFileIndexcLcLTransients(void *p) {
      delete [] ((::edm::FileIndex::Transients*)p);
   }
   static void destruct_edmcLcLFileIndexcLcLTransients(void *p) {
      typedef ::edm::FileIndex::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::FileIndex::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE0gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<0>.
      typedef ::ROOT::Shadow::edm::HashlE0gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<0>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE0gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<0> : new ::edm::Hash<0>;
   }
   static void *newArray_edmcLcLHashlE0gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<0>[nElements] : new ::edm::Hash<0>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE0gR(void *p) {
      delete ((::edm::Hash<0>*)p);
   }
   static void deleteArray_edmcLcLHashlE0gR(void *p) {
      delete [] ((::edm::Hash<0>*)p);
   }
   static void destruct_edmcLcLHashlE0gR(void *p) {
      typedef ::edm::Hash<0> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<0>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE1gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<1>.
      typedef ::ROOT::Shadow::edm::HashlE1gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<1>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE1gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<1> : new ::edm::Hash<1>;
   }
   static void *newArray_edmcLcLHashlE1gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<1>[nElements] : new ::edm::Hash<1>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE1gR(void *p) {
      delete ((::edm::Hash<1>*)p);
   }
   static void deleteArray_edmcLcLHashlE1gR(void *p) {
      delete [] ((::edm::Hash<1>*)p);
   }
   static void destruct_edmcLcLHashlE1gR(void *p) {
      typedef ::edm::Hash<1> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<1>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE2gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<2>.
      typedef ::ROOT::Shadow::edm::HashlE2gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<2>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE2gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<2> : new ::edm::Hash<2>;
   }
   static void *newArray_edmcLcLHashlE2gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<2>[nElements] : new ::edm::Hash<2>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE2gR(void *p) {
      delete ((::edm::Hash<2>*)p);
   }
   static void deleteArray_edmcLcLHashlE2gR(void *p) {
      delete [] ((::edm::Hash<2>*)p);
   }
   static void destruct_edmcLcLHashlE2gR(void *p) {
      typedef ::edm::Hash<2> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<2>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE3gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<3>.
      typedef ::ROOT::Shadow::edm::HashlE3gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<3>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE3gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<3> : new ::edm::Hash<3>;
   }
   static void *newArray_edmcLcLHashlE3gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<3>[nElements] : new ::edm::Hash<3>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE3gR(void *p) {
      delete ((::edm::Hash<3>*)p);
   }
   static void deleteArray_edmcLcLHashlE3gR(void *p) {
      delete [] ((::edm::Hash<3>*)p);
   }
   static void destruct_edmcLcLHashlE3gR(void *p) {
      typedef ::edm::Hash<3> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<3>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE4gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<4>.
      typedef ::ROOT::Shadow::edm::HashlE4gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<4>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE4gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<4> : new ::edm::Hash<4>;
   }
   static void *newArray_edmcLcLHashlE4gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<4>[nElements] : new ::edm::Hash<4>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE4gR(void *p) {
      delete ((::edm::Hash<4>*)p);
   }
   static void deleteArray_edmcLcLHashlE4gR(void *p) {
      delete [] ((::edm::Hash<4>*)p);
   }
   static void destruct_edmcLcLHashlE4gR(void *p) {
      typedef ::edm::Hash<4> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<4>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHashlE5gR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Hash<5>.
      typedef ::ROOT::Shadow::edm::HashlE5gR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Hash<5>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHashlE5gR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<5> : new ::edm::Hash<5>;
   }
   static void *newArray_edmcLcLHashlE5gR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Hash<5>[nElements] : new ::edm::Hash<5>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHashlE5gR(void *p) {
      delete ((::edm::Hash<5>*)p);
   }
   static void deleteArray_edmcLcLHashlE5gR(void *p) {
      delete [] ((::edm::Hash<5>*)p);
   }
   static void destruct_edmcLcLHashlE5gR(void *p) {
      typedef ::edm::Hash<5> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Hash<5>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLHistory_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::History.
      typedef ::ROOT::Shadow::edm::History ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::History*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLHistory(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::History : new ::edm::History;
   }
   static void *newArray_edmcLcLHistory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::History[nElements] : new ::edm::History[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLHistory(void *p) {
      delete ((::edm::History*)p);
   }
   static void deleteArray_edmcLcLHistory(void *p) {
      delete [] ((::edm::History*)p);
   }
   static void destruct_edmcLcLHistory(void *p) {
      typedef ::edm::History current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::History

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLLuminosityBlockAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::LuminosityBlockAuxiliary.
      typedef ::ROOT::Shadow::edm::LuminosityBlockAuxiliary ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::LuminosityBlockAuxiliary*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLLuminosityBlockAuxiliary(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::LuminosityBlockAuxiliary : new ::edm::LuminosityBlockAuxiliary;
   }
   static void *newArray_edmcLcLLuminosityBlockAuxiliary(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::LuminosityBlockAuxiliary[nElements] : new ::edm::LuminosityBlockAuxiliary[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLLuminosityBlockAuxiliary(void *p) {
      delete ((::edm::LuminosityBlockAuxiliary*)p);
   }
   static void deleteArray_edmcLcLLuminosityBlockAuxiliary(void *p) {
      delete [] ((::edm::LuminosityBlockAuxiliary*)p);
   }
   static void destruct_edmcLcLLuminosityBlockAuxiliary(void *p) {
      typedef ::edm::LuminosityBlockAuxiliary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::LuminosityBlockAuxiliary

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLLuminosityBlockID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::LuminosityBlockID.
      typedef ::ROOT::Shadow::edm::LuminosityBlockID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::LuminosityBlockID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLLuminosityBlockID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::LuminosityBlockID : new ::edm::LuminosityBlockID;
   }
   static void *newArray_edmcLcLLuminosityBlockID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::LuminosityBlockID[nElements] : new ::edm::LuminosityBlockID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLLuminosityBlockID(void *p) {
      delete ((::edm::LuminosityBlockID*)p);
   }
   static void deleteArray_edmcLcLLuminosityBlockID(void *p) {
      delete [] ((::edm::LuminosityBlockID*)p);
   }
   static void destruct_edmcLcLLuminosityBlockID(void *p) {
      typedef ::edm::LuminosityBlockID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::LuminosityBlockID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLModuleDescription_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ModuleDescription.
      typedef ::ROOT::Shadow::edm::ModuleDescription ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ModuleDescription*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLModuleDescription(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ModuleDescription : new ::edm::ModuleDescription;
   }
   static void *newArray_edmcLcLModuleDescription(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ModuleDescription[nElements] : new ::edm::ModuleDescription[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLModuleDescription(void *p) {
      delete ((::edm::ModuleDescription*)p);
   }
   static void deleteArray_edmcLcLModuleDescription(void *p) {
      delete [] ((::edm::ModuleDescription*)p);
   }
   static void destruct_edmcLcLModuleDescription(void *p) {
      typedef ::edm::ModuleDescription current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ModuleDescription

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLParameterSetBlob_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ParameterSetBlob.
      typedef ::ROOT::Shadow::edm::ParameterSetBlob ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ParameterSetBlob*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLParameterSetBlob(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ParameterSetBlob : new ::edm::ParameterSetBlob;
   }
   static void *newArray_edmcLcLParameterSetBlob(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ParameterSetBlob[nElements] : new ::edm::ParameterSetBlob[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLParameterSetBlob(void *p) {
      delete ((::edm::ParameterSetBlob*)p);
   }
   static void deleteArray_edmcLcLParameterSetBlob(void *p) {
      delete [] ((::edm::ParameterSetBlob*)p);
   }
   static void destruct_edmcLcLParameterSetBlob(void *p) {
      typedef ::edm::ParameterSetBlob current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ParameterSetBlob

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLParentage_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Parentage.
      typedef ::ROOT::Shadow::edm::Parentage ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Parentage*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLParentage(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Parentage : new ::edm::Parentage;
   }
   static void *newArray_edmcLcLParentage(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Parentage[nElements] : new ::edm::Parentage[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLParentage(void *p) {
      delete ((::edm::Parentage*)p);
   }
   static void deleteArray_edmcLcLParentage(void *p) {
      delete [] ((::edm::Parentage*)p);
   }
   static void destruct_edmcLcLParentage(void *p) {
      typedef ::edm::Parentage current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Parentage

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLParentagecLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Parentage::Transients.
      typedef ::ROOT::Shadow::edm::Parentage::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Parentage::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLParentagecLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Parentage::Transients : new ::edm::Parentage::Transients;
   }
   static void *newArray_edmcLcLParentagecLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Parentage::Transients[nElements] : new ::edm::Parentage::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLParentagecLcLTransients(void *p) {
      delete ((::edm::Parentage::Transients*)p);
   }
   static void deleteArray_edmcLcLParentagecLcLTransients(void *p) {
      delete [] ((::edm::Parentage::Transients*)p);
   }
   static void destruct_edmcLcLParentagecLcLTransients(void *p) {
      typedef ::edm::Parentage::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Parentage::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProcessConfiguration_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProcessConfiguration.
      typedef ::ROOT::Shadow::edm::ProcessConfiguration ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessConfiguration*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProcessConfiguration(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessConfiguration : new ::edm::ProcessConfiguration;
   }
   static void *newArray_edmcLcLProcessConfiguration(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessConfiguration[nElements] : new ::edm::ProcessConfiguration[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProcessConfiguration(void *p) {
      delete ((::edm::ProcessConfiguration*)p);
   }
   static void deleteArray_edmcLcLProcessConfiguration(void *p) {
      delete [] ((::edm::ProcessConfiguration*)p);
   }
   static void destruct_edmcLcLProcessConfiguration(void *p) {
      typedef ::edm::ProcessConfiguration current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProcessConfiguration

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProcessConfigurationcLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProcessConfiguration::Transients.
      typedef ::ROOT::Shadow::edm::ProcessConfiguration::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessConfiguration::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProcessConfigurationcLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessConfiguration::Transients : new ::edm::ProcessConfiguration::Transients;
   }
   static void *newArray_edmcLcLProcessConfigurationcLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessConfiguration::Transients[nElements] : new ::edm::ProcessConfiguration::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProcessConfigurationcLcLTransients(void *p) {
      delete ((::edm::ProcessConfiguration::Transients*)p);
   }
   static void deleteArray_edmcLcLProcessConfigurationcLcLTransients(void *p) {
      delete [] ((::edm::ProcessConfiguration::Transients*)p);
   }
   static void destruct_edmcLcLProcessConfigurationcLcLTransients(void *p) {
      typedef ::edm::ProcessConfiguration::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProcessConfiguration::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProcessHistory_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProcessHistory.
      typedef ::ROOT::Shadow::edm::ProcessHistory ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessHistory*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProcessHistory(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessHistory : new ::edm::ProcessHistory;
   }
   static void *newArray_edmcLcLProcessHistory(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessHistory[nElements] : new ::edm::ProcessHistory[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProcessHistory(void *p) {
      delete ((::edm::ProcessHistory*)p);
   }
   static void deleteArray_edmcLcLProcessHistory(void *p) {
      delete [] ((::edm::ProcessHistory*)p);
   }
   static void destruct_edmcLcLProcessHistory(void *p) {
      typedef ::edm::ProcessHistory current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProcessHistory

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProductProvenance_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProductProvenance.
      typedef ::ROOT::Shadow::edm::ProductProvenance ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductProvenance*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProductProvenance(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductProvenance : new ::edm::ProductProvenance;
   }
   static void *newArray_edmcLcLProductProvenance(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductProvenance[nElements] : new ::edm::ProductProvenance[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProductProvenance(void *p) {
      delete ((::edm::ProductProvenance*)p);
   }
   static void deleteArray_edmcLcLProductProvenance(void *p) {
      delete [] ((::edm::ProductProvenance*)p);
   }
   static void destruct_edmcLcLProductProvenance(void *p) {
      typedef ::edm::ProductProvenance current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProductProvenance

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLStoredProductProvenance_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::StoredProductProvenance.
      typedef ::ROOT::Shadow::edm::StoredProductProvenance ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::StoredProductProvenance*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLStoredProductProvenance(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::StoredProductProvenance : new ::edm::StoredProductProvenance;
   }
   static void *newArray_edmcLcLStoredProductProvenance(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::StoredProductProvenance[nElements] : new ::edm::StoredProductProvenance[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLStoredProductProvenance(void *p) {
      delete ((::edm::StoredProductProvenance*)p);
   }
   static void deleteArray_edmcLcLStoredProductProvenance(void *p) {
      delete [] ((::edm::StoredProductProvenance*)p);
   }
   static void destruct_edmcLcLStoredProductProvenance(void *p) {
      typedef ::edm::StoredProductProvenance current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::StoredProductProvenance

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProcessHistorycLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProcessHistory::Transients.
      typedef ::ROOT::Shadow::edm::ProcessHistory::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProcessHistory::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProcessHistorycLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessHistory::Transients : new ::edm::ProcessHistory::Transients;
   }
   static void *newArray_edmcLcLProcessHistorycLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProcessHistory::Transients[nElements] : new ::edm::ProcessHistory::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProcessHistorycLcLTransients(void *p) {
      delete ((::edm::ProcessHistory::Transients*)p);
   }
   static void deleteArray_edmcLcLProcessHistorycLcLTransients(void *p) {
      delete [] ((::edm::ProcessHistory::Transients*)p);
   }
   static void destruct_edmcLcLProcessHistorycLcLTransients(void *p) {
      typedef ::edm::ProcessHistory::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProcessHistory::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProductID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProductID.
      typedef ::ROOT::Shadow::edm::ProductID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProductID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductID : new ::edm::ProductID;
   }
   static void *newArray_edmcLcLProductID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductID[nElements] : new ::edm::ProductID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProductID(void *p) {
      delete ((::edm::ProductID*)p);
   }
   static void deleteArray_edmcLcLProductID(void *p) {
      delete [] ((::edm::ProductID*)p);
   }
   static void destruct_edmcLcLProductID(void *p) {
      typedef ::edm::ProductID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProductID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProductRegistry_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProductRegistry.
      typedef ::ROOT::Shadow::edm::ProductRegistry ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductRegistry*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProductRegistry(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductRegistry : new ::edm::ProductRegistry;
   }
   static void *newArray_edmcLcLProductRegistry(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductRegistry[nElements] : new ::edm::ProductRegistry[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProductRegistry(void *p) {
      delete ((::edm::ProductRegistry*)p);
   }
   static void deleteArray_edmcLcLProductRegistry(void *p) {
      delete [] ((::edm::ProductRegistry*)p);
   }
   static void destruct_edmcLcLProductRegistry(void *p) {
      typedef ::edm::ProductRegistry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProductRegistry

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLProductRegistrycLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::ProductRegistry::Transients.
      typedef ::ROOT::Shadow::edm::ProductRegistry::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::ProductRegistry::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLProductRegistrycLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductRegistry::Transients : new ::edm::ProductRegistry::Transients;
   }
   static void *newArray_edmcLcLProductRegistrycLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::ProductRegistry::Transients[nElements] : new ::edm::ProductRegistry::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLProductRegistrycLcLTransients(void *p) {
      delete ((::edm::ProductRegistry::Transients*)p);
   }
   static void deleteArray_edmcLcLProductRegistrycLcLTransients(void *p) {
      delete [] ((::edm::ProductRegistry::Transients*)p);
   }
   static void destruct_edmcLcLProductRegistrycLcLTransients(void *p) {
      typedef ::edm::ProductRegistry::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::ProductRegistry::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLRunAuxiliary_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::RunAuxiliary.
      typedef ::ROOT::Shadow::edm::RunAuxiliary ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::RunAuxiliary*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRunAuxiliary(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RunAuxiliary : new ::edm::RunAuxiliary;
   }
   static void *newArray_edmcLcLRunAuxiliary(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RunAuxiliary[nElements] : new ::edm::RunAuxiliary[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRunAuxiliary(void *p) {
      delete ((::edm::RunAuxiliary*)p);
   }
   static void deleteArray_edmcLcLRunAuxiliary(void *p) {
      delete [] ((::edm::RunAuxiliary*)p);
   }
   static void destruct_edmcLcLRunAuxiliary(void *p) {
      typedef ::edm::RunAuxiliary current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RunAuxiliary

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLRunID_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::RunID.
      typedef ::ROOT::Shadow::edm::RunID ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::RunID*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLRunID(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RunID : new ::edm::RunID;
   }
   static void *newArray_edmcLcLRunID(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::RunID[nElements] : new ::edm::RunID[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLRunID(void *p) {
      delete ((::edm::RunID*)p);
   }
   static void deleteArray_edmcLcLRunID(void *p) {
      delete [] ((::edm::RunID*)p);
   }
   static void destruct_edmcLcLRunID(void *p) {
      typedef ::edm::RunID current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::RunID

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTimestamp_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Timestamp.
      typedef ::ROOT::Shadow::edm::Timestamp ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Timestamp*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTimestamp(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Timestamp : new ::edm::Timestamp;
   }
   static void *newArray_edmcLcLTimestamp(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Timestamp[nElements] : new ::edm::Timestamp[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTimestamp(void *p) {
      delete ((::edm::Timestamp*)p);
   }
   static void deleteArray_edmcLcLTimestamp(void *p) {
      delete [] ((::edm::Timestamp*)p);
   }
   static void destruct_edmcLcLTimestamp(void *p) {
      typedef ::edm::Timestamp current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Timestamp

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::BranchDescription::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLBranchDescriptioncLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::BranchDescription::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::BranchDescription::Transients> : new ::edm::Transient<edm::BranchDescription::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::BranchDescription::Transients>[nElements] : new ::edm::Transient<edm::BranchDescription::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::BranchDescription::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::BranchDescription::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::BranchDescription::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::BranchDescription::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::EventEntryDescription::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryDescription::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::EventEntryDescription::Transients> : new ::edm::Transient<edm::EventEntryDescription::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::EventEntryDescription::Transients>[nElements] : new ::edm::Transient<edm::EventEntryDescription::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::EventEntryDescription::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::EventEntryDescription::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::EventEntryDescription::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::EventEntryDescription::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::EventEntryInfo::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLEventEntryInfocLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::EventEntryInfo::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::EventEntryInfo::Transients> : new ::edm::Transient<edm::EventEntryInfo::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::EventEntryInfo::Transients>[nElements] : new ::edm::Transient<edm::EventEntryInfo::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::EventEntryInfo::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::EventEntryInfo::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::EventEntryInfo::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::EventEntryInfo::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::FileIndex::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLFileIndexcLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::FileIndex::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::FileIndex::Transients> : new ::edm::Transient<edm::FileIndex::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::FileIndex::Transients>[nElements] : new ::edm::Transient<edm::FileIndex::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::FileIndex::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::FileIndex::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::FileIndex::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::FileIndex::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::Parentage::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLParentagecLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::Parentage::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::Parentage::Transients> : new ::edm::Transient<edm::Parentage::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::Parentage::Transients>[nElements] : new ::edm::Transient<edm::Parentage::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::Parentage::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::Parentage::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::Parentage::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::Parentage::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::ProcessConfiguration::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLProcessConfigurationcLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessConfiguration::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProcessConfiguration::Transients> : new ::edm::Transient<edm::ProcessConfiguration::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProcessConfiguration::Transients>[nElements] : new ::edm::Transient<edm::ProcessConfiguration::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::ProcessConfiguration::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::ProcessConfiguration::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::ProcessConfiguration::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::ProcessConfiguration::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::ProcessHistory::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLProcessHistorycLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProcessHistory::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProcessHistory::Transients> : new ::edm::Transient<edm::ProcessHistory::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProcessHistory::Transients>[nElements] : new ::edm::Transient<edm::ProcessHistory::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::ProcessHistory::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::ProcessHistory::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::ProcessHistory::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::ProcessHistory::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::ProductProvenance::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLProductProvenancecLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductProvenance::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProductProvenance::Transients> : new ::edm::Transient<edm::ProductProvenance::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProductProvenance::Transients>[nElements] : new ::edm::Transient<edm::ProductProvenance::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::ProductProvenance::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::ProductProvenance::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::ProductProvenance::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::ProductProvenance::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::ProductRegistry::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLProductRegistrycLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::ProductRegistry::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProductRegistry::Transients> : new ::edm::Transient<edm::ProductRegistry::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::ProductRegistry::Transients>[nElements] : new ::edm::Transient<edm::ProductRegistry::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::ProductRegistry::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::ProductRegistry::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::ProductRegistry::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::ProductRegistry::Transients>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Transient<edm::IndexIntoFile::Transients>.
      typedef ::ROOT::Shadow::edm::TransientlEedmcLcLIndexIntoFilecLcLTransientsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Transient<edm::IndexIntoFile::Transients>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::IndexIntoFile::Transients> : new ::edm::Transient<edm::IndexIntoFile::Transients>;
   }
   static void *newArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Transient<edm::IndexIntoFile::Transients>[nElements] : new ::edm::Transient<edm::IndexIntoFile::Transients>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p) {
      delete ((::edm::Transient<edm::IndexIntoFile::Transients>*)p);
   }
   static void deleteArray_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p) {
      delete [] ((::edm::Transient<edm::IndexIntoFile::Transients>*)p);
   }
   static void destruct_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void *p) {
      typedef ::edm::Transient<edm::IndexIntoFile::Transients> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Transient<edm::IndexIntoFile::Transients>

//______________________________________________________________________________
namespace ROOT {
   void pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<edm::BranchKey,edm::BranchDescription>.
      typedef ::ROOT::Shadow::pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<edm::BranchKey,edm::BranchDescription>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("edm::BranchKey", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", (void*)&sobj->second);
      R__insp.InspectMember("edm::BranchDescription", (void*)&sobj->second, "second.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::BranchKey,edm::BranchDescription> : new pair<edm::BranchKey,edm::BranchDescription>;
   }
   static void *newArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::BranchKey,edm::BranchDescription>[nElements] : new pair<edm::BranchKey,edm::BranchDescription>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p) {
      delete ((pair<edm::BranchKey,edm::BranchDescription>*)p);
   }
   static void deleteArray_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p) {
      delete [] ((pair<edm::BranchKey,edm::BranchDescription>*)p);
   }
   static void destruct_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void *p) {
      typedef pair<edm::BranchKey,edm::BranchDescription> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::BranchKey,edm::BranchDescription>

//______________________________________________________________________________
namespace ROOT {
   void pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<edm::Hash<1>,edm::ParameterSetBlob>.
      typedef ::ROOT::Shadow::pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<edm::Hash<1>,edm::ParameterSetBlob>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("edm::Hash<1>", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", (void*)&sobj->second);
      R__insp.InspectMember("edm::ParameterSetBlob", (void*)&sobj->second, "second.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::Hash<1>,edm::ParameterSetBlob> : new pair<edm::Hash<1>,edm::ParameterSetBlob>;
   }
   static void *newArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::Hash<1>,edm::ParameterSetBlob>[nElements] : new pair<edm::Hash<1>,edm::ParameterSetBlob>[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p) {
      delete ((pair<edm::Hash<1>,edm::ParameterSetBlob>*)p);
   }
   static void deleteArray_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p) {
      delete [] ((pair<edm::Hash<1>,edm::ParameterSetBlob>*)p);
   }
   static void destruct_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void *p) {
      typedef pair<edm::Hash<1>,edm::ParameterSetBlob> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::Hash<1>,edm::ParameterSetBlob>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEboolgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<bool>.
      typedef ::ROOT::Shadow::edm::WrapperlEboolgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<bool>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<bool>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEboolgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<bool> : new ::edm::Wrapper<bool>;
   }
   static void *newArray_edmcLcLWrapperlEboolgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<bool>[nElements] : new ::edm::Wrapper<bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEboolgR(void *p) {
      delete ((::edm::Wrapper<bool>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEboolgR(void *p) {
      delete [] ((::edm::Wrapper<bool>*)p);
   }
   static void destruct_edmcLcLWrapperlEboolgR(void *p) {
      typedef ::edm::Wrapper<bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<bool>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<bool,allocator<bool> > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<bool,allocator<bool> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<bool,allocator<bool> >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<bool,allocator<bool> > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<bool,allocator<bool> > > : new ::edm::Wrapper<vector<bool,allocator<bool> > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<bool,allocator<bool> > >[nElements] : new ::edm::Wrapper<vector<bool,allocator<bool> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<bool,allocator<bool> > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<bool,allocator<bool> > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<bool,allocator<bool> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<bool,allocator<bool> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEULong64_tgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<unsigned long long>.
      typedef ::ROOT::Shadow::edm::WrapperlEunsignedsPlongsPlonggR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<unsigned long long>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<unsigned long long>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEULong64_tgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ULong64_t> : new ::edm::Wrapper<ULong64_t>;
   }
   static void *newArray_edmcLcLWrapperlEULong64_tgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<ULong64_t>[nElements] : new ::edm::Wrapper<ULong64_t>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEULong64_tgR(void *p) {
      delete ((::edm::Wrapper<ULong64_t>*)p);
   }
   static void deleteArray_edmcLcLWrapperlEULong64_tgR(void *p) {
      delete [] ((::edm::Wrapper<ULong64_t>*)p);
   }
   static void destruct_edmcLcLWrapperlEULong64_tgR(void *p) {
      typedef ::edm::Wrapper<ULong64_t> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<ULong64_t>

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLIndexIntoFile_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::IndexIntoFile.
      typedef ::ROOT::Shadow::edm::IndexIntoFile ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLIndexIntoFile(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile : new ::edm::IndexIntoFile;
   }
   static void *newArray_edmcLcLIndexIntoFile(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile[nElements] : new ::edm::IndexIntoFile[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLIndexIntoFile(void *p) {
      delete ((::edm::IndexIntoFile*)p);
   }
   static void deleteArray_edmcLcLIndexIntoFile(void *p) {
      delete [] ((::edm::IndexIntoFile*)p);
   }
   static void destruct_edmcLcLIndexIntoFile(void *p) {
      typedef ::edm::IndexIntoFile current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::IndexIntoFile

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLIndexIntoFilecLcLRunOrLumiEntry_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::IndexIntoFile::RunOrLumiEntry.
      typedef ::ROOT::Shadow::edm::IndexIntoFile::RunOrLumiEntry ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile::RunOrLumiEntry*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile::RunOrLumiEntry : new ::edm::IndexIntoFile::RunOrLumiEntry;
   }
   static void *newArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile::RunOrLumiEntry[nElements] : new ::edm::IndexIntoFile::RunOrLumiEntry[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p) {
      delete ((::edm::IndexIntoFile::RunOrLumiEntry*)p);
   }
   static void deleteArray_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p) {
      delete [] ((::edm::IndexIntoFile::RunOrLumiEntry*)p);
   }
   static void destruct_edmcLcLIndexIntoFilecLcLRunOrLumiEntry(void *p) {
      typedef ::edm::IndexIntoFile::RunOrLumiEntry current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::IndexIntoFile::RunOrLumiEntry

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLIndexIntoFilecLcLTransients_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::IndexIntoFile::Transients.
      typedef ::ROOT::Shadow::edm::IndexIntoFile::Transients ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::IndexIntoFile::Transients*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLIndexIntoFilecLcLTransients(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile::Transients : new ::edm::IndexIntoFile::Transients;
   }
   static void *newArray_edmcLcLIndexIntoFilecLcLTransients(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::IndexIntoFile::Transients[nElements] : new ::edm::IndexIntoFile::Transients[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLIndexIntoFilecLcLTransients(void *p) {
      delete ((::edm::IndexIntoFile::Transients*)p);
   }
   static void deleteArray_edmcLcLIndexIntoFilecLcLTransients(void *p) {
      delete [] ((::edm::IndexIntoFile::Transients*)p);
   }
   static void destruct_edmcLcLIndexIntoFilecLcLTransients(void *p) {
      typedef ::edm::IndexIntoFile::Transients current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::IndexIntoFile::Transients

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlETBitsgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<TBits>.
      typedef ::ROOT::Shadow::edm::WrapperlETBitsgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<TBits>*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", &sobj->obj);
      R__insp.InspectMember(sobj->obj, "obj.");
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<TBits>*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlETBitsgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<TBits> : new ::edm::Wrapper<TBits>;
   }
   static void *newArray_edmcLcLWrapperlETBitsgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<TBits>[nElements] : new ::edm::Wrapper<TBits>[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlETBitsgR(void *p) {
      delete ((::edm::Wrapper<TBits>*)p);
   }
   static void deleteArray_edmcLcLWrapperlETBitsgR(void *p) {
      delete [] ((::edm::Wrapper<TBits>*)p);
   }
   static void destruct_edmcLcLWrapperlETBitsgR(void *p) {
      typedef ::edm::Wrapper<TBits> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<TBits>

//______________________________________________________________________________
namespace ROOT {
   void pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >.
      typedef ::ROOT::Shadow::pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "first", (void*)&sobj->first);
      R__insp.InspectMember("edm::BranchID", (void*)&sobj->first, "first.", false);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "second", (void*)&sobj->second);
      R__insp.InspectMember("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >", (void*)&sobj->second, "second.", false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > : new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >;
   }
   static void *newArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >[nElements] : new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p) {
      delete ((pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)p);
   }
   static void deleteArray_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p) {
      delete [] ((pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)p);
   }
   static void destruct_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void *p) {
      typedef pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > : new ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >[nElements] : new ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > : new ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >[nElements] : new ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > : new ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >[nElements] : new ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > : new ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >[nElements] : new ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > : new ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[nElements] : new ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >

//______________________________________________________________________________
namespace ROOT {
   void edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp)
   {
      // Inspect the data members of an object of class edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >.
      typedef ::ROOT::Shadow::edm::WrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR ShadowClass;
      ShadowClass *sobj = (ShadowClass*)obj;
      if (sobj) { } // Dummy usage just in case there is no datamember.

      TClass *R__cl  = ::ROOT::GenerateInitInstanceLocal((const ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x0)->GetClass();
      if (R__cl || R__insp.IsA()) { }
      R__insp.Inspect(R__cl, R__insp.GetParent(), "present", &sobj->present);
      R__insp.Inspect(R__cl, R__insp.GetParent(), "obj", (void*)&sobj->obj);
      R__insp.InspectMember("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >", (void*)&sobj->obj, "obj.", false);
      R__insp.GenericShowMembers("edm::EDProduct", ( ::edm::EDProduct * )( (::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) obj ), false);
   }

}

namespace ROOT {
   // Wrappers around operator new
   static void *new_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > : new ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
   }
   static void *newArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[nElements] : new ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete ((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)p);
   }
   static void deleteArray_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      delete [] ((::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)p);
   }
   static void destruct_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void *p) {
      typedef ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class ::edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >

namespace ROOT {
   void maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR_Dictionary();
   static void *new_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p = 0);
   static void *newArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(Long_t size, void *p);
   static void delete_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p);
   static void deleteArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p);
   static void destruct_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const map<edm::BranchID,set<edm::BranchID> >*)
   {
      map<edm::BranchID,set<edm::BranchID> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(map<edm::BranchID,set<edm::BranchID> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("map<edm::BranchID,set<edm::BranchID> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/map", 63,
                  typeid(map<edm::BranchID,set<edm::BranchID> >), DefineBehavior(ptr, ptr),
                  0, &maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(map<edm::BranchID,set<edm::BranchID> >) );
      instance.SetNew(&new_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR);
      instance.SetNewArray(&newArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR);
      instance.SetDelete(&delete_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR);
      instance.SetDeleteArray(&deleteArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR);
      instance.SetDestructor(&destruct_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::MapInsert< map<edm::BranchID,set<edm::BranchID> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const map<edm::BranchID,set<edm::BranchID> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const map<edm::BranchID,set<edm::BranchID> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) map<edm::BranchID,set<edm::BranchID> > : new map<edm::BranchID,set<edm::BranchID> >;
   }
   static void *newArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) map<edm::BranchID,set<edm::BranchID> >[nElements] : new map<edm::BranchID,set<edm::BranchID> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p) {
      delete ((map<edm::BranchID,set<edm::BranchID> >*)p);
   }
   static void deleteArray_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p) {
      delete [] ((map<edm::BranchID,set<edm::BranchID> >*)p);
   }
   static void destruct_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDgRsPgR(void *p) {
      typedef map<edm::BranchID,set<edm::BranchID> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class map<edm::BranchID,set<edm::BranchID> >

namespace ROOT {
   void setlEedmcLcLBranchIDgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void setlEedmcLcLBranchIDgR_Dictionary();
   static void *new_setlEedmcLcLBranchIDgR(void *p = 0);
   static void *newArray_setlEedmcLcLBranchIDgR(Long_t size, void *p);
   static void delete_setlEedmcLcLBranchIDgR(void *p);
   static void deleteArray_setlEedmcLcLBranchIDgR(void *p);
   static void destruct_setlEedmcLcLBranchIDgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const set<edm::BranchID>*)
   {
      set<edm::BranchID> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(set<edm::BranchID>),0);
      static ::ROOT::TGenericClassInfo 
         instance("set<edm::BranchID>", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/set", 49,
                  typeid(set<edm::BranchID>), DefineBehavior(ptr, ptr),
                  0, &setlEedmcLcLBranchIDgR_Dictionary, isa_proxy, 4,
                  sizeof(set<edm::BranchID>) );
      instance.SetNew(&new_setlEedmcLcLBranchIDgR);
      instance.SetNewArray(&newArray_setlEedmcLcLBranchIDgR);
      instance.SetDelete(&delete_setlEedmcLcLBranchIDgR);
      instance.SetDeleteArray(&deleteArray_setlEedmcLcLBranchIDgR);
      instance.SetDestructor(&destruct_setlEedmcLcLBranchIDgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Insert< set<edm::BranchID> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const set<edm::BranchID>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void setlEedmcLcLBranchIDgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const set<edm::BranchID>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_setlEedmcLcLBranchIDgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) set<edm::BranchID> : new set<edm::BranchID>;
   }
   static void *newArray_setlEedmcLcLBranchIDgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) set<edm::BranchID>[nElements] : new set<edm::BranchID>[nElements];
   }
   // Wrapper around operator delete
   static void delete_setlEedmcLcLBranchIDgR(void *p) {
      delete ((set<edm::BranchID>*)p);
   }
   static void deleteArray_setlEedmcLcLBranchIDgR(void *p) {
      delete [] ((set<edm::BranchID>*)p);
   }
   static void destruct_setlEedmcLcLBranchIDgR(void *p) {
      typedef set<edm::BranchID> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class set<edm::BranchID>

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)
   {
      vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > : new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[nElements] : new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      delete ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      delete [] ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void *p) {
      typedef vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)
   {
      vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > : new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[nElements] : new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete [] ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      typedef vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > : new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements] : new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete [] ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      typedef vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)
   {
      vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > : new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements] : new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      delete [] ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void *p) {
      typedef vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >

namespace ROOT {
   void vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary();
   static void *new_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p = 0);
   static void *newArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(Long_t size, void *p);
   static void delete_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);
   static void deleteArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);
   static void destruct_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<ROOT::Math::PxPyPzE4D<float> >*)
   {
      vector<ROOT::Math::PxPyPzE4D<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<ROOT::Math::PxPyPzE4D<float> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<ROOT::Math::PxPyPzE4D<float> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<ROOT::Math::PxPyPzE4D<float> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<ROOT::Math::PxPyPzE4D<float> >) );
      instance.SetNew(&new_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetNewArray(&newArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDelete(&delete_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.SetDestructor(&destruct_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<ROOT::Math::PxPyPzE4D<float> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<ROOT::Math::PxPyPzE4D<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<ROOT::Math::PxPyPzE4D<float> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PxPyPzE4D<float> > : new vector<ROOT::Math::PxPyPzE4D<float> >;
   }
   static void *newArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<ROOT::Math::PxPyPzE4D<float> >[nElements] : new vector<ROOT::Math::PxPyPzE4D<float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      delete ((vector<ROOT::Math::PxPyPzE4D<float> >*)p);
   }
   static void deleteArray_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      delete [] ((vector<ROOT::Math::PxPyPzE4D<float> >*)p);
   }
   static void destruct_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void *p) {
      typedef vector<ROOT::Math::PxPyPzE4D<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<ROOT::Math::PxPyPzE4D<float> >

namespace ROOT {
   void vectorlETStringgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlETStringgR_Dictionary();
   static void *new_vectorlETStringgR(void *p = 0);
   static void *newArray_vectorlETStringgR(Long_t size, void *p);
   static void delete_vectorlETStringgR(void *p);
   static void deleteArray_vectorlETStringgR(void *p);
   static void destruct_vectorlETStringgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<TString>*)
   {
      vector<TString> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<TString>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<TString>", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<TString>), DefineBehavior(ptr, ptr),
                  0, &vectorlETStringgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<TString>) );
      instance.SetNew(&new_vectorlETStringgR);
      instance.SetNewArray(&newArray_vectorlETStringgR);
      instance.SetDelete(&delete_vectorlETStringgR);
      instance.SetDeleteArray(&deleteArray_vectorlETStringgR);
      instance.SetDestructor(&destruct_vectorlETStringgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<TString> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<TString>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlETStringgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<TString>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlETStringgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TString> : new vector<TString>;
   }
   static void *newArray_vectorlETStringgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<TString>[nElements] : new vector<TString>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlETStringgR(void *p) {
      delete ((vector<TString>*)p);
   }
   static void deleteArray_vectorlETStringgR(void *p) {
      delete [] ((vector<TString>*)p);
   }
   static void destruct_vectorlETStringgR(void *p) {
      typedef vector<TString> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<TString>

namespace ROOT {
   void vectorlEboolgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEboolgR_Dictionary();
   static void *new_vectorlEboolgR(void *p = 0);
   static void *newArray_vectorlEboolgR(Long_t size, void *p);
   static void delete_vectorlEboolgR(void *p);
   static void deleteArray_vectorlEboolgR(void *p);
   static void destruct_vectorlEboolgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<bool>*)
   {
      vector<bool> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<bool>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<bool>", -2, "vectorbool.dll", 0,
                  typeid(vector<bool>), DefineBehavior(ptr, ptr),
                  0, &vectorlEboolgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<bool>) );
      instance.SetNew(&new_vectorlEboolgR);
      instance.SetNewArray(&newArray_vectorlEboolgR);
      instance.SetDelete(&delete_vectorlEboolgR);
      instance.SetDeleteArray(&deleteArray_vectorlEboolgR);
      instance.SetDestructor(&destruct_vectorlEboolgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<bool> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<bool>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEboolgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<bool>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEboolgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<bool> : new vector<bool>;
   }
   static void *newArray_vectorlEboolgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<bool>[nElements] : new vector<bool>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEboolgR(void *p) {
      delete ((vector<bool>*)p);
   }
   static void deleteArray_vectorlEboolgR(void *p) {
      delete [] ((vector<bool>*)p);
   }
   static void destruct_vectorlEboolgR(void *p) {
      typedef vector<bool> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<bool>

namespace ROOT {
   void vectorlEdoublegR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEdoublegR_Dictionary();
   static void *new_vectorlEdoublegR(void *p = 0);
   static void *newArray_vectorlEdoublegR(Long_t size, void *p);
   static void delete_vectorlEdoublegR(void *p);
   static void deleteArray_vectorlEdoublegR(void *p);
   static void destruct_vectorlEdoublegR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<double>*)
   {
      vector<double> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<double>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<double>", -2, "vector.dll", 0,
                  typeid(vector<double>), DefineBehavior(ptr, ptr),
                  0, &vectorlEdoublegR_Dictionary, isa_proxy, 0,
                  sizeof(vector<double>) );
      instance.SetNew(&new_vectorlEdoublegR);
      instance.SetNewArray(&newArray_vectorlEdoublegR);
      instance.SetDelete(&delete_vectorlEdoublegR);
      instance.SetDeleteArray(&deleteArray_vectorlEdoublegR);
      instance.SetDestructor(&destruct_vectorlEdoublegR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<double> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<double>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEdoublegR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<double>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEdoublegR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double> : new vector<double>;
   }
   static void *newArray_vectorlEdoublegR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<double>[nElements] : new vector<double>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEdoublegR(void *p) {
      delete ((vector<double>*)p);
   }
   static void deleteArray_vectorlEdoublegR(void *p) {
      delete [] ((vector<double>*)p);
   }
   static void destruct_vectorlEdoublegR(void *p) {
      typedef vector<double> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<double>

namespace ROOT {
   void vectorlEfloatgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEfloatgR_Dictionary();
   static void *new_vectorlEfloatgR(void *p = 0);
   static void *newArray_vectorlEfloatgR(Long_t size, void *p);
   static void delete_vectorlEfloatgR(void *p);
   static void deleteArray_vectorlEfloatgR(void *p);
   static void destruct_vectorlEfloatgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<float>*)
   {
      vector<float> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<float>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<float>", -2, "vector.dll", 0,
                  typeid(vector<float>), DefineBehavior(ptr, ptr),
                  0, &vectorlEfloatgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<float>) );
      instance.SetNew(&new_vectorlEfloatgR);
      instance.SetNewArray(&newArray_vectorlEfloatgR);
      instance.SetDelete(&delete_vectorlEfloatgR);
      instance.SetDeleteArray(&deleteArray_vectorlEfloatgR);
      instance.SetDestructor(&destruct_vectorlEfloatgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<float> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<float>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEfloatgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<float>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEfloatgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<float> : new vector<float>;
   }
   static void *newArray_vectorlEfloatgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<float>[nElements] : new vector<float>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEfloatgR(void *p) {
      delete ((vector<float>*)p);
   }
   static void deleteArray_vectorlEfloatgR(void *p) {
      delete [] ((vector<float>*)p);
   }
   static void destruct_vectorlEfloatgR(void *p) {
      typedef vector<float> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<float>

namespace ROOT {
   void vectorlEintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEintgR_Dictionary();
   static void *new_vectorlEintgR(void *p = 0);
   static void *newArray_vectorlEintgR(Long_t size, void *p);
   static void delete_vectorlEintgR(void *p);
   static void deleteArray_vectorlEintgR(void *p);
   static void destruct_vectorlEintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<int>*)
   {
      vector<int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<int>", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<int>) );
      instance.SetNew(&new_vectorlEintgR);
      instance.SetNewArray(&newArray_vectorlEintgR);
      instance.SetDelete(&delete_vectorlEintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEintgR);
      instance.SetDestructor(&destruct_vectorlEintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int> : new vector<int>;
   }
   static void *newArray_vectorlEintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<int>[nElements] : new vector<int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEintgR(void *p) {
      delete ((vector<int>*)p);
   }
   static void deleteArray_vectorlEintgR(void *p) {
      delete [] ((vector<int>*)p);
   }
   static void destruct_vectorlEintgR(void *p) {
      typedef vector<int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<int>

namespace ROOT {
   void vectorlEunsignedsPintgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEunsignedsPintgR_Dictionary();
   static void *new_vectorlEunsignedsPintgR(void *p = 0);
   static void *newArray_vectorlEunsignedsPintgR(Long_t size, void *p);
   static void delete_vectorlEunsignedsPintgR(void *p);
   static void deleteArray_vectorlEunsignedsPintgR(void *p);
   static void destruct_vectorlEunsignedsPintgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<unsigned int>*)
   {
      vector<unsigned int> *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<unsigned int>),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<unsigned int>", -2, "vector.dll", 0,
                  typeid(vector<unsigned int>), DefineBehavior(ptr, ptr),
                  0, &vectorlEunsignedsPintgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<unsigned int>) );
      instance.SetNew(&new_vectorlEunsignedsPintgR);
      instance.SetNewArray(&newArray_vectorlEunsignedsPintgR);
      instance.SetDelete(&delete_vectorlEunsignedsPintgR);
      instance.SetDeleteArray(&deleteArray_vectorlEunsignedsPintgR);
      instance.SetDestructor(&destruct_vectorlEunsignedsPintgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<unsigned int> >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<unsigned int>*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEunsignedsPintgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<unsigned int>*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEunsignedsPintgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int> : new vector<unsigned int>;
   }
   static void *newArray_vectorlEunsignedsPintgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<unsigned int>[nElements] : new vector<unsigned int>[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEunsignedsPintgR(void *p) {
      delete ((vector<unsigned int>*)p);
   }
   static void deleteArray_vectorlEunsignedsPintgR(void *p) {
      delete [] ((vector<unsigned int>*)p);
   }
   static void destruct_vectorlEunsignedsPintgR(void *p) {
      typedef vector<unsigned int> current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<unsigned int>

namespace ROOT {
   void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >*)
   {
      vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >) );
      instance.SetNew(&new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > : new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >;
   }
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >[nElements] : new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p) {
      delete ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >*)p);
   }
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >*)p);
   }
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR(void *p) {
      typedef vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >

namespace ROOT {
   void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)
   {
      vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >) );
      instance.SetNew(&new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > : new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >;
   }
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >[nElements] : new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p) {
      delete ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)p);
   }
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)p);
   }
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void *p) {
      typedef vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >

namespace ROOT {
   void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >*)
   {
      vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >) );
      instance.SetNew(&new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > : new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >;
   }
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >[nElements] : new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      delete ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      delete [] ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >*)p);
   }
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      typedef vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >

namespace ROOT {
   void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)
   {
      vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >) );
      instance.SetNew(&new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > : new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >;
   }
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >[nElements] : new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      delete ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      delete [] ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)p);
   }
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void *p) {
      typedef vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >

namespace ROOT {
   void vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<ROOT::Math::PxPyPzE4D<float> > >*)
   {
      vector<vector<ROOT::Math::PxPyPzE4D<float> > > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<ROOT::Math::PxPyPzE4D<float> > >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<ROOT::Math::PxPyPzE4D<float> > >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<ROOT::Math::PxPyPzE4D<float> > >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary, isa_proxy, 4,
                  sizeof(vector<vector<ROOT::Math::PxPyPzE4D<float> > >) );
      instance.SetNew(&new_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<ROOT::Math::PxPyPzE4D<float> > > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PxPyPzE4D<float> > >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<ROOT::Math::PxPyPzE4D<float> > >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PxPyPzE4D<float> > > : new vector<vector<ROOT::Math::PxPyPzE4D<float> > >;
   }
   static void *newArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<ROOT::Math::PxPyPzE4D<float> > >[nElements] : new vector<vector<ROOT::Math::PxPyPzE4D<float> > >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete ((vector<vector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void deleteArray_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      delete [] ((vector<vector<ROOT::Math::PxPyPzE4D<float> > >*)p);
   }
   static void destruct_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void *p) {
      typedef vector<vector<ROOT::Math::PxPyPzE4D<float> > > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<ROOT::Math::PxPyPzE4D<float> > >

namespace ROOT {
   void vectorlEvectorlETStringgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlETStringgRsPgR_Dictionary();
   static void *new_vectorlEvectorlETStringgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlETStringgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlETStringgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlETStringgRsPgR(void *p);
   static void destruct_vectorlEvectorlETStringgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<TString> >*)
   {
      vector<vector<TString> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<TString> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<TString> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<TString> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlETStringgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<TString> >) );
      instance.SetNew(&new_vectorlEvectorlETStringgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlETStringgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlETStringgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlETStringgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlETStringgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<TString> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<TString> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlETStringgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<TString> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlETStringgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<TString> > : new vector<vector<TString> >;
   }
   static void *newArray_vectorlEvectorlETStringgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<TString> >[nElements] : new vector<vector<TString> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlETStringgRsPgR(void *p) {
      delete ((vector<vector<TString> >*)p);
   }
   static void deleteArray_vectorlEvectorlETStringgRsPgR(void *p) {
      delete [] ((vector<vector<TString> >*)p);
   }
   static void destruct_vectorlEvectorlETStringgRsPgR(void *p) {
      typedef vector<vector<TString> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<TString> >

namespace ROOT {
   void vectorlEvectorlEdoublegRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEdoublegRsPgR_Dictionary();
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p);
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<double> >*)
   {
      vector<vector<double> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<double> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<double> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<double> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEdoublegRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<double> >) );
      instance.SetNew(&new_vectorlEvectorlEdoublegRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEdoublegRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEdoublegRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEdoublegRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<double> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<double> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEdoublegRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<double> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEdoublegRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> > : new vector<vector<double> >;
   }
   static void *newArray_vectorlEvectorlEdoublegRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<double> >[nElements] : new vector<vector<double> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete ((vector<vector<double> >*)p);
   }
   static void deleteArray_vectorlEvectorlEdoublegRsPgR(void *p) {
      delete [] ((vector<vector<double> >*)p);
   }
   static void destruct_vectorlEvectorlEdoublegRsPgR(void *p) {
      typedef vector<vector<double> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<double> >

namespace ROOT {
   void vectorlEvectorlEfloatgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEfloatgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEfloatgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEfloatgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEfloatgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEfloatgRsPgR(void *p);
   static void destruct_vectorlEvectorlEfloatgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<float> >*)
   {
      vector<vector<float> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<float> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<float> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<float> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEfloatgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<float> >) );
      instance.SetNew(&new_vectorlEvectorlEfloatgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEfloatgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEfloatgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEfloatgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEfloatgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<float> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<float> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEfloatgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<float> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEfloatgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<float> > : new vector<vector<float> >;
   }
   static void *newArray_vectorlEvectorlEfloatgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<float> >[nElements] : new vector<vector<float> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEfloatgRsPgR(void *p) {
      delete ((vector<vector<float> >*)p);
   }
   static void deleteArray_vectorlEvectorlEfloatgRsPgR(void *p) {
      delete [] ((vector<vector<float> >*)p);
   }
   static void destruct_vectorlEvectorlEfloatgRsPgR(void *p) {
      typedef vector<vector<float> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<float> >

namespace ROOT {
   void vectorlEvectorlEintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEintgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEintgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEintgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEintgRsPgR(void *p);
   static void destruct_vectorlEvectorlEintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<int> >*)
   {
      vector<vector<int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<int> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<int> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<int> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<int> >) );
      instance.SetNew(&new_vectorlEvectorlEintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEintgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<int> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEintgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<int> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<int> > : new vector<vector<int> >;
   }
   static void *newArray_vectorlEvectorlEintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<int> >[nElements] : new vector<vector<int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEintgRsPgR(void *p) {
      delete ((vector<vector<int> >*)p);
   }
   static void deleteArray_vectorlEvectorlEintgRsPgR(void *p) {
      delete [] ((vector<vector<int> >*)p);
   }
   static void destruct_vectorlEvectorlEintgRsPgR(void *p) {
      typedef vector<vector<int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<int> >

namespace ROOT {
   void vectorlEvectorlEunsignedsPintgRsPgR_ShowMembers(void *obj, TMemberInspector &R__insp);
   static void vectorlEvectorlEunsignedsPintgRsPgR_Dictionary();
   static void *new_vectorlEvectorlEunsignedsPintgRsPgR(void *p = 0);
   static void *newArray_vectorlEvectorlEunsignedsPintgRsPgR(Long_t size, void *p);
   static void delete_vectorlEvectorlEunsignedsPintgRsPgR(void *p);
   static void deleteArray_vectorlEvectorlEunsignedsPintgRsPgR(void *p);
   static void destruct_vectorlEvectorlEunsignedsPintgRsPgR(void *p);

   // Function generating the singleton type initializer
   static TGenericClassInfo *GenerateInitInstanceLocal(const vector<vector<unsigned int> >*)
   {
      vector<vector<unsigned int> > *ptr = 0;
      static ::TVirtualIsAProxy* isa_proxy = new ::TIsAProxy(typeid(vector<vector<unsigned int> >),0);
      static ::ROOT::TGenericClassInfo 
         instance("vector<vector<unsigned int> >", -2, "/grid_mnt/opt__exp_soft/cms/slc5_amd64_gcc462/lcg/root/5.32.00-cms9/cint/cint/lib/prec_stl/vector", 49,
                  typeid(vector<vector<unsigned int> >), DefineBehavior(ptr, ptr),
                  0, &vectorlEvectorlEunsignedsPintgRsPgR_Dictionary, isa_proxy, 0,
                  sizeof(vector<vector<unsigned int> >) );
      instance.SetNew(&new_vectorlEvectorlEunsignedsPintgRsPgR);
      instance.SetNewArray(&newArray_vectorlEvectorlEunsignedsPintgRsPgR);
      instance.SetDelete(&delete_vectorlEvectorlEunsignedsPintgRsPgR);
      instance.SetDeleteArray(&deleteArray_vectorlEvectorlEunsignedsPintgRsPgR);
      instance.SetDestructor(&destruct_vectorlEvectorlEunsignedsPintgRsPgR);
      instance.AdoptCollectionProxyInfo(TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< vector<vector<unsigned int> > >()));
      return &instance;
   }
   // Static variable to force the class initialization
   static ::ROOT::TGenericClassInfo *_R__UNIQUE_(Init) = GenerateInitInstanceLocal((const vector<vector<unsigned int> >*)0x0); R__UseDummy(_R__UNIQUE_(Init));

   // Dictionary for non-ClassDef classes
   static void vectorlEvectorlEunsignedsPintgRsPgR_Dictionary() {
      ::ROOT::GenerateInitInstanceLocal((const vector<vector<unsigned int> >*)0x0)->GetClass();
   }

} // end of namespace ROOT

namespace ROOT {
   // Wrappers around operator new
   static void *new_vectorlEvectorlEunsignedsPintgRsPgR(void *p) {
      return  p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<unsigned int> > : new vector<vector<unsigned int> >;
   }
   static void *newArray_vectorlEvectorlEunsignedsPintgRsPgR(Long_t nElements, void *p) {
      return p ? ::new((::ROOT::TOperatorNewHelper*)p) vector<vector<unsigned int> >[nElements] : new vector<vector<unsigned int> >[nElements];
   }
   // Wrapper around operator delete
   static void delete_vectorlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete ((vector<vector<unsigned int> >*)p);
   }
   static void deleteArray_vectorlEvectorlEunsignedsPintgRsPgR(void *p) {
      delete [] ((vector<vector<unsigned int> >*)p);
   }
   static void destruct_vectorlEvectorlEunsignedsPintgRsPgR(void *p) {
      typedef vector<vector<unsigned int> > current_t;
      ((current_t*)p)->~current_t();
   }
} // end of namespace ROOT for class vector<vector<unsigned int> >

/********************************************************
* MiniFWLiteDict.cc
* CAUTION: DON'T CHANGE THIS FILE. THIS FILE IS AUTOMATICALLY GENERATED
*          FROM HEADER FILES LISTED IN G__setup_cpp_environmentXXX().
*          CHANGE THOSE HEADER FILES AND REGENERATE THIS FILE.
********************************************************/

#ifdef G__MEMTEST
#undef malloc
#undef free
#endif

#if defined(__GNUC__) && __GNUC__ >= 4 && ((__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >= 1) || (__GNUC_MINOR__ >= 3))
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif

extern "C" void G__cpp_reset_tagtableMiniFWLiteDict();

extern "C" void G__set_cpp_environmentMiniFWLiteDict() {
  G__add_ipath("$ROOTSYS/include");
  G__cpp_reset_tagtableMiniFWLiteDict();
}
#include <new>
extern "C" int G__cpp_dllrevMiniFWLiteDict() { return(30051515); }

/*********************************************************
* Member function Interface Method
*********************************************************/

/* edm::EDProduct */
static int G__MiniFWLiteDict_163_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EDProduct* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EDProduct[n];
     } else {
       p = new((void*) gvp) edm::EDProduct[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EDProduct;
     } else {
       p = new((void*) gvp) edm::EDProduct;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_163_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const edm::EDProduct*) G__getstructoffset())->isPresent());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_163_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const edm::EDProduct*) G__getstructoffset())->isMergeable());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_163_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((edm::EDProduct*) G__getstructoffset())->mergeProduct((edm::EDProduct*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_163_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const edm::EDProduct*) G__getstructoffset())->hasIsProductEqual());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_163_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const edm::EDProduct*) G__getstructoffset())->isProductEqual((edm::EDProduct*) G__int(libp->para[0])));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_163_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EDProduct* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EDProduct(*(edm::EDProduct*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EDProduct G__TedmcLcLEDProduct;
static int G__MiniFWLiteDict_163_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EDProduct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EDProduct*) (soff+(sizeof(edm::EDProduct)*i)))->~G__TedmcLcLEDProduct();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EDProduct*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EDProduct*) (soff))->~G__TedmcLcLEDProduct();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_163_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EDProduct* dest = (edm::EDProduct*) G__getstructoffset();
   *dest = *(edm::EDProduct*) libp->para[0].ref;
   const edm::EDProduct& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::BranchKey */
// automatic default constructor
static int G__MiniFWLiteDict_488_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchKey *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchKey[n];
     } else {
       p = new((void*) gvp) edm::BranchKey[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchKey;
     } else {
       p = new((void*) gvp) edm::BranchKey;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_488_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::BranchKey* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::BranchKey(*(edm::BranchKey*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::BranchKey G__TedmcLcLBranchKey;
static int G__MiniFWLiteDict_488_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::BranchKey*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::BranchKey*) (soff+(sizeof(edm::BranchKey)*i)))->~G__TedmcLcLBranchKey();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::BranchKey*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::BranchKey*) (soff))->~G__TedmcLcLBranchKey();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_488_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchKey* dest = (edm::BranchKey*) G__getstructoffset();
   const edm::BranchKey& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventAuxiliary */
// automatic default constructor
static int G__MiniFWLiteDict_489_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventAuxiliary *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventAuxiliary[n];
     } else {
       p = new((void*) gvp) edm::EventAuxiliary[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventAuxiliary;
     } else {
       p = new((void*) gvp) edm::EventAuxiliary;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_489_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventAuxiliary* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventAuxiliary(*(edm::EventAuxiliary*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventAuxiliary G__TedmcLcLEventAuxiliary;
static int G__MiniFWLiteDict_489_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventAuxiliary*) (soff+(sizeof(edm::EventAuxiliary)*i)))->~G__TedmcLcLEventAuxiliary();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventAuxiliary*) (soff))->~G__TedmcLcLEventAuxiliary();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_489_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventAuxiliary* dest = (edm::EventAuxiliary*) G__getstructoffset();
   const edm::EventAuxiliary& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::FileFormatVersion */
// automatic default constructor
static int G__MiniFWLiteDict_490_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileFormatVersion *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileFormatVersion[n];
     } else {
       p = new((void*) gvp) edm::FileFormatVersion[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileFormatVersion;
     } else {
       p = new((void*) gvp) edm::FileFormatVersion;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_490_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::FileFormatVersion* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::FileFormatVersion(*(edm::FileFormatVersion*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::FileFormatVersion G__TedmcLcLFileFormatVersion;
static int G__MiniFWLiteDict_490_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::FileFormatVersion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::FileFormatVersion*) (soff+(sizeof(edm::FileFormatVersion)*i)))->~G__TedmcLcLFileFormatVersion();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::FileFormatVersion*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::FileFormatVersion*) (soff))->~G__TedmcLcLFileFormatVersion();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_490_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileFormatVersion* dest = (edm::FileFormatVersion*) G__getstructoffset();
   const edm::FileFormatVersion& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::LuminosityBlockAuxiliary */
// automatic default constructor
static int G__MiniFWLiteDict_491_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::LuminosityBlockAuxiliary *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::LuminosityBlockAuxiliary[n];
     } else {
       p = new((void*) gvp) edm::LuminosityBlockAuxiliary[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::LuminosityBlockAuxiliary;
     } else {
       p = new((void*) gvp) edm::LuminosityBlockAuxiliary;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_491_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::LuminosityBlockAuxiliary* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::LuminosityBlockAuxiliary(*(edm::LuminosityBlockAuxiliary*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::LuminosityBlockAuxiliary G__TedmcLcLLuminosityBlockAuxiliary;
static int G__MiniFWLiteDict_491_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::LuminosityBlockAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::LuminosityBlockAuxiliary*) (soff+(sizeof(edm::LuminosityBlockAuxiliary)*i)))->~G__TedmcLcLLuminosityBlockAuxiliary();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::LuminosityBlockAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::LuminosityBlockAuxiliary*) (soff))->~G__TedmcLcLLuminosityBlockAuxiliary();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_491_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::LuminosityBlockAuxiliary* dest = (edm::LuminosityBlockAuxiliary*) G__getstructoffset();
   const edm::LuminosityBlockAuxiliary& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ParameterSetBlob */
// automatic default constructor
static int G__MiniFWLiteDict_492_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ParameterSetBlob *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ParameterSetBlob[n];
     } else {
       p = new((void*) gvp) edm::ParameterSetBlob[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ParameterSetBlob;
     } else {
       p = new((void*) gvp) edm::ParameterSetBlob;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_492_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ParameterSetBlob* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ParameterSetBlob(*(edm::ParameterSetBlob*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ParameterSetBlob G__TedmcLcLParameterSetBlob;
static int G__MiniFWLiteDict_492_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ParameterSetBlob*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ParameterSetBlob*) (soff+(sizeof(edm::ParameterSetBlob)*i)))->~G__TedmcLcLParameterSetBlob();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ParameterSetBlob*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ParameterSetBlob*) (soff))->~G__TedmcLcLParameterSetBlob();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_492_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ParameterSetBlob* dest = (edm::ParameterSetBlob*) G__getstructoffset();
   const edm::ParameterSetBlob& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::RunAuxiliary */
// automatic default constructor
static int G__MiniFWLiteDict_493_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::RunAuxiliary *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::RunAuxiliary[n];
     } else {
       p = new((void*) gvp) edm::RunAuxiliary[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::RunAuxiliary;
     } else {
       p = new((void*) gvp) edm::RunAuxiliary;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_493_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::RunAuxiliary* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::RunAuxiliary(*(edm::RunAuxiliary*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::RunAuxiliary G__TedmcLcLRunAuxiliary;
static int G__MiniFWLiteDict_493_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::RunAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::RunAuxiliary*) (soff+(sizeof(edm::RunAuxiliary)*i)))->~G__TedmcLcLRunAuxiliary();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::RunAuxiliary*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::RunAuxiliary*) (soff))->~G__TedmcLcLRunAuxiliary();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_493_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::RunAuxiliary* dest = (edm::RunAuxiliary*) G__getstructoffset();
   const edm::RunAuxiliary& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::BranchChildren */
// automatic default constructor
static int G__MiniFWLiteDict_494_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchChildren *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchChildren[n];
     } else {
       p = new((void*) gvp) edm::BranchChildren[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchChildren;
     } else {
       p = new((void*) gvp) edm::BranchChildren;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_494_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::BranchChildren* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::BranchChildren(*(edm::BranchChildren*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::BranchChildren G__TedmcLcLBranchChildren;
static int G__MiniFWLiteDict_494_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::BranchChildren*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::BranchChildren*) (soff+(sizeof(edm::BranchChildren)*i)))->~G__TedmcLcLBranchChildren();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::BranchChildren*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::BranchChildren*) (soff))->~G__TedmcLcLBranchChildren();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_494_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchChildren* dest = (edm::BranchChildren*) G__getstructoffset();
   const edm::BranchChildren& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::BranchDescription */
// automatic default constructor
static int G__MiniFWLiteDict_495_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchDescription *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchDescription[n];
     } else {
       p = new((void*) gvp) edm::BranchDescription[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchDescription;
     } else {
       p = new((void*) gvp) edm::BranchDescription;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_495_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::BranchDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::BranchDescription(*(edm::BranchDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::BranchDescription G__TedmcLcLBranchDescription;
static int G__MiniFWLiteDict_495_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::BranchDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::BranchDescription*) (soff+(sizeof(edm::BranchDescription)*i)))->~G__TedmcLcLBranchDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::BranchDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::BranchDescription*) (soff))->~G__TedmcLcLBranchDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_495_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchDescription* dest = (edm::BranchDescription*) G__getstructoffset();
   const edm::BranchDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::BranchDescription::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_496_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchDescription::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchDescription::Transients[n];
     } else {
       p = new((void*) gvp) edm::BranchDescription::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchDescription::Transients;
     } else {
       p = new((void*) gvp) edm::BranchDescription::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_496_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::BranchDescription::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::BranchDescription::Transients(*(edm::BranchDescription::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::BranchDescription::Transients G__TedmcLcLBranchDescriptioncLcLTransients;
static int G__MiniFWLiteDict_496_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::BranchDescription::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::BranchDescription::Transients*) (soff+(sizeof(edm::BranchDescription::Transients)*i)))->~G__TedmcLcLBranchDescriptioncLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::BranchDescription::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::BranchDescription::Transients*) (soff))->~G__TedmcLcLBranchDescriptioncLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_496_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchDescription::Transients* dest = (edm::BranchDescription::Transients*) G__getstructoffset();
   const edm::BranchDescription::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::BranchID */
static int G__MiniFWLiteDict_497_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const edm::BranchID*) G__getstructoffset())->operator<(*(edm::BranchID*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic default constructor
static int G__MiniFWLiteDict_497_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchID[n];
     } else {
       p = new((void*) gvp) edm::BranchID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::BranchID;
     } else {
       p = new((void*) gvp) edm::BranchID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_497_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::BranchID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::BranchID(*(edm::BranchID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::BranchID G__TedmcLcLBranchID;
static int G__MiniFWLiteDict_497_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::BranchID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::BranchID*) (soff+(sizeof(edm::BranchID)*i)))->~G__TedmcLcLBranchID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::BranchID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::BranchID*) (soff))->~G__TedmcLcLBranchID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_497_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::BranchID* dest = (edm::BranchID*) G__getstructoffset();
   const edm::BranchID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventEntryDescription */
// automatic default constructor
static int G__MiniFWLiteDict_498_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryDescription *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryDescription[n];
     } else {
       p = new((void*) gvp) edm::EventEntryDescription[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryDescription;
     } else {
       p = new((void*) gvp) edm::EventEntryDescription;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_498_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventEntryDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventEntryDescription(*(edm::EventEntryDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventEntryDescription G__TedmcLcLEventEntryDescription;
static int G__MiniFWLiteDict_498_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventEntryDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventEntryDescription*) (soff+(sizeof(edm::EventEntryDescription)*i)))->~G__TedmcLcLEventEntryDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventEntryDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventEntryDescription*) (soff))->~G__TedmcLcLEventEntryDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_498_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryDescription* dest = (edm::EventEntryDescription*) G__getstructoffset();
   const edm::EventEntryDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventEntryDescription::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_499_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryDescription::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryDescription::Transients[n];
     } else {
       p = new((void*) gvp) edm::EventEntryDescription::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryDescription::Transients;
     } else {
       p = new((void*) gvp) edm::EventEntryDescription::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_499_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventEntryDescription::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventEntryDescription::Transients(*(edm::EventEntryDescription::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventEntryDescription::Transients G__TedmcLcLEventEntryDescriptioncLcLTransients;
static int G__MiniFWLiteDict_499_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventEntryDescription::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventEntryDescription::Transients*) (soff+(sizeof(edm::EventEntryDescription::Transients)*i)))->~G__TedmcLcLEventEntryDescriptioncLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventEntryDescription::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventEntryDescription::Transients*) (soff))->~G__TedmcLcLEventEntryDescriptioncLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_499_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryDescription::Transients* dest = (edm::EventEntryDescription::Transients*) G__getstructoffset();
   const edm::EventEntryDescription::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventEntryInfo */
// automatic default constructor
static int G__MiniFWLiteDict_500_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryInfo *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryInfo[n];
     } else {
       p = new((void*) gvp) edm::EventEntryInfo[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryInfo;
     } else {
       p = new((void*) gvp) edm::EventEntryInfo;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_500_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventEntryInfo* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventEntryInfo(*(edm::EventEntryInfo*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventEntryInfo G__TedmcLcLEventEntryInfo;
static int G__MiniFWLiteDict_500_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventEntryInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventEntryInfo*) (soff+(sizeof(edm::EventEntryInfo)*i)))->~G__TedmcLcLEventEntryInfo();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventEntryInfo*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventEntryInfo*) (soff))->~G__TedmcLcLEventEntryInfo();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_500_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryInfo* dest = (edm::EventEntryInfo*) G__getstructoffset();
   const edm::EventEntryInfo& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventEntryInfo::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_501_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryInfo::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryInfo::Transients[n];
     } else {
       p = new((void*) gvp) edm::EventEntryInfo::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventEntryInfo::Transients;
     } else {
       p = new((void*) gvp) edm::EventEntryInfo::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_501_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventEntryInfo::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventEntryInfo::Transients(*(edm::EventEntryInfo::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventEntryInfo::Transients G__TedmcLcLEventEntryInfocLcLTransients;
static int G__MiniFWLiteDict_501_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventEntryInfo::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventEntryInfo::Transients*) (soff+(sizeof(edm::EventEntryInfo::Transients)*i)))->~G__TedmcLcLEventEntryInfocLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventEntryInfo::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventEntryInfo::Transients*) (soff))->~G__TedmcLcLEventEntryInfocLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_501_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventEntryInfo::Transients* dest = (edm::EventEntryInfo::Transients*) G__getstructoffset();
   const edm::EventEntryInfo::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::EventID */
// automatic default constructor
static int G__MiniFWLiteDict_502_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventID[n];
     } else {
       p = new((void*) gvp) edm::EventID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::EventID;
     } else {
       p = new((void*) gvp) edm::EventID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_502_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::EventID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::EventID(*(edm::EventID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::EventID G__TedmcLcLEventID;
static int G__MiniFWLiteDict_502_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::EventID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::EventID*) (soff+(sizeof(edm::EventID)*i)))->~G__TedmcLcLEventID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::EventID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::EventID*) (soff))->~G__TedmcLcLEventID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_502_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::EventID* dest = (edm::EventID*) G__getstructoffset();
   const edm::EventID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::FileID */
// automatic default constructor
static int G__MiniFWLiteDict_503_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileID[n];
     } else {
       p = new((void*) gvp) edm::FileID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileID;
     } else {
       p = new((void*) gvp) edm::FileID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_503_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::FileID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::FileID(*(edm::FileID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::FileID G__TedmcLcLFileID;
static int G__MiniFWLiteDict_503_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::FileID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::FileID*) (soff+(sizeof(edm::FileID)*i)))->~G__TedmcLcLFileID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::FileID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::FileID*) (soff))->~G__TedmcLcLFileID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_503_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileID* dest = (edm::FileID*) G__getstructoffset();
   const edm::FileID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::FileIndex */
// automatic default constructor
static int G__MiniFWLiteDict_504_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex[n];
     } else {
       p = new((void*) gvp) edm::FileIndex[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex;
     } else {
       p = new((void*) gvp) edm::FileIndex;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_504_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::FileIndex* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::FileIndex(*(edm::FileIndex*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::FileIndex G__TedmcLcLFileIndex;
static int G__MiniFWLiteDict_504_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::FileIndex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::FileIndex*) (soff+(sizeof(edm::FileIndex)*i)))->~G__TedmcLcLFileIndex();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::FileIndex*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::FileIndex*) (soff))->~G__TedmcLcLFileIndex();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_504_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex* dest = (edm::FileIndex*) G__getstructoffset();
   const edm::FileIndex& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::FileIndex::Element */
// automatic default constructor
static int G__MiniFWLiteDict_505_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex::Element *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex::Element[n];
     } else {
       p = new((void*) gvp) edm::FileIndex::Element[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex::Element;
     } else {
       p = new((void*) gvp) edm::FileIndex::Element;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_505_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::FileIndex::Element* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::FileIndex::Element(*(edm::FileIndex::Element*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::FileIndex::Element G__TedmcLcLFileIndexcLcLElement;
static int G__MiniFWLiteDict_505_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::FileIndex::Element*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::FileIndex::Element*) (soff+(sizeof(edm::FileIndex::Element)*i)))->~G__TedmcLcLFileIndexcLcLElement();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::FileIndex::Element*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::FileIndex::Element*) (soff))->~G__TedmcLcLFileIndexcLcLElement();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_505_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex::Element* dest = (edm::FileIndex::Element*) G__getstructoffset();
   const edm::FileIndex::Element& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::FileIndex::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_506_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex::Transients[n];
     } else {
       p = new((void*) gvp) edm::FileIndex::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::FileIndex::Transients;
     } else {
       p = new((void*) gvp) edm::FileIndex::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_506_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::FileIndex::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::FileIndex::Transients(*(edm::FileIndex::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::FileIndex::Transients G__TedmcLcLFileIndexcLcLTransients;
static int G__MiniFWLiteDict_506_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::FileIndex::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::FileIndex::Transients*) (soff+(sizeof(edm::FileIndex::Transients)*i)))->~G__TedmcLcLFileIndexcLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::FileIndex::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::FileIndex::Transients*) (soff))->~G__TedmcLcLFileIndexcLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_506_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::FileIndex::Transients* dest = (edm::FileIndex::Transients*) G__getstructoffset();
   const edm::FileIndex::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::History */
// automatic default constructor
static int G__MiniFWLiteDict_507_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::History *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::History[n];
     } else {
       p = new((void*) gvp) edm::History[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::History;
     } else {
       p = new((void*) gvp) edm::History;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_507_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::History* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::History(*(edm::History*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::History G__TedmcLcLHistory;
static int G__MiniFWLiteDict_507_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::History*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::History*) (soff+(sizeof(edm::History)*i)))->~G__TedmcLcLHistory();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::History*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::History*) (soff))->~G__TedmcLcLHistory();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_507_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::History* dest = (edm::History*) G__getstructoffset();
   const edm::History& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::LuminosityBlockID */
// automatic default constructor
static int G__MiniFWLiteDict_508_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::LuminosityBlockID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::LuminosityBlockID[n];
     } else {
       p = new((void*) gvp) edm::LuminosityBlockID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::LuminosityBlockID;
     } else {
       p = new((void*) gvp) edm::LuminosityBlockID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_508_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::LuminosityBlockID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::LuminosityBlockID(*(edm::LuminosityBlockID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::LuminosityBlockID G__TedmcLcLLuminosityBlockID;
static int G__MiniFWLiteDict_508_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::LuminosityBlockID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::LuminosityBlockID*) (soff+(sizeof(edm::LuminosityBlockID)*i)))->~G__TedmcLcLLuminosityBlockID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::LuminosityBlockID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::LuminosityBlockID*) (soff))->~G__TedmcLcLLuminosityBlockID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_508_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::LuminosityBlockID* dest = (edm::LuminosityBlockID*) G__getstructoffset();
   const edm::LuminosityBlockID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ModuleDescription */
// automatic default constructor
static int G__MiniFWLiteDict_509_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ModuleDescription *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ModuleDescription[n];
     } else {
       p = new((void*) gvp) edm::ModuleDescription[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ModuleDescription;
     } else {
       p = new((void*) gvp) edm::ModuleDescription;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_509_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ModuleDescription* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ModuleDescription(*(edm::ModuleDescription*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ModuleDescription G__TedmcLcLModuleDescription;
static int G__MiniFWLiteDict_509_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ModuleDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ModuleDescription*) (soff+(sizeof(edm::ModuleDescription)*i)))->~G__TedmcLcLModuleDescription();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ModuleDescription*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ModuleDescription*) (soff))->~G__TedmcLcLModuleDescription();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_509_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ModuleDescription* dest = (edm::ModuleDescription*) G__getstructoffset();
   const edm::ModuleDescription& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Parentage */
// automatic default constructor
static int G__MiniFWLiteDict_510_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Parentage *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Parentage[n];
     } else {
       p = new((void*) gvp) edm::Parentage[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Parentage;
     } else {
       p = new((void*) gvp) edm::Parentage;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_510_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Parentage* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Parentage(*(edm::Parentage*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Parentage G__TedmcLcLParentage;
static int G__MiniFWLiteDict_510_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Parentage*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Parentage*) (soff+(sizeof(edm::Parentage)*i)))->~G__TedmcLcLParentage();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Parentage*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Parentage*) (soff))->~G__TedmcLcLParentage();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_510_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Parentage* dest = (edm::Parentage*) G__getstructoffset();
   const edm::Parentage& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Parentage::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_511_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Parentage::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Parentage::Transients[n];
     } else {
       p = new((void*) gvp) edm::Parentage::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Parentage::Transients;
     } else {
       p = new((void*) gvp) edm::Parentage::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_511_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Parentage::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Parentage::Transients(*(edm::Parentage::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Parentage::Transients G__TedmcLcLParentagecLcLTransients;
static int G__MiniFWLiteDict_511_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Parentage::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Parentage::Transients*) (soff+(sizeof(edm::Parentage::Transients)*i)))->~G__TedmcLcLParentagecLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Parentage::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Parentage::Transients*) (soff))->~G__TedmcLcLParentagecLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_511_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Parentage::Transients* dest = (edm::Parentage::Transients*) G__getstructoffset();
   const edm::Parentage::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProcessConfiguration */
// automatic default constructor
static int G__MiniFWLiteDict_512_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessConfiguration *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessConfiguration[n];
     } else {
       p = new((void*) gvp) edm::ProcessConfiguration[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessConfiguration;
     } else {
       p = new((void*) gvp) edm::ProcessConfiguration;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_512_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProcessConfiguration* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProcessConfiguration(*(edm::ProcessConfiguration*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProcessConfiguration G__TedmcLcLProcessConfiguration;
static int G__MiniFWLiteDict_512_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProcessConfiguration*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProcessConfiguration*) (soff+(sizeof(edm::ProcessConfiguration)*i)))->~G__TedmcLcLProcessConfiguration();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProcessConfiguration*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProcessConfiguration*) (soff))->~G__TedmcLcLProcessConfiguration();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_512_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessConfiguration* dest = (edm::ProcessConfiguration*) G__getstructoffset();
   const edm::ProcessConfiguration& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProcessConfiguration::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_513_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessConfiguration::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessConfiguration::Transients[n];
     } else {
       p = new((void*) gvp) edm::ProcessConfiguration::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessConfiguration::Transients;
     } else {
       p = new((void*) gvp) edm::ProcessConfiguration::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_513_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProcessConfiguration::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProcessConfiguration::Transients(*(edm::ProcessConfiguration::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProcessConfiguration::Transients G__TedmcLcLProcessConfigurationcLcLTransients;
static int G__MiniFWLiteDict_513_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProcessConfiguration::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProcessConfiguration::Transients*) (soff+(sizeof(edm::ProcessConfiguration::Transients)*i)))->~G__TedmcLcLProcessConfigurationcLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProcessConfiguration::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProcessConfiguration::Transients*) (soff))->~G__TedmcLcLProcessConfigurationcLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_513_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessConfiguration::Transients* dest = (edm::ProcessConfiguration::Transients*) G__getstructoffset();
   const edm::ProcessConfiguration::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProcessHistory */
// automatic default constructor
static int G__MiniFWLiteDict_514_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessHistory *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessHistory[n];
     } else {
       p = new((void*) gvp) edm::ProcessHistory[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessHistory;
     } else {
       p = new((void*) gvp) edm::ProcessHistory;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_514_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProcessHistory* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProcessHistory(*(edm::ProcessHistory*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProcessHistory G__TedmcLcLProcessHistory;
static int G__MiniFWLiteDict_514_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProcessHistory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProcessHistory*) (soff+(sizeof(edm::ProcessHistory)*i)))->~G__TedmcLcLProcessHistory();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProcessHistory*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProcessHistory*) (soff))->~G__TedmcLcLProcessHistory();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_514_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessHistory* dest = (edm::ProcessHistory*) G__getstructoffset();
   const edm::ProcessHistory& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProcessHistory::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_515_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessHistory::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessHistory::Transients[n];
     } else {
       p = new((void*) gvp) edm::ProcessHistory::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProcessHistory::Transients;
     } else {
       p = new((void*) gvp) edm::ProcessHistory::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_515_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProcessHistory::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProcessHistory::Transients(*(edm::ProcessHistory::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProcessHistory::Transients G__TedmcLcLProcessHistorycLcLTransients;
static int G__MiniFWLiteDict_515_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProcessHistory::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProcessHistory::Transients*) (soff+(sizeof(edm::ProcessHistory::Transients)*i)))->~G__TedmcLcLProcessHistorycLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProcessHistory::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProcessHistory::Transients*) (soff))->~G__TedmcLcLProcessHistorycLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_515_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProcessHistory::Transients* dest = (edm::ProcessHistory::Transients*) G__getstructoffset();
   const edm::ProcessHistory::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProductID */
// automatic default constructor
static int G__MiniFWLiteDict_516_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductID[n];
     } else {
       p = new((void*) gvp) edm::ProductID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductID;
     } else {
       p = new((void*) gvp) edm::ProductID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_516_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProductID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProductID(*(edm::ProductID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProductID G__TedmcLcLProductID;
static int G__MiniFWLiteDict_516_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProductID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProductID*) (soff+(sizeof(edm::ProductID)*i)))->~G__TedmcLcLProductID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProductID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProductID*) (soff))->~G__TedmcLcLProductID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_516_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductID* dest = (edm::ProductID*) G__getstructoffset();
   const edm::ProductID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::StoredProductProvenance */
// automatic default constructor
static int G__MiniFWLiteDict_517_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::StoredProductProvenance *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::StoredProductProvenance[n];
     } else {
       p = new((void*) gvp) edm::StoredProductProvenance[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::StoredProductProvenance;
     } else {
       p = new((void*) gvp) edm::StoredProductProvenance;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_517_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::StoredProductProvenance* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::StoredProductProvenance(*(edm::StoredProductProvenance*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::StoredProductProvenance G__TedmcLcLStoredProductProvenance;
static int G__MiniFWLiteDict_517_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::StoredProductProvenance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::StoredProductProvenance*) (soff+(sizeof(edm::StoredProductProvenance)*i)))->~G__TedmcLcLStoredProductProvenance();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::StoredProductProvenance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::StoredProductProvenance*) (soff))->~G__TedmcLcLStoredProductProvenance();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_517_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::StoredProductProvenance* dest = (edm::StoredProductProvenance*) G__getstructoffset();
   const edm::StoredProductProvenance& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProductProvenance */
// automatic default constructor
static int G__MiniFWLiteDict_519_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductProvenance *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductProvenance[n];
     } else {
       p = new((void*) gvp) edm::ProductProvenance[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductProvenance;
     } else {
       p = new((void*) gvp) edm::ProductProvenance;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_519_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProductProvenance* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProductProvenance(*(edm::ProductProvenance*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProductProvenance G__TedmcLcLProductProvenance;
static int G__MiniFWLiteDict_519_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProductProvenance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProductProvenance*) (soff+(sizeof(edm::ProductProvenance)*i)))->~G__TedmcLcLProductProvenance();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProductProvenance*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProductProvenance*) (soff))->~G__TedmcLcLProductProvenance();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_519_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductProvenance* dest = (edm::ProductProvenance*) G__getstructoffset();
   const edm::ProductProvenance& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProductRegistry */
// automatic default constructor
static int G__MiniFWLiteDict_521_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductRegistry *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductRegistry[n];
     } else {
       p = new((void*) gvp) edm::ProductRegistry[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductRegistry;
     } else {
       p = new((void*) gvp) edm::ProductRegistry;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_521_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProductRegistry* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProductRegistry(*(edm::ProductRegistry*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProductRegistry G__TedmcLcLProductRegistry;
static int G__MiniFWLiteDict_521_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProductRegistry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProductRegistry*) (soff+(sizeof(edm::ProductRegistry)*i)))->~G__TedmcLcLProductRegistry();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProductRegistry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProductRegistry*) (soff))->~G__TedmcLcLProductRegistry();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_521_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductRegistry* dest = (edm::ProductRegistry*) G__getstructoffset();
   const edm::ProductRegistry& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::ProductRegistry::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_522_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductRegistry::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductRegistry::Transients[n];
     } else {
       p = new((void*) gvp) edm::ProductRegistry::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::ProductRegistry::Transients;
     } else {
       p = new((void*) gvp) edm::ProductRegistry::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_522_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::ProductRegistry::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::ProductRegistry::Transients(*(edm::ProductRegistry::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::ProductRegistry::Transients G__TedmcLcLProductRegistrycLcLTransients;
static int G__MiniFWLiteDict_522_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::ProductRegistry::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::ProductRegistry::Transients*) (soff+(sizeof(edm::ProductRegistry::Transients)*i)))->~G__TedmcLcLProductRegistrycLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::ProductRegistry::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::ProductRegistry::Transients*) (soff))->~G__TedmcLcLProductRegistrycLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_522_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::ProductRegistry::Transients* dest = (edm::ProductRegistry::Transients*) G__getstructoffset();
   const edm::ProductRegistry::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::RunID */
// automatic default constructor
static int G__MiniFWLiteDict_523_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::RunID *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::RunID[n];
     } else {
       p = new((void*) gvp) edm::RunID[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::RunID;
     } else {
       p = new((void*) gvp) edm::RunID;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_523_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::RunID* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::RunID(*(edm::RunID*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::RunID G__TedmcLcLRunID;
static int G__MiniFWLiteDict_523_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::RunID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::RunID*) (soff+(sizeof(edm::RunID)*i)))->~G__TedmcLcLRunID();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::RunID*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::RunID*) (soff))->~G__TedmcLcLRunID();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_523_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::RunID* dest = (edm::RunID*) G__getstructoffset();
   const edm::RunID& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Timestamp */
// automatic default constructor
static int G__MiniFWLiteDict_524_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Timestamp *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Timestamp[n];
     } else {
       p = new((void*) gvp) edm::Timestamp[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Timestamp;
     } else {
       p = new((void*) gvp) edm::Timestamp;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_524_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Timestamp* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Timestamp(*(edm::Timestamp*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Timestamp G__TedmcLcLTimestamp;
static int G__MiniFWLiteDict_524_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Timestamp*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Timestamp*) (soff+(sizeof(edm::Timestamp)*i)))->~G__TedmcLcLTimestamp();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Timestamp*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Timestamp*) (soff))->~G__TedmcLcLTimestamp();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_524_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Timestamp* dest = (edm::Timestamp*) G__getstructoffset();
   const edm::Timestamp& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::IndexIntoFile */
// automatic default constructor
static int G__MiniFWLiteDict_525_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile[n];
     } else {
       p = new((void*) gvp) edm::IndexIntoFile[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile;
     } else {
       p = new((void*) gvp) edm::IndexIntoFile;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_525_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::IndexIntoFile* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::IndexIntoFile(*(edm::IndexIntoFile*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::IndexIntoFile G__TedmcLcLIndexIntoFile;
static int G__MiniFWLiteDict_525_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::IndexIntoFile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::IndexIntoFile*) (soff+(sizeof(edm::IndexIntoFile)*i)))->~G__TedmcLcLIndexIntoFile();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::IndexIntoFile*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::IndexIntoFile*) (soff))->~G__TedmcLcLIndexIntoFile();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_525_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile* dest = (edm::IndexIntoFile*) G__getstructoffset();
   const edm::IndexIntoFile& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::IndexIntoFile::Transients */
// automatic default constructor
static int G__MiniFWLiteDict_526_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile::Transients *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile::Transients[n];
     } else {
       p = new((void*) gvp) edm::IndexIntoFile::Transients[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile::Transients;
     } else {
       p = new((void*) gvp) edm::IndexIntoFile::Transients;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_526_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::IndexIntoFile::Transients* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::IndexIntoFile::Transients(*(edm::IndexIntoFile::Transients*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::IndexIntoFile::Transients G__TedmcLcLIndexIntoFilecLcLTransients;
static int G__MiniFWLiteDict_526_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::IndexIntoFile::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::IndexIntoFile::Transients*) (soff+(sizeof(edm::IndexIntoFile::Transients)*i)))->~G__TedmcLcLIndexIntoFilecLcLTransients();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::IndexIntoFile::Transients*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::IndexIntoFile::Transients*) (soff))->~G__TedmcLcLIndexIntoFilecLcLTransients();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_526_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile::Transients* dest = (edm::IndexIntoFile::Transients*) G__getstructoffset();
   const edm::IndexIntoFile::Transients& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::IndexIntoFile::RunOrLumiEntry */
// automatic default constructor
static int G__MiniFWLiteDict_527_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile::RunOrLumiEntry *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile::RunOrLumiEntry[n];
     } else {
       p = new((void*) gvp) edm::IndexIntoFile::RunOrLumiEntry[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::IndexIntoFile::RunOrLumiEntry;
     } else {
       p = new((void*) gvp) edm::IndexIntoFile::RunOrLumiEntry;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_527_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::IndexIntoFile::RunOrLumiEntry* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::IndexIntoFile::RunOrLumiEntry(*(edm::IndexIntoFile::RunOrLumiEntry*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::IndexIntoFile::RunOrLumiEntry G__TedmcLcLIndexIntoFilecLcLRunOrLumiEntry;
static int G__MiniFWLiteDict_527_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::IndexIntoFile::RunOrLumiEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::IndexIntoFile::RunOrLumiEntry*) (soff+(sizeof(edm::IndexIntoFile::RunOrLumiEntry)*i)))->~G__TedmcLcLIndexIntoFilecLcLRunOrLumiEntry();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::IndexIntoFile::RunOrLumiEntry*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::IndexIntoFile::RunOrLumiEntry*) (soff))->~G__TedmcLcLIndexIntoFilecLcLRunOrLumiEntry();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_527_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::IndexIntoFile::RunOrLumiEntry* dest = (edm::IndexIntoFile::RunOrLumiEntry*) G__getstructoffset();
   const edm::IndexIntoFile::RunOrLumiEntry& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::PxPyPzE4D<float> */
static int G__MiniFWLiteDict_528_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PxPyPzE4D<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::PxPyPzE4D<float>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::PxPyPzE4D<float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::PxPyPzE4D<float>;
     } else {
       p = new((void*) gvp) ROOT::Math::PxPyPzE4D<float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PxPyPzE4D<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::PxPyPzE4D<float>(
(ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[2]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::PxPyPzE4D<float>(
(ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[2]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PxPyPzE4D<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::PxPyPzE4D<float>(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) ROOT::Math::PxPyPzE4D<float>(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PxPyPzE4D<float>& obj = ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->operator=(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetCoordinates((ROOT::Math::PxPyPzE4D<float>::Scalar*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->GetCoordinates((ROOT::Math::PxPyPzE4D<float>::Scalar*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetCoordinates((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[2]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->GetCoordinates(*(ROOT::Math::PxPyPzE4D<float>::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::PxPyPzE4D<float>::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::PxPyPzE4D<float>::Scalar*) G__Floatref(&libp->para[2]), *(ROOT::Math::PxPyPzE4D<float>::Scalar*) G__Floatref(&libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Px());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Py());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Pz());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->E());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->T());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->P2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->P());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->R());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->M2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Mag2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->M());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Mag());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Pt2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Perp2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Pt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Perp());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Rho());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Mt2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Mt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Et2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Et());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Phi());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Theta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Eta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPx((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPy((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPz((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetE((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPxPyPzE((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[2]), (ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Negate();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->Scale(*(ROOT::Math::PxPyPzE4D<float>::Scalar*) G__Floatref(&libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->operator==(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->operator!=(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->x());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->t());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPt((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetEta((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetPhi((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_528_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((ROOT::Math::PxPyPzE4D<float>*) G__getstructoffset())->SetM((ROOT::Math::PxPyPzE4D<float>::Scalar) G__double(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::PxPyPzE4D<float> G__TROOTcLcLMathcLcLPxPyPzE4DlEfloatgR;
static int G__MiniFWLiteDict_528_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::PxPyPzE4D<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::PxPyPzE4D<float>*) (soff+(sizeof(ROOT::Math::PxPyPzE4D<float>)*i)))->~G__TROOTcLcLMathcLcLPxPyPzE4DlEfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::PxPyPzE4D<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::PxPyPzE4D<float>*) (soff))->~G__TROOTcLcLMathcLcLPxPyPzE4DlEfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > */
static int G__MiniFWLiteDict_529_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >[n];
     } else {
       p = new((void*) gvp) ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >;
     } else {
       p = new((void*) gvp) ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 4
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(
*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[2]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[3]));
   } else {
     p = new((void*) gvp) ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(
*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[2]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[3]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PxPyPzE4D<float>& obj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Coordinates();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetCoordinates((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetCoordinates((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[1])
, (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[2]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->GetCoordinates(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[2]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[3]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->GetCoordinates((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetXYZT((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[1])
, (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[2]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPxPyPzE((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[1])
, (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[2]), (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[3]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator==(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator!=(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Px());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Py());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Pz());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->E());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->T());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->M2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->M());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->R());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->P());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->P2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Perp2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Pt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Rho());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Mt2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Mt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Et2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Et());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Phi());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Theta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Eta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* pobj;
         const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Vect();
         pobj = new ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator*=((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator/=((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* pobj;
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator*(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[0]));
         pobj = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* pobj;
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator/(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar*) G__Floatref(&libp->para[0]));
         pobj = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* pobj;
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator-();
         pobj = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* pobj;
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->operator+();
         pobj = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Rapidity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->ColinearRapidity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->isTimelike());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   switch (libp->paran) {
   case 1:
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->isLightlike((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0])));
      break;
   case 0:
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->isLightlike());
      break;
   }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_46(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->isSpacelike());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_47(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::BetaVector* pobj;
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::BetaVector xobj = ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->BoostToCM();
         pobj = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::BetaVector(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_48(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Beta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_49(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->Gamma());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_50(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->x());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_51(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_52(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_53(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->t());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_54(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->px());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_55(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->py());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_56(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->pz());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_57(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->e());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_58(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->r());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_59(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->theta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_60(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->phi());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_61(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->rho());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_62(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->eta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_63(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->pt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_64(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->perp2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_65(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mag2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_66(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mag());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_67(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mt());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_68(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mt2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_69(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->energy());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_70(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mass());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_71(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->mass2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_72(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetE((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_73(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetEta((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_74(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetM((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_75(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPhi((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_76(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPt((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_77(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPx((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_78(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPy((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_529_0_79(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset())->SetPz((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_529_0_80(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > G__TROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR;
static int G__MiniFWLiteDict_529_0_81(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) (soff+(sizeof(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >)*i)))->~G__TROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) (soff))->~G__TROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_529_0_82(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >* dest = (ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__getstructoffset();
   *dest = *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[0].ref;
   const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> */
static int G__MiniFWLiteDict_532_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>[n];
     } else {
       p = new((void*) gvp) ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>;
     } else {
       p = new((void*) gvp) ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 3
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(
*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[2]));
   } else {
     p = new((void*) gvp) ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(
*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[2]));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::Cartesian3D<float>& obj = ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Coordinates();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetCoordinates((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetCoordinates((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]), (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->GetCoordinates(*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[0]), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[1])
, *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__Floatref(&libp->para[2]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->GetCoordinates((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar*) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetXYZ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]), (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[1])
, (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[2]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator==(*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator!=(*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->X());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->R());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Theta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Phi());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Eta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Rho());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Mag2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->Perp2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetX((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetY((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetZ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetR((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetTheta((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetPhi((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetRho((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->SetEta((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator*=((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator/=((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* pobj;
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> xobj = ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator*((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         pobj = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* pobj;
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> xobj = ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->operator/((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar) G__double(libp->para[0]));
         pobj = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_33(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->x());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_34(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->y());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_35(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->z());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_36(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->r());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_37(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->theta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_38(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->phi());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_39(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->eta());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_40(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->rho());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_41(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->mag2());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_532_0_42(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letdouble(result7, 102, (double) ((const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset())->perp2());
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_532_0_43(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>(*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> G__TROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR;
static int G__MiniFWLiteDict_532_0_44(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) (soff+(sizeof(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>)*i)))->~G__TROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) (soff))->~G__TROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_532_0_45(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>* dest = (ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__getstructoffset();
   *dest = *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[0].ref;
   const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > */
static int G__MiniFWLiteDict_534_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reference obj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->at((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_reference obj = ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->at((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator* pobj;
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator xobj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->begin();
         pobj = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator* pobj;
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator xobj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->end();
         pobj = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator* pobj;
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator xobj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->rbegin();
         pobj = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator* pobj;
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator xobj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->rend();
         pobj = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->resize((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->resize((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]), *((ROOT::Math::PxPyPzE4D<float>*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reference obj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_reference obj = ((const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >[n];
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >;
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]), *(ROOT::Math::PxPyPzE4D<float>*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]), *(ROOT::Math::PxPyPzE4D<float>*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >(*(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >(*(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >& obj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->operator=(*(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->reserve((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PxPyPzE4D<float>& obj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PxPyPzE4D<float>& obj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->push_back(*(ROOT::Math::PxPyPzE4D<float>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->swap(*(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator* pobj;
         vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator xobj = ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[0])), *(ROOT::Math::PxPyPzE4D<float>*) libp->para[1].ref);
         pobj = new vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[1]))
, *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[0])), (vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type) G__int(libp->para[1])
, *(ROOT::Math::PxPyPzE4D<float>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_534_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > G__TvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR;
static int G__MiniFWLiteDict_534_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) (soff+(sizeof(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >)*i)))->~G__TvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) (soff))->~G__TvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > */
static int G__MiniFWLiteDict_538_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reference obj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->at((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_reference obj = ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->at((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator* pobj;
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator xobj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->begin();
         pobj = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator* pobj;
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator xobj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->end();
         pobj = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator* pobj;
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator xobj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->rbegin();
         pobj = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator* pobj;
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator xobj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->rend();
         pobj = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->resize((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->resize((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]), *((ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reference obj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_reference obj = ((const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >[n];
     } else {
       p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >;
     } else {
       p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >(*(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >(*(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >& obj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->operator=(*(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->reserve((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >& obj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->push_back(*(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->swap(*(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator* pobj;
         vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator xobj = ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[0])), *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[1].ref);
         pobj = new vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[1]))
, *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[0])), (vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type) G__int(libp->para[1])
, *(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_538_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > G__TvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_538_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) (soff+(sizeof(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >)*i)))->~G__TvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) (soff))->~G__TvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > */
static int G__MiniFWLiteDict_542_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reference obj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->at((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_reference obj = ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->at((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator* pobj;
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator xobj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->begin();
         pobj = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator* pobj;
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator xobj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->end();
         pobj = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator* pobj;
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator xobj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->rbegin();
         pobj = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator* pobj;
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator xobj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->rend();
         pobj = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->resize((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->resize((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]), *((ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reference obj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_reference obj = ((const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->operator[]((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >[n];
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >;
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >(*(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >(*(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >& obj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->operator=(*(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->reserve((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>& obj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->push_back(*(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->swap(*(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator* pobj;
         vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator xobj = ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[0])), *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[1].ref);
         pobj = new vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[1]))
, *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->insert(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[0])), (vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type) G__int(libp->para[1])
, *(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->erase(*((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[0])), *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_542_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > G__TvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR;
static int G__MiniFWLiteDict_542_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) (soff+(sizeof(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >)*i)))->~G__TvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) (soff))->~G__TvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > */
static int G__MiniFWLiteDict_546_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reference obj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_reference obj = ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->begin();
         pobj = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->end();
         pobj = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->rbegin();
         pobj = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->rend();
         pobj = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]), *((vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reference obj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_reference obj = ((const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >[n];
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >;
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >(*(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >(*(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >& obj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->operator=(*(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->reserve((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >& obj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >& obj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->push_back(*(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->swap(*(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[0])), *(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[1].ref);
         pobj = new vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[1]))
, *((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[0])), (vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type) G__int(libp->para[1])
, *(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_546_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > G__TvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_546_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) (soff+(sizeof(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >)*i)))->~G__TvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*) (soff))->~G__TvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > */
static int G__MiniFWLiteDict_550_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reference obj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_reference obj = ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator* pobj;
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator xobj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->begin();
         pobj = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator* pobj;
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator xobj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->end();
         pobj = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->rbegin();
         pobj = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->rend();
         pobj = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]), *((vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reference obj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_reference obj = ((const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >[n];
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >;
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >(*(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >(*(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >& obj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->operator=(*(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->reserve((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >& obj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >& obj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->push_back(*(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->swap(*(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator* pobj;
         vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator xobj = ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[0])), *(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[1].ref);
         pobj = new vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[1]))
, *((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[0])), (vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type) G__int(libp->para[1])
, *(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_550_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > G__TvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_550_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) (soff+(sizeof(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >)*i)))->~G__TvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*) (soff))->~G__TvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > */
static int G__MiniFWLiteDict_554_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reference obj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_reference obj = ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->at((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->begin();
         pobj = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->end();
         pobj = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->rbegin();
         pobj = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator* pobj;
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator xobj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->rend();
         pobj = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->resize((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]), *((vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->capacity());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reference obj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_reference obj = ((const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->operator[]((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >[n];
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >;
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   switch (libp->paran) {
   case 2:
     //m: 2
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[1].ref);
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]), *(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[1].ref);
     }
     break;
   case 1:
     //m: 1
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
     } else {
       p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
     }
     break;
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >(*(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >(*(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >& obj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->operator=(*(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->reserve((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[0]));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >& obj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->front();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >& obj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->back();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->push_back(*(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->swap(*(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator* pobj;
         vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator xobj = ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[0])), *(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[1].ref);
         pobj = new vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[1]))
, *((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator*) G__int(libp->para[2])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->insert(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[0])), (vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type) G__int(libp->para[1])
, *(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*) libp->para[2].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_28(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->pop_back();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_29(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_30(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->erase(*((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[0])), *((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_554_0_31(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > G__TvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_554_0_32(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) (soff+(sizeof(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >)*i)))->~G__TvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*) (soff))->~G__TvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<TString> */
static int G__MiniFWLiteDict_557_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<TString>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<TString>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<TString>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<TString>;
     } else {
       p = new((void*) gvp) edm::Wrapper<TString>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_557_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<TString>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_557_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<TString>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_557_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<TString>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_557_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<TString>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<TString> G__TedmcLcLWrapperlETStringgR;
static int G__MiniFWLiteDict_557_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<TString>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<TString>*) (soff+(sizeof(edm::Wrapper<TString>)*i)))->~G__TedmcLcLWrapperlETStringgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<TString>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<TString>*) (soff))->~G__TedmcLcLWrapperlETStringgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<double> */
static int G__MiniFWLiteDict_558_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<double>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<double>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<double>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<double>;
     } else {
       p = new((void*) gvp) edm::Wrapper<double>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_558_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const edm::Wrapper<double>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_558_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 68, (long) ((const edm::Wrapper<double>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_558_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<double>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_558_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<double>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<double> G__TedmcLcLWrapperlEdoublegR;
static int G__MiniFWLiteDict_558_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<double>*) (soff+(sizeof(edm::Wrapper<double>)*i)))->~G__TedmcLcLWrapperlEdoublegR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<double>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<double>*) (soff))->~G__TedmcLcLWrapperlEdoublegR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<float> */
static int G__MiniFWLiteDict_559_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<float>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<float>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<float>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<float>;
     } else {
       p = new((void*) gvp) edm::Wrapper<float>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_559_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((const edm::Wrapper<float>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_559_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 70, (long) ((const edm::Wrapper<float>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_559_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<float>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_559_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<float>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<float> G__TedmcLcLWrapperlEfloatgR;
static int G__MiniFWLiteDict_559_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<float>*) (soff+(sizeof(edm::Wrapper<float>)*i)))->~G__TedmcLcLWrapperlEfloatgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<float>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<float>*) (soff))->~G__TedmcLcLWrapperlEfloatgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<int> */
static int G__MiniFWLiteDict_560_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<int>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<int>;
     } else {
       p = new((void*) gvp) edm::Wrapper<int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_560_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const edm::Wrapper<int>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_560_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 73, (long) ((const edm::Wrapper<int>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_560_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<int>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_560_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<int>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<int> G__TedmcLcLWrapperlEintgR;
static int G__MiniFWLiteDict_560_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<int>*) (soff+(sizeof(edm::Wrapper<int>)*i)))->~G__TedmcLcLWrapperlEintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<int>*) (soff))->~G__TedmcLcLWrapperlEintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<unsigned int> */
static int G__MiniFWLiteDict_561_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<unsigned int>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<unsigned int>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<unsigned int>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<unsigned int>;
     } else {
       p = new((void*) gvp) edm::Wrapper<unsigned int>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_561_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 72, (long) ((const edm::Wrapper<unsigned int>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_561_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 72, (long) ((const edm::Wrapper<unsigned int>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_561_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<unsigned int>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_561_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<unsigned int>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<unsigned int> G__TedmcLcLWrapperlEunsignedsPintgR;
static int G__MiniFWLiteDict_561_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<unsigned int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<unsigned int>*) (soff+(sizeof(edm::Wrapper<unsigned int>)*i)))->~G__TedmcLcLWrapperlEunsignedsPintgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<unsigned int>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<unsigned int>*) (soff))->~G__TedmcLcLWrapperlEunsignedsPintgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > */
static int G__MiniFWLiteDict_566_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_566_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_566_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_566_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_566_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR;
static int G__MiniFWLiteDict_566_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) (soff+(sizeof(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >)*i)))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*) (soff))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > */
static int G__MiniFWLiteDict_567_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_567_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_567_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_567_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_567_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR;
static int G__MiniFWLiteDict_567_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) (soff+(sizeof(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >)*i)))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*) (soff))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > */
static int G__MiniFWLiteDict_569_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >;
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_569_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_569_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_569_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_569_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR;
static int G__MiniFWLiteDict_569_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) (soff+(sizeof(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >)*i)))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*) (soff))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > */
static int G__MiniFWLiteDict_570_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >;
     } else {
       p = new((void*) gvp) edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_570_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_570_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_570_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_570_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR;
static int G__MiniFWLiteDict_570_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) (soff+(sizeof(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >)*i)))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*) (soff))->~G__TedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<TString,allocator<TString> > > */
static int G__MiniFWLiteDict_575_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<TString,allocator<TString> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<TString,allocator<TString> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<TString,allocator<TString> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<TString,allocator<TString> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<TString,allocator<TString> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_575_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<TString,allocator<TString> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_575_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<TString,allocator<TString> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_575_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<TString,allocator<TString> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_575_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<TString,allocator<TString> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<TString,allocator<TString> > > G__TedmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR;
static int G__MiniFWLiteDict_575_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<TString,allocator<TString> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<TString,allocator<TString> > >*) (soff+(sizeof(edm::Wrapper<vector<TString,allocator<TString> > >)*i)))->~G__TedmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<TString,allocator<TString> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<TString,allocator<TString> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<double,allocator<double> > > */
static int G__MiniFWLiteDict_576_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<double,allocator<double> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<double,allocator<double> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<double,allocator<double> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<double,allocator<double> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<double,allocator<double> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_576_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<double,allocator<double> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_576_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<double,allocator<double> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_576_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<double,allocator<double> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_576_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<double,allocator<double> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<double,allocator<double> > > G__TedmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR;
static int G__MiniFWLiteDict_576_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<double,allocator<double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<double,allocator<double> > >*) (soff+(sizeof(edm::Wrapper<vector<double,allocator<double> > >)*i)))->~G__TedmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<double,allocator<double> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<double,allocator<double> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<float,allocator<float> > > */
static int G__MiniFWLiteDict_577_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<float,allocator<float> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<float,allocator<float> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<float,allocator<float> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<float,allocator<float> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<float,allocator<float> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_577_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<float,allocator<float> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_577_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<float,allocator<float> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_577_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<float,allocator<float> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_577_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<float,allocator<float> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<float,allocator<float> > > G__TedmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR;
static int G__MiniFWLiteDict_577_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<float,allocator<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<float,allocator<float> > >*) (soff+(sizeof(edm::Wrapper<vector<float,allocator<float> > >)*i)))->~G__TedmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<float,allocator<float> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<float,allocator<float> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<int,allocator<int> > > */
static int G__MiniFWLiteDict_581_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<int,allocator<int> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<int,allocator<int> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<int,allocator<int> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<int,allocator<int> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<int,allocator<int> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_581_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<int,allocator<int> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_581_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<int,allocator<int> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_581_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<int,allocator<int> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_581_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<int,allocator<int> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<int,allocator<int> > > G__TedmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR;
static int G__MiniFWLiteDict_581_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<int,allocator<int> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<int,allocator<int> > >*) (soff+(sizeof(edm::Wrapper<vector<int,allocator<int> > >)*i)))->~G__TedmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<int,allocator<int> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<int,allocator<int> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > */
static int G__MiniFWLiteDict_582_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_582_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_582_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_582_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_582_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > G__TedmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR;
static int G__MiniFWLiteDict_582_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) (soff+(sizeof(edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >)*i)))->~G__TedmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > */
static int G__MiniFWLiteDict_587_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_587_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_587_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_587_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_587_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_587_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) (soff+(sizeof(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > */
static int G__MiniFWLiteDict_588_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_588_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_588_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_588_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_588_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_588_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) (soff+(sizeof(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
static int G__MiniFWLiteDict_593_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_593_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_593_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_593_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_593_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_593_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) (soff+(sizeof(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
static int G__MiniFWLiteDict_594_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_594_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_594_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_594_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_594_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_594_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) (soff+(sizeof(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > */
static int G__MiniFWLiteDict_599_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_599_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_599_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_599_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_599_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > G__TedmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_599_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > */
static int G__MiniFWLiteDict_604_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_604_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_604_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_604_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_604_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > G__TedmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_604_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > */
static int G__MiniFWLiteDict_609_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_609_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_609_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_609_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_609_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > G__TedmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_609_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > */
static int G__MiniFWLiteDict_614_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_614_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_614_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_614_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_614_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > G__TedmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_614_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > */
static int G__MiniFWLiteDict_619_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_619_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_619_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_619_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_619_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > G__TedmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_619_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > */
static int G__MiniFWLiteDict_624_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_624_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_624_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_624_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_624_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_624_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > */
static int G__MiniFWLiteDict_625_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_625_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_625_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_625_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_625_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_625_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
static int G__MiniFWLiteDict_630_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_630_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_630_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_630_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_630_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_630_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
static int G__MiniFWLiteDict_631_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_631_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_631_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_631_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_631_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_631_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) (soff+(sizeof(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >)*i)))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<0> */
// automatic default constructor
static int G__MiniFWLiteDict_632_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<0> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<0>[n];
     } else {
       p = new((void*) gvp) edm::Hash<0>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<0>;
     } else {
       p = new((void*) gvp) edm::Hash<0>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_632_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<0>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<0>(*(edm::Hash<0>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<0> G__TedmcLcLHashlE0gR;
static int G__MiniFWLiteDict_632_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<0>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<0>*) (soff+(sizeof(edm::Hash<0>)*i)))->~G__TedmcLcLHashlE0gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<0>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<0>*) (soff))->~G__TedmcLcLHashlE0gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_632_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<0>* dest = (edm::Hash<0>*) G__getstructoffset();
   const edm::Hash<0>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<1> */
// automatic default constructor
static int G__MiniFWLiteDict_633_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<1> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<1>[n];
     } else {
       p = new((void*) gvp) edm::Hash<1>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<1>;
     } else {
       p = new((void*) gvp) edm::Hash<1>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_633_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<1>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<1>(*(edm::Hash<1>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<1> G__TedmcLcLHashlE1gR;
static int G__MiniFWLiteDict_633_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<1>*) (soff+(sizeof(edm::Hash<1>)*i)))->~G__TedmcLcLHashlE1gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<1>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<1>*) (soff))->~G__TedmcLcLHashlE1gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_633_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<1>* dest = (edm::Hash<1>*) G__getstructoffset();
   const edm::Hash<1>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<2> */
// automatic default constructor
static int G__MiniFWLiteDict_634_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<2> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<2>[n];
     } else {
       p = new((void*) gvp) edm::Hash<2>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<2>;
     } else {
       p = new((void*) gvp) edm::Hash<2>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_634_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<2>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<2>(*(edm::Hash<2>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<2> G__TedmcLcLHashlE2gR;
static int G__MiniFWLiteDict_634_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<2>*) (soff+(sizeof(edm::Hash<2>)*i)))->~G__TedmcLcLHashlE2gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<2>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<2>*) (soff))->~G__TedmcLcLHashlE2gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_634_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<2>* dest = (edm::Hash<2>*) G__getstructoffset();
   const edm::Hash<2>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<3> */
// automatic default constructor
static int G__MiniFWLiteDict_635_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<3> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<3>[n];
     } else {
       p = new((void*) gvp) edm::Hash<3>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<3>;
     } else {
       p = new((void*) gvp) edm::Hash<3>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_635_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<3>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<3>(*(edm::Hash<3>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<3> G__TedmcLcLHashlE3gR;
static int G__MiniFWLiteDict_635_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<3>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<3>*) (soff+(sizeof(edm::Hash<3>)*i)))->~G__TedmcLcLHashlE3gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<3>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<3>*) (soff))->~G__TedmcLcLHashlE3gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_635_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<3>* dest = (edm::Hash<3>*) G__getstructoffset();
   const edm::Hash<3>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<4> */
// automatic default constructor
static int G__MiniFWLiteDict_636_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<4> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<4>[n];
     } else {
       p = new((void*) gvp) edm::Hash<4>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<4>;
     } else {
       p = new((void*) gvp) edm::Hash<4>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_636_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<4>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<4>(*(edm::Hash<4>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<4> G__TedmcLcLHashlE4gR;
static int G__MiniFWLiteDict_636_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<4>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<4>*) (soff+(sizeof(edm::Hash<4>)*i)))->~G__TedmcLcLHashlE4gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<4>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<4>*) (soff))->~G__TedmcLcLHashlE4gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_636_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<4>* dest = (edm::Hash<4>*) G__getstructoffset();
   const edm::Hash<4>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Hash<5> */
// automatic default constructor
static int G__MiniFWLiteDict_637_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<5> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<5>[n];
     } else {
       p = new((void*) gvp) edm::Hash<5>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Hash<5>;
     } else {
       p = new((void*) gvp) edm::Hash<5>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_637_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Hash<5>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Hash<5>(*(edm::Hash<5>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Hash<5> G__TedmcLcLHashlE5gR;
static int G__MiniFWLiteDict_637_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Hash<5>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Hash<5>*) (soff+(sizeof(edm::Hash<5>)*i)))->~G__TedmcLcLHashlE5gR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Hash<5>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Hash<5>*) (soff))->~G__TedmcLcLHashlE5gR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_637_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Hash<5>* dest = (edm::Hash<5>*) G__getstructoffset();
   const edm::Hash<5>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::BranchDescription::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_638_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::BranchDescription::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::BranchDescription::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::BranchDescription::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::BranchDescription::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::BranchDescription::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_638_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::BranchDescription::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::BranchDescription::Transients>(*(edm::Transient<edm::BranchDescription::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::BranchDescription::Transients> G__TedmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR;
static int G__MiniFWLiteDict_638_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::BranchDescription::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::BranchDescription::Transients>*) (soff+(sizeof(edm::Transient<edm::BranchDescription::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::BranchDescription::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::BranchDescription::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_638_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::BranchDescription::Transients>* dest = (edm::Transient<edm::BranchDescription::Transients>*) G__getstructoffset();
   const edm::Transient<edm::BranchDescription::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::EventEntryDescription::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_639_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::EventEntryDescription::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::EventEntryDescription::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::EventEntryDescription::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::EventEntryDescription::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::EventEntryDescription::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_639_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::EventEntryDescription::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::EventEntryDescription::Transients>(*(edm::Transient<edm::EventEntryDescription::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::EventEntryDescription::Transients> G__TedmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR;
static int G__MiniFWLiteDict_639_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::EventEntryDescription::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::EventEntryDescription::Transients>*) (soff+(sizeof(edm::Transient<edm::EventEntryDescription::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::EventEntryDescription::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::EventEntryDescription::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_639_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::EventEntryDescription::Transients>* dest = (edm::Transient<edm::EventEntryDescription::Transients>*) G__getstructoffset();
   const edm::Transient<edm::EventEntryDescription::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::EventEntryInfo::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_640_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::EventEntryInfo::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::EventEntryInfo::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::EventEntryInfo::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::EventEntryInfo::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::EventEntryInfo::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_640_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::EventEntryInfo::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::EventEntryInfo::Transients>(*(edm::Transient<edm::EventEntryInfo::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::EventEntryInfo::Transients> G__TedmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR;
static int G__MiniFWLiteDict_640_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::EventEntryInfo::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::EventEntryInfo::Transients>*) (soff+(sizeof(edm::Transient<edm::EventEntryInfo::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::EventEntryInfo::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::EventEntryInfo::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_640_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::EventEntryInfo::Transients>* dest = (edm::Transient<edm::EventEntryInfo::Transients>*) G__getstructoffset();
   const edm::Transient<edm::EventEntryInfo::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::FileIndex::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_641_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::FileIndex::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::FileIndex::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::FileIndex::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::FileIndex::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::FileIndex::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_641_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::FileIndex::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::FileIndex::Transients>(*(edm::Transient<edm::FileIndex::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::FileIndex::Transients> G__TedmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR;
static int G__MiniFWLiteDict_641_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::FileIndex::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::FileIndex::Transients>*) (soff+(sizeof(edm::Transient<edm::FileIndex::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::FileIndex::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::FileIndex::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_641_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::FileIndex::Transients>* dest = (edm::Transient<edm::FileIndex::Transients>*) G__getstructoffset();
   const edm::Transient<edm::FileIndex::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::Parentage::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_642_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::Parentage::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::Parentage::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::Parentage::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::Parentage::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::Parentage::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_642_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::Parentage::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::Parentage::Transients>(*(edm::Transient<edm::Parentage::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::Parentage::Transients> G__TedmcLcLTransientlEedmcLcLParentagecLcLTransientsgR;
static int G__MiniFWLiteDict_642_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::Parentage::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::Parentage::Transients>*) (soff+(sizeof(edm::Transient<edm::Parentage::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLParentagecLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::Parentage::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::Parentage::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLParentagecLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_642_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::Parentage::Transients>* dest = (edm::Transient<edm::Parentage::Transients>*) G__getstructoffset();
   const edm::Transient<edm::Parentage::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::ProcessConfiguration::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_643_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProcessConfiguration::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProcessConfiguration::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProcessConfiguration::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProcessConfiguration::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProcessConfiguration::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_643_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::ProcessConfiguration::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::ProcessConfiguration::Transients>(*(edm::Transient<edm::ProcessConfiguration::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::ProcessConfiguration::Transients> G__TedmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR;
static int G__MiniFWLiteDict_643_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::ProcessConfiguration::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::ProcessConfiguration::Transients>*) (soff+(sizeof(edm::Transient<edm::ProcessConfiguration::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::ProcessConfiguration::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::ProcessConfiguration::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_643_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProcessConfiguration::Transients>* dest = (edm::Transient<edm::ProcessConfiguration::Transients>*) G__getstructoffset();
   const edm::Transient<edm::ProcessConfiguration::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::ProcessHistory::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_644_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProcessHistory::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProcessHistory::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProcessHistory::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProcessHistory::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProcessHistory::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_644_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::ProcessHistory::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::ProcessHistory::Transients>(*(edm::Transient<edm::ProcessHistory::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::ProcessHistory::Transients> G__TedmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR;
static int G__MiniFWLiteDict_644_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::ProcessHistory::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::ProcessHistory::Transients>*) (soff+(sizeof(edm::Transient<edm::ProcessHistory::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::ProcessHistory::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::ProcessHistory::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_644_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProcessHistory::Transients>* dest = (edm::Transient<edm::ProcessHistory::Transients>*) G__getstructoffset();
   const edm::Transient<edm::ProcessHistory::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::ProductProvenance::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_645_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProductProvenance::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProductProvenance::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProductProvenance::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProductProvenance::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProductProvenance::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_645_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::ProductProvenance::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::ProductProvenance::Transients>(*(edm::Transient<edm::ProductProvenance::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::ProductProvenance::Transients> G__TedmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR;
static int G__MiniFWLiteDict_645_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::ProductProvenance::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::ProductProvenance::Transients>*) (soff+(sizeof(edm::Transient<edm::ProductProvenance::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::ProductProvenance::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::ProductProvenance::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_645_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProductProvenance::Transients>* dest = (edm::Transient<edm::ProductProvenance::Transients>*) G__getstructoffset();
   const edm::Transient<edm::ProductProvenance::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::ProductRegistry::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_646_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProductRegistry::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProductRegistry::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProductRegistry::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::ProductRegistry::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::ProductRegistry::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_646_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::ProductRegistry::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::ProductRegistry::Transients>(*(edm::Transient<edm::ProductRegistry::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::ProductRegistry::Transients> G__TedmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR;
static int G__MiniFWLiteDict_646_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::ProductRegistry::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::ProductRegistry::Transients>*) (soff+(sizeof(edm::Transient<edm::ProductRegistry::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::ProductRegistry::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::ProductRegistry::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_646_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::ProductRegistry::Transients>* dest = (edm::Transient<edm::ProductRegistry::Transients>*) G__getstructoffset();
   const edm::Transient<edm::ProductRegistry::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Transient<edm::IndexIntoFile::Transients> */
// automatic default constructor
static int G__MiniFWLiteDict_647_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::IndexIntoFile::Transients> *p;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::IndexIntoFile::Transients>[n];
     } else {
       p = new((void*) gvp) edm::Transient<edm::IndexIntoFile::Transients>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Transient<edm::IndexIntoFile::Transients>;
     } else {
       p = new((void*) gvp) edm::Transient<edm::IndexIntoFile::Transients>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_647_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   edm::Transient<edm::IndexIntoFile::Transients>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new edm::Transient<edm::IndexIntoFile::Transients>(*(edm::Transient<edm::IndexIntoFile::Transients>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Transient<edm::IndexIntoFile::Transients> G__TedmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR;
static int G__MiniFWLiteDict_647_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Transient<edm::IndexIntoFile::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Transient<edm::IndexIntoFile::Transients>*) (soff+(sizeof(edm::Transient<edm::IndexIntoFile::Transients>)*i)))->~G__TedmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Transient<edm::IndexIntoFile::Transients>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Transient<edm::IndexIntoFile::Transients>*) (soff))->~G__TedmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic assignment operator
static int G__MiniFWLiteDict_647_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Transient<edm::IndexIntoFile::Transients>* dest = (edm::Transient<edm::IndexIntoFile::Transients>*) G__getstructoffset();
   const edm::Transient<edm::IndexIntoFile::Transients>& obj = *dest;
   result7->ref = (long) (&obj);
   result7->obj.i = (long) (&obj);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<edm::BranchKey,edm::BranchDescription> */
static int G__MiniFWLiteDict_648_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::BranchKey,edm::BranchDescription>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::BranchKey,edm::BranchDescription>[n];
     } else {
       p = new((void*) gvp) pair<edm::BranchKey,edm::BranchDescription>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::BranchKey,edm::BranchDescription>;
     } else {
       p = new((void*) gvp) pair<edm::BranchKey,edm::BranchDescription>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_648_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::BranchKey,edm::BranchDescription>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<edm::BranchKey,edm::BranchDescription>(*(edm::BranchKey*) libp->para[0].ref, *(edm::BranchDescription*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) pair<edm::BranchKey,edm::BranchDescription>(*(edm::BranchKey*) libp->para[0].ref, *(edm::BranchDescription*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_648_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<edm::BranchKey,edm::BranchDescription>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<edm::BranchKey,edm::BranchDescription>(*(pair<edm::BranchKey,edm::BranchDescription>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<edm::BranchKey,edm::BranchDescription> G__TpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR;
static int G__MiniFWLiteDict_648_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<edm::BranchKey,edm::BranchDescription>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<edm::BranchKey,edm::BranchDescription>*) (soff+(sizeof(pair<edm::BranchKey,edm::BranchDescription>)*i)))->~G__TpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<edm::BranchKey,edm::BranchDescription>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<edm::BranchKey,edm::BranchDescription>*) (soff))->~G__TpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<edm::Hash<1>,edm::ParameterSetBlob> */
static int G__MiniFWLiteDict_649_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::Hash<1>,edm::ParameterSetBlob>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::Hash<1>,edm::ParameterSetBlob>[n];
     } else {
       p = new((void*) gvp) pair<edm::Hash<1>,edm::ParameterSetBlob>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::Hash<1>,edm::ParameterSetBlob>;
     } else {
       p = new((void*) gvp) pair<edm::Hash<1>,edm::ParameterSetBlob>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_649_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::Hash<1>,edm::ParameterSetBlob>* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<edm::Hash<1>,edm::ParameterSetBlob>(*(edm::Hash<1>*) libp->para[0].ref, *(edm::ParameterSetBlob*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) pair<edm::Hash<1>,edm::ParameterSetBlob>(*(edm::Hash<1>*) libp->para[0].ref, *(edm::ParameterSetBlob*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_649_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<edm::Hash<1>,edm::ParameterSetBlob>* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<edm::Hash<1>,edm::ParameterSetBlob>(*(pair<edm::Hash<1>,edm::ParameterSetBlob>*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<edm::Hash<1>,edm::ParameterSetBlob> G__TpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR;
static int G__MiniFWLiteDict_649_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<edm::Hash<1>,edm::ParameterSetBlob>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<edm::Hash<1>,edm::ParameterSetBlob>*) (soff+(sizeof(pair<edm::Hash<1>,edm::ParameterSetBlob>)*i)))->~G__TpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<edm::Hash<1>,edm::ParameterSetBlob>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<edm::Hash<1>,edm::ParameterSetBlob>*) (soff))->~G__TpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<bool> */
static int G__MiniFWLiteDict_650_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<bool>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<bool>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<bool>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<bool>;
     } else {
       p = new((void*) gvp) edm::Wrapper<bool>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_650_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 71, (long) ((const edm::Wrapper<bool>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_650_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 71, (long) ((const edm::Wrapper<bool>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_650_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<bool>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_650_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<bool>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<bool> G__TedmcLcLWrapperlEboolgR;
static int G__MiniFWLiteDict_650_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<bool>*) (soff+(sizeof(edm::Wrapper<bool>)*i)))->~G__TedmcLcLWrapperlEboolgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<bool>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<bool>*) (soff))->~G__TedmcLcLWrapperlEboolgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<vector<bool,allocator<bool> > > */
static int G__MiniFWLiteDict_651_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<vector<bool,allocator<bool> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<bool,allocator<bool> > >[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<bool,allocator<bool> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<vector<bool,allocator<bool> > >;
     } else {
       p = new((void*) gvp) edm::Wrapper<vector<bool,allocator<bool> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_651_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<bool,allocator<bool> > >*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_651_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<vector<bool,allocator<bool> > >*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_651_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<bool,allocator<bool> > >::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_651_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<vector<bool,allocator<bool> > >::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<vector<bool,allocator<bool> > > G__TedmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR;
static int G__MiniFWLiteDict_651_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<vector<bool,allocator<bool> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<vector<bool,allocator<bool> > >*) (soff+(sizeof(edm::Wrapper<vector<bool,allocator<bool> > >)*i)))->~G__TedmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<vector<bool,allocator<bool> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<vector<bool,allocator<bool> > >*) (soff))->~G__TedmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<unsigned long long> */
static int G__MiniFWLiteDict_652_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<unsigned long long>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<unsigned long long>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<unsigned long long>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<unsigned long long>;
     } else {
       p = new((void*) gvp) edm::Wrapper<unsigned long long>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_652_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 77, (long) ((const edm::Wrapper<unsigned long long>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_652_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 77, (long) ((const edm::Wrapper<unsigned long long>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_652_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<unsigned long long>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_652_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<unsigned long long>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<unsigned long long> G__TedmcLcLWrapperlEunsignedsPlongsPlonggR;
static int G__MiniFWLiteDict_652_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<unsigned long long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<unsigned long long>*) (soff+(sizeof(edm::Wrapper<unsigned long long>)*i)))->~G__TedmcLcLWrapperlEunsignedsPlongsPlonggR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<unsigned long long>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<unsigned long long>*) (soff))->~G__TedmcLcLWrapperlEunsignedsPlongsPlonggR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* edm::Wrapper<TBits> */
static int G__MiniFWLiteDict_653_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   edm::Wrapper<TBits>* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<TBits>[n];
     } else {
       p = new((void*) gvp) edm::Wrapper<TBits>[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new edm::Wrapper<TBits>;
     } else {
       p = new((void*) gvp) edm::Wrapper<TBits>;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_653_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<TBits>*) G__getstructoffset())->product());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_653_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 85, (long) ((const edm::Wrapper<TBits>*) G__getstructoffset())->operator->());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_653_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<TBits>::productTypeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_653_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const type_info& obj = edm::Wrapper<TBits>::typeInfo();
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef edm::Wrapper<TBits> G__TedmcLcLWrapperlETBitsgR;
static int G__MiniFWLiteDict_653_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (edm::Wrapper<TBits>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((edm::Wrapper<TBits>*) (soff+(sizeof(edm::Wrapper<TBits>)*i)))->~G__TedmcLcLWrapperlETBitsgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (edm::Wrapper<TBits>*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((edm::Wrapper<TBits>*) (soff))->~G__TedmcLcLWrapperlETBitsgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > */
static int G__MiniFWLiteDict_657_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >[n];
     } else {
       p = new((void*) gvp) set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >;
     } else {
       p = new((void*) gvp) set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >(*(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >(*(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >& obj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->operator=(*(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->begin();
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->end();
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator* pobj;
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->rbegin();
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator* pobj;
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->rend();
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         pair<set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator,bool>* pobj;
         pair<set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator,bool> xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->insert(*(edm::BranchID*) libp->para[0].ref);
         pobj = new pair<set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator,bool>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->insert(*((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator*) G__int(libp->para[0])), *(edm::BranchID*) libp->para[1].ref);
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->erase(*((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->erase(*((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator*) G__int(libp->para[0])), *((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->swap(*(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->find(*(edm::BranchID*) libp->para[0].ref);
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->count(*(edm::BranchID*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->lower_bound(*(edm::BranchID*) libp->para[0].ref);
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_657_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator* pobj;
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator xobj = ((const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) G__getstructoffset())->upper_bound(*(edm::BranchID*) libp->para[0].ref);
         pobj = new set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > G__TsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR;
static int G__MiniFWLiteDict_657_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) (soff+(sizeof(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >)*i)))->~G__TsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) (soff))->~G__TsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > */
static int G__MiniFWLiteDict_661_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >[n];
     } else {
       p = new((void*) gvp) pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >;
     } else {
       p = new((void*) gvp) pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_661_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >(*(edm::BranchID*) libp->para[0].ref, *(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[1].ref);
   } else {
     p = new((void*) gvp) pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >(*(edm::BranchID*) libp->para[0].ref, *(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*) libp->para[1].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic copy constructor
static int G__MiniFWLiteDict_661_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)

{
   pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >* p;
   void* tmp = (void*) G__int(libp->para[0]);
   p = new pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >(*(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*) tmp);
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > G__TpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR;
static int G__MiniFWLiteDict_661_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*) (soff+(sizeof(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >)*i)))->~G__TpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*) (soff))->~G__TpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > */
static int G__MiniFWLiteDict_664_0_1(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   int n = G__getaryconstruct();
   if (n) {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >[n];
     } else {
       p = new((void*) gvp) map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >[n];
     }
   } else {
     if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
       p = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >;
     } else {
       p = new((void*) gvp) map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >;
     }
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_2(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_3(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 2
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[1])));
   } else {
     p = new((void*) gvp) map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[1])));
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_4(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >* p = NULL;
   char* gvp = (char*) G__getgvp();
   //m: 1
   if ((gvp == (char*)G__PVOID) || (gvp == 0)) {
     p = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) libp->para[0].ref);
   } else {
     p = new((void*) gvp) map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >(*(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) libp->para[0].ref);
   }
   result7->obj.i = (long) p;
   result7->ref = (long) p;
   G__set_tagnum(result7,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_5(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >& obj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->operator=(*(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_6(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->begin();
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_7(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->end();
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_8(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->rbegin();
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_9(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->rend();
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_10(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 103, (long) ((const map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->empty());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_11(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_12(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->max_size());
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_13(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         const set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >& obj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->operator[](*(edm::BranchID*) libp->para[0].ref);
         result7->ref = (long) (&obj);
         result7->obj.i = (long) (&obj);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_14(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         pair<map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator,bool>* pobj;
         pair<map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator,bool> xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->insert(*(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::value_type*) libp->para[0].ref);
         pobj = new pair<map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator,bool>(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_15(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->insert(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])), *(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::value_type*) libp->para[1].ref);
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_16(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->insert(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_17(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->insert(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_18(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->erase(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_19(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->erase(*(edm::BranchID*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_20(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->erase(*((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[0])), *((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator*) G__int(libp->para[1])));
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_21(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->swap(*(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) libp->para[0].ref);
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_22(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->clear();
      G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_23(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->find(*(edm::BranchID*) libp->para[0].ref);
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_24(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      G__letint(result7, 107, (long) ((const map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->count(*(edm::BranchID*) libp->para[0].ref));
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_25(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->lower_bound(*(edm::BranchID*) libp->para[0].ref);
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

static int G__MiniFWLiteDict_664_0_26(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
      {
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator* pobj;
         map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator xobj = ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) G__getstructoffset())->upper_bound(*(edm::BranchID*) libp->para[0].ref);
         pobj = new map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator(xobj);
         result7->obj.i = (long) ((void*) pobj);
         result7->ref = result7->obj.i;
         G__store_tempobject(*result7);
      }
   return(1 || funcname || hash || result7 || libp) ;
}

// automatic destructor
typedef map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > G__TmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR;
static int G__MiniFWLiteDict_664_0_27(G__value* result7, G__CONST char* funcname, struct G__param* libp, int hash)
{
   char* gvp = (char*) G__getgvp();
   long soff = G__getstructoffset();
   int n = G__getaryconstruct();
   //
   //has_a_delete: 0
   //has_own_delete1arg: 0
   //has_own_delete2arg: 0
   //
   if (!soff) {
     return(1);
   }
   if (n) {
     if (gvp == (char*)G__PVOID) {
       delete[] (map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       for (int i = n - 1; i >= 0; --i) {
         ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) (soff+(sizeof(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >)*i)))->~G__TmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR();
       }
       G__setgvp((long)gvp);
     }
   } else {
     if (gvp == (char*)G__PVOID) {
       delete (map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) soff;
     } else {
       G__setgvp((long) G__PVOID);
       ((map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*) (soff))->~G__TmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR();
       G__setgvp((long)gvp);
     }
   }
   G__setnull(result7);
   return(1 || funcname || hash || result7 || libp) ;
}


/* Setting up global function */

/*********************************************************
* Member function Stub
*********************************************************/

/* edm::EDProduct */

/* edm::BranchKey */

/* edm::EventAuxiliary */

/* edm::FileFormatVersion */

/* edm::LuminosityBlockAuxiliary */

/* edm::ParameterSetBlob */

/* edm::RunAuxiliary */

/* edm::BranchChildren */

/* edm::BranchDescription */

/* edm::BranchDescription::Transients */

/* edm::BranchID */

/* edm::EventEntryDescription */

/* edm::EventEntryDescription::Transients */

/* edm::EventEntryInfo */

/* edm::EventEntryInfo::Transients */

/* edm::EventID */

/* edm::FileID */

/* edm::FileIndex */

/* edm::FileIndex::Element */

/* edm::FileIndex::Transients */

/* edm::History */

/* edm::LuminosityBlockID */

/* edm::ModuleDescription */

/* edm::Parentage */

/* edm::Parentage::Transients */

/* edm::ProcessConfiguration */

/* edm::ProcessConfiguration::Transients */

/* edm::ProcessHistory */

/* edm::ProcessHistory::Transients */

/* edm::ProductID */

/* edm::StoredProductProvenance */

/* edm::ProductProvenance */

/* edm::ProductRegistry */

/* edm::ProductRegistry::Transients */

/* edm::RunID */

/* edm::Timestamp */

/* edm::IndexIntoFile */

/* edm::IndexIntoFile::Transients */

/* edm::IndexIntoFile::RunOrLumiEntry */

/* ROOT::Math::PxPyPzE4D<float> */

/* ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > */

/* ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> */

/* vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > */

/* vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > */

/* vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > */

/* vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > */

/* vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > */

/* vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > */

/* edm::Wrapper<TString> */

/* edm::Wrapper<double> */

/* edm::Wrapper<float> */

/* edm::Wrapper<int> */

/* edm::Wrapper<unsigned int> */

/* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > */

/* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > */

/* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > */

/* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > */

/* edm::Wrapper<vector<TString,allocator<TString> > > */

/* edm::Wrapper<vector<double,allocator<double> > > */

/* edm::Wrapper<vector<float,allocator<float> > > */

/* edm::Wrapper<vector<int,allocator<int> > > */

/* edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > */

/* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > */

/* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > */

/* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > */

/* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > */

/* edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > */

/* edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > */

/* edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > */

/* edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > */

/* edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > */

/* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > */

/* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > */

/* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */

/* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */

/* edm::Hash<0> */

/* edm::Hash<1> */

/* edm::Hash<2> */

/* edm::Hash<3> */

/* edm::Hash<4> */

/* edm::Hash<5> */

/* edm::Transient<edm::BranchDescription::Transients> */

/* edm::Transient<edm::EventEntryDescription::Transients> */

/* edm::Transient<edm::EventEntryInfo::Transients> */

/* edm::Transient<edm::FileIndex::Transients> */

/* edm::Transient<edm::Parentage::Transients> */

/* edm::Transient<edm::ProcessConfiguration::Transients> */

/* edm::Transient<edm::ProcessHistory::Transients> */

/* edm::Transient<edm::ProductProvenance::Transients> */

/* edm::Transient<edm::ProductRegistry::Transients> */

/* edm::Transient<edm::IndexIntoFile::Transients> */

/* pair<edm::BranchKey,edm::BranchDescription> */

/* pair<edm::Hash<1>,edm::ParameterSetBlob> */

/* edm::Wrapper<bool> */

/* edm::Wrapper<vector<bool,allocator<bool> > > */

/* edm::Wrapper<unsigned long long> */

/* edm::Wrapper<TBits> */

/* set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > */

/* pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > */

/* map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > */

/*********************************************************
* Global function Stub
*********************************************************/

/*********************************************************
* Get size of pointer to member function
*********************************************************/
class G__Sizep2memfuncMiniFWLiteDict {
 public:
  G__Sizep2memfuncMiniFWLiteDict(): p(&G__Sizep2memfuncMiniFWLiteDict::sizep2memfunc) {}
    size_t sizep2memfunc() { return(sizeof(p)); }
  private:
    size_t (G__Sizep2memfuncMiniFWLiteDict::*p)();
};

size_t G__get_sizep2memfuncMiniFWLiteDict()
{
  G__Sizep2memfuncMiniFWLiteDict a;
  G__setsizep2memfunc((int)a.sizep2memfunc());
  return((size_t)a.sizep2memfunc());
}


/*********************************************************
* virtual base class offset calculation interface
*********************************************************/

   /* Setting up class inheritance */

/*********************************************************
* Inheritance information setup/
*********************************************************/
extern "C" void G__cpp_setup_inheritanceMiniFWLiteDict() {

   /* Setting up class inheritance */
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR))) {
     edm::Wrapper<TString> *G__Lderived;
     G__Lderived=(edm::Wrapper<TString>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR))) {
     edm::Wrapper<double> *G__Lderived;
     G__Lderived=(edm::Wrapper<double>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR))) {
     edm::Wrapper<float> *G__Lderived;
     G__Lderived=(edm::Wrapper<float>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR))) {
     edm::Wrapper<int> *G__Lderived;
     G__Lderived=(edm::Wrapper<int>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR))) {
     edm::Wrapper<unsigned int> *G__Lderived;
     G__Lderived=(edm::Wrapper<unsigned int>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR))) {
     edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR))) {
     edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR))) {
     edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > *G__Lderived;
     G__Lderived=(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR))) {
     edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > *G__Lderived;
     G__Lderived=(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR))) {
     edm::Wrapper<vector<TString,allocator<TString> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<TString,allocator<TString> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR))) {
     edm::Wrapper<vector<double,allocator<double> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<double,allocator<double> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR))) {
     edm::Wrapper<vector<float,allocator<float> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<float,allocator<float> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR))) {
     edm::Wrapper<vector<int,allocator<int> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<int,allocator<int> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR))) {
     edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR))) {
     edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR))) {
     edm::Wrapper<bool> *G__Lderived;
     G__Lderived=(edm::Wrapper<bool>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR))) {
     edm::Wrapper<vector<bool,allocator<bool> > > *G__Lderived;
     G__Lderived=(edm::Wrapper<vector<bool,allocator<bool> > >*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR))) {
     edm::Wrapper<unsigned long long> *G__Lderived;
     G__Lderived=(edm::Wrapper<unsigned long long>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
   if(0==G__getnumbaseclass(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR))) {
     edm::Wrapper<TBits> *G__Lderived;
     G__Lderived=(edm::Wrapper<TBits>*)0x1000;
     {
       edm::EDProduct *G__Lpbase=(edm::EDProduct*)G__Lderived;
       G__inheritance_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR),G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct),(long)G__Lpbase-(long)G__Lderived,1,1);
     }
   }
}

/*********************************************************
* typedef information setup/
*********************************************************/
extern "C" void G__cpp_setup_typetableMiniFWLiteDict() {

   /* Setting up typedef entry */
   G__search_typename2("vector<ROOT::TSchemaHelper>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<TVirtualArray*>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Scalar",102,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Scalar",102,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("CoordinateType",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Cartesian3D<Scalar>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Cartesian3D",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("::ROOT::Math::DisplacementVector3D<Cartesian3D<Scalar> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("::ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("DisplacementVector3D<Cartesian3D<Scalar> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("DisplacementVector3D<ROOT::Math::Cartesian3D<float> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("BetaVector",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Scalar",102,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("CoordinateType",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("CoordinateSystemTag",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDefaultCoordinateSystemTag),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::Math::PxPyPzE4D<float> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::PxPyPzE4D<float> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<const_iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator<iterator>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<TString> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<double> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<float> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<int> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<unsigned int> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<TString> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<double> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<float> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<int> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<unsigned int> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("edm::Wrapper<vector<bool> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("edm::Wrapper<ULong64_t>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edm));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("set<edm::BranchID>",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_compare",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_compare",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("allocator_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_allocatorlEedmcLcLBranchIDgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_pointer",85,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),1,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reference",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),257,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("set<edm::BranchID,less<edm::BranchID> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("pair<edm::BranchID,set<edm::BranchID> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<edm::BranchID,set<edm::BranchID> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("mapped_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("value_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("key_compare",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("allocator_type",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_allocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgR),0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("size_type",107,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("difference_type",108,-1,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("const_reverse_iterator",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator),256,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
   G__search_typename2("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID> >",117,G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR),0,-1);
   G__setnewtype(-1,NULL,0);
}

/*********************************************************
* Data Member information setup/
*********************************************************/

   /* Setting up class,struct,union tag member variable */

   /* edm::EDProduct */
static void G__setup_memvaredmcLcLEDProduct(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct));
   { edm::EDProduct *p; p=(edm::EDProduct*)0x1000; if (p) { }
   G__memvar_setup((void*)0,108,0,0,-1,-1,-1,4,"G__virtualinfo=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::BranchKey */
static void G__setup_memvaredmcLcLBranchKey(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey));
   { edm::BranchKey *p; p=(edm::BranchKey*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventAuxiliary */
static void G__setup_memvaredmcLcLEventAuxiliary(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary));
   { edm::EventAuxiliary *p; p=(edm::EventAuxiliary*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::FileFormatVersion */
static void G__setup_memvaredmcLcLFileFormatVersion(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion));
   { edm::FileFormatVersion *p; p=(edm::FileFormatVersion*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::LuminosityBlockAuxiliary */
static void G__setup_memvaredmcLcLLuminosityBlockAuxiliary(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary));
   { edm::LuminosityBlockAuxiliary *p; p=(edm::LuminosityBlockAuxiliary*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ParameterSetBlob */
static void G__setup_memvaredmcLcLParameterSetBlob(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob));
   { edm::ParameterSetBlob *p; p=(edm::ParameterSetBlob*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::RunAuxiliary */
static void G__setup_memvaredmcLcLRunAuxiliary(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary));
   { edm::RunAuxiliary *p; p=(edm::RunAuxiliary*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::BranchChildren */
static void G__setup_memvaredmcLcLBranchChildren(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren));
   { edm::BranchChildren *p; p=(edm::BranchChildren*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::BranchDescription */
static void G__setup_memvaredmcLcLBranchDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription));
   { edm::BranchDescription *p; p=(edm::BranchDescription*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::BranchDescription::Transients */
static void G__setup_memvaredmcLcLBranchDescriptioncLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients));
   { edm::BranchDescription::Transients *p; p=(edm::BranchDescription::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::BranchID */
static void G__setup_memvaredmcLcLBranchID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID));
   { edm::BranchID *p; p=(edm::BranchID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventEntryDescription */
static void G__setup_memvaredmcLcLEventEntryDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription));
   { edm::EventEntryDescription *p; p=(edm::EventEntryDescription*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventEntryDescription::Transients */
static void G__setup_memvaredmcLcLEventEntryDescriptioncLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients));
   { edm::EventEntryDescription::Transients *p; p=(edm::EventEntryDescription::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventEntryInfo */
static void G__setup_memvaredmcLcLEventEntryInfo(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo));
   { edm::EventEntryInfo *p; p=(edm::EventEntryInfo*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventEntryInfo::Transients */
static void G__setup_memvaredmcLcLEventEntryInfocLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients));
   { edm::EventEntryInfo::Transients *p; p=(edm::EventEntryInfo::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::EventID */
static void G__setup_memvaredmcLcLEventID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID));
   { edm::EventID *p; p=(edm::EventID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::FileID */
static void G__setup_memvaredmcLcLFileID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID));
   { edm::FileID *p; p=(edm::FileID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::FileIndex */
static void G__setup_memvaredmcLcLFileIndex(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex));
   { edm::FileIndex *p; p=(edm::FileIndex*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::FileIndex::Element */
static void G__setup_memvaredmcLcLFileIndexcLcLElement(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement));
   { edm::FileIndex::Element *p; p=(edm::FileIndex::Element*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::FileIndex::Transients */
static void G__setup_memvaredmcLcLFileIndexcLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients));
   { edm::FileIndex::Transients *p; p=(edm::FileIndex::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::History */
static void G__setup_memvaredmcLcLHistory(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory));
   { edm::History *p; p=(edm::History*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::LuminosityBlockID */
static void G__setup_memvaredmcLcLLuminosityBlockID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID));
   { edm::LuminosityBlockID *p; p=(edm::LuminosityBlockID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ModuleDescription */
static void G__setup_memvaredmcLcLModuleDescription(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription));
   { edm::ModuleDescription *p; p=(edm::ModuleDescription*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Parentage */
static void G__setup_memvaredmcLcLParentage(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage));
   { edm::Parentage *p; p=(edm::Parentage*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Parentage::Transients */
static void G__setup_memvaredmcLcLParentagecLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients));
   { edm::Parentage::Transients *p; p=(edm::Parentage::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProcessConfiguration */
static void G__setup_memvaredmcLcLProcessConfiguration(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration));
   { edm::ProcessConfiguration *p; p=(edm::ProcessConfiguration*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProcessConfiguration::Transients */
static void G__setup_memvaredmcLcLProcessConfigurationcLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients));
   { edm::ProcessConfiguration::Transients *p; p=(edm::ProcessConfiguration::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProcessHistory */
static void G__setup_memvaredmcLcLProcessHistory(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory));
   { edm::ProcessHistory *p; p=(edm::ProcessHistory*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProcessHistory::Transients */
static void G__setup_memvaredmcLcLProcessHistorycLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients));
   { edm::ProcessHistory::Transients *p; p=(edm::ProcessHistory::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProductID */
static void G__setup_memvaredmcLcLProductID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID));
   { edm::ProductID *p; p=(edm::ProductID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::StoredProductProvenance */
static void G__setup_memvaredmcLcLStoredProductProvenance(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance));
   { edm::StoredProductProvenance *p; p=(edm::StoredProductProvenance*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProductProvenance */
static void G__setup_memvaredmcLcLProductProvenance(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance));
   { edm::ProductProvenance *p; p=(edm::ProductProvenance*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProductRegistry */
static void G__setup_memvaredmcLcLProductRegistry(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry));
   { edm::ProductRegistry *p; p=(edm::ProductRegistry*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::ProductRegistry::Transients */
static void G__setup_memvaredmcLcLProductRegistrycLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients));
   { edm::ProductRegistry::Transients *p; p=(edm::ProductRegistry::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::RunID */
static void G__setup_memvaredmcLcLRunID(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID));
   { edm::RunID *p; p=(edm::RunID*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Timestamp */
static void G__setup_memvaredmcLcLTimestamp(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp));
   { edm::Timestamp *p; p=(edm::Timestamp*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::IndexIntoFile */
static void G__setup_memvaredmcLcLIndexIntoFile(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile));
   { edm::IndexIntoFile *p; p=(edm::IndexIntoFile*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::IndexIntoFile::Transients */
static void G__setup_memvaredmcLcLIndexIntoFilecLcLTransients(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients));
   { edm::IndexIntoFile::Transients *p; p=(edm::IndexIntoFile::Transients*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::IndexIntoFile::RunOrLumiEntry */
static void G__setup_memvaredmcLcLIndexIntoFilecLcLRunOrLumiEntry(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry));
   { edm::IndexIntoFile::RunOrLumiEntry *p; p=(edm::IndexIntoFile::RunOrLumiEntry*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::PxPyPzE4D<float> */
static void G__setup_memvarROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   { ROOT::Math::PxPyPzE4D<float> *p; p=(ROOT::Math::PxPyPzE4D<float>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"fX=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"fY=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"fZ=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"fT=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > */
static void G__setup_memvarROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   { ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > *p; p=(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),-1,-1,4,"fCoordinates=",0,"internal coordinate system");
   }
   G__tag_memvar_reset();
}


   /* ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> */
static void G__setup_memvarROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   { ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> *p; p=(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR),-1,-1,4,"fCoordinates=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > */
static void G__setup_memvarvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   { vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > *p; p=(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > */
static void G__setup_memvarvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   { vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > *p; p=(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > */
static void G__setup_memvarvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   { vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > *p; p=(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > */
static void G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   { vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > *p; p=(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > */
static void G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   { vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > *p; p=(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > */
static void G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   { vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > *p; p=(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<TString> */
static void G__setup_memvaredmcLcLWrapperlETStringgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR));
   { edm::Wrapper<TString> *p; p=(edm::Wrapper<TString>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_TString),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<double> */
static void G__setup_memvaredmcLcLWrapperlEdoublegR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR));
   { edm::Wrapper<double> *p; p=(edm::Wrapper<double>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,100,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<float> */
static void G__setup_memvaredmcLcLWrapperlEfloatgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR));
   { edm::Wrapper<float> *p; p=(edm::Wrapper<float>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,102,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<int> */
static void G__setup_memvaredmcLcLWrapperlEintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR));
   { edm::Wrapper<int> *p; p=(edm::Wrapper<int>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,105,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<unsigned int> */
static void G__setup_memvaredmcLcLWrapperlEunsignedsPintgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR));
   { edm::Wrapper<unsigned int> *p; p=(edm::Wrapper<unsigned int>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,104,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > */
static void G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR));
   { edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > *p; p=(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > */
static void G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   { edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > *p; p=(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > */
static void G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   { edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > *p; p=(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > */
static void G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   { edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > *p; p=(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<TString,allocator<TString> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR));
   { edm::Wrapper<vector<TString,allocator<TString> > > *p; p=(edm::Wrapper<vector<TString,allocator<TString> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<double,allocator<double> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR));
   { edm::Wrapper<vector<double,allocator<double> > > *p; p=(edm::Wrapper<vector<double,allocator<double> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<float,allocator<float> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR));
   { edm::Wrapper<vector<float,allocator<float> > > *p; p=(edm::Wrapper<vector<float,allocator<float> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<int,allocator<int> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR));
   { edm::Wrapper<vector<int,allocator<int> > > *p; p=(edm::Wrapper<vector<int,allocator<int> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR));
   { edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > *p; p=(edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > *p; p=(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > *p; p=(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   { edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > *p; p=(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   { edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > *p; p=(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > *p; p=(edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > *p; p=(edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > *p; p=(edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > *p; p=(edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > *p; p=(edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > *p; p=(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > *p; p=(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *p; p=(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   { edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > *p; p=(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<0> */
static void G__setup_memvaredmcLcLHashlE0gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR));
   { edm::Hash<0> *p; p=(edm::Hash<0>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<1> */
static void G__setup_memvaredmcLcLHashlE1gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR));
   { edm::Hash<1> *p; p=(edm::Hash<1>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<2> */
static void G__setup_memvaredmcLcLHashlE2gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR));
   { edm::Hash<2> *p; p=(edm::Hash<2>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<3> */
static void G__setup_memvaredmcLcLHashlE3gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR));
   { edm::Hash<3> *p; p=(edm::Hash<3>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<4> */
static void G__setup_memvaredmcLcLHashlE4gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR));
   { edm::Hash<4> *p; p=(edm::Hash<4>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Hash<5> */
static void G__setup_memvaredmcLcLHashlE5gR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR));
   { edm::Hash<5> *p; p=(edm::Hash<5>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::BranchDescription::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR));
   { edm::Transient<edm::BranchDescription::Transients> *p; p=(edm::Transient<edm::BranchDescription::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::EventEntryDescription::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR));
   { edm::Transient<edm::EventEntryDescription::Transients> *p; p=(edm::Transient<edm::EventEntryDescription::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::EventEntryInfo::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR));
   { edm::Transient<edm::EventEntryInfo::Transients> *p; p=(edm::Transient<edm::EventEntryInfo::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::FileIndex::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR));
   { edm::Transient<edm::FileIndex::Transients> *p; p=(edm::Transient<edm::FileIndex::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::Parentage::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR));
   { edm::Transient<edm::Parentage::Transients> *p; p=(edm::Transient<edm::Parentage::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::ProcessConfiguration::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR));
   { edm::Transient<edm::ProcessConfiguration::Transients> *p; p=(edm::Transient<edm::ProcessConfiguration::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::ProcessHistory::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR));
   { edm::Transient<edm::ProcessHistory::Transients> *p; p=(edm::Transient<edm::ProcessHistory::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::ProductProvenance::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR));
   { edm::Transient<edm::ProductProvenance::Transients> *p; p=(edm::Transient<edm::ProductProvenance::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::ProductRegistry::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR));
   { edm::Transient<edm::ProductRegistry::Transients> *p; p=(edm::Transient<edm::ProductRegistry::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* edm::Transient<edm::IndexIntoFile::Transients> */
static void G__setup_memvaredmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR));
   { edm::Transient<edm::IndexIntoFile::Transients> *p; p=(edm::Transient<edm::IndexIntoFile::Transients>*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* pair<edm::BranchKey,edm::BranchDescription> */
static void G__setup_memvarpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
   { pair<edm::BranchKey,edm::BranchDescription> *p; p=(pair<edm::BranchKey,edm::BranchDescription>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription),-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* pair<edm::Hash<1>,edm::ParameterSetBlob> */
static void G__setup_memvarpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
   { pair<edm::Hash<1>,edm::ParameterSetBlob> *p; p=(pair<edm::Hash<1>,edm::ParameterSetBlob>*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob),-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<bool> */
static void G__setup_memvaredmcLcLWrapperlEboolgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR));
   { edm::Wrapper<bool> *p; p=(edm::Wrapper<bool>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<vector<bool,allocator<bool> > > */
static void G__setup_memvaredmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR));
   { edm::Wrapper<vector<bool,allocator<bool> > > *p; p=(edm::Wrapper<vector<bool,allocator<bool> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<unsigned long long> */
static void G__setup_memvaredmcLcLWrapperlEunsignedsPlongsPlonggR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR));
   { edm::Wrapper<unsigned long long> *p; p=(edm::Wrapper<unsigned long long>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,109,0,0,-1,-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* edm::Wrapper<TBits> */
static void G__setup_memvaredmcLcLWrapperlETBitsgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR));
   { edm::Wrapper<TBits> *p; p=(edm::Wrapper<TBits>*)0x1000; if (p) { }
   G__memvar_setup((void*)0,103,0,0,-1,-1,-1,4,"present=",0,(char*)NULL);
   G__memvar_setup((void*)0,117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_TBits),-1,-1,4,"obj=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > */
static void G__setup_memvarsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   { set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > *p; p=(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}


   /* pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > */
static void G__setup_memvarpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
   { pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > *p; p=(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >*)0x1000; if (p) { }
   G__memvar_setup((void*)((long)(&p->first)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID),-1,-1,1,"first=",0,(char*)NULL);
   G__memvar_setup((void*)((long)(&p->second)-(long)(p)),117,0,0,G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR),-1,-1,1,"second=",0,(char*)NULL);
   }
   G__tag_memvar_reset();
}


   /* map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > */
static void G__setup_memvarmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR(void) {
   G__tag_memvar_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   { map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > *p; p=(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >*)0x1000; if (p) { }
   }
   G__tag_memvar_reset();
}

extern "C" void G__cpp_setup_memvarMiniFWLiteDict() {
}
/***********************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
************************************************************
***********************************************************/

/*********************************************************
* Member function information setup for each class
*********************************************************/
static void G__setup_memfuncedmcLcLEDProduct(void) {
   /* edm::EDProduct */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct));
   G__memfunc_setup("EDProduct",874,G__MiniFWLiteDict_163_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isPresent",957,G__MiniFWLiteDict_163_0_2, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isMergeable",1120,G__MiniFWLiteDict_163_0_3, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mergeProduct",1265,G__MiniFWLiteDict_163_0_4, 103, -1, -1, 0, 1, 1, 1, 0, "U 'edm::EDProduct' - 10 - newProduct", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("hasIsProductEqual",1745,G__MiniFWLiteDict_163_0_5, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isProductEqual",1461,G__MiniFWLiteDict_163_0_6, 103, -1, -1, 0, 1, 1, 1, 8, "U 'edm::EDProduct' - 10 - newProduct", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isPresent_",1052,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 4, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isMergeable_",1215,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 4, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("mergeProduct_",1360,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 4, 0, "U 'edm::EDProduct' - 10 - newProduct", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("hasIsProductEqual_",1840,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 0, 1, 4, 8, "", (char*)NULL, (void*) NULL, 1);
   G__memfunc_setup("isProductEqual_",1556,(G__InterfaceMethod) NULL, 103, -1, -1, 0, 1, 1, 4, 8, "U 'edm::EDProduct' - 10 - newProduct", (char*)NULL, (void*) NULL, 1);
   // automatic copy constructor
   G__memfunc_setup("EDProduct", 874, G__MiniFWLiteDict_163_0_12, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct), -1, 0, 1, 1, 1, 0, "u 'edm::EDProduct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EDProduct", 1000, G__MiniFWLiteDict_163_0_13, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_163_0_14, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEDProduct), -1, 1, 1, 1, 1, 0, "u 'edm::EDProduct' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLBranchKey(void) {
   /* edm::BranchKey */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey));
   // automatic default constructor
   G__memfunc_setup("BranchKey", 887, G__MiniFWLiteDict_488_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BranchKey", 887, G__MiniFWLiteDict_488_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey), -1, 0, 1, 1, 1, 0, "u 'edm::BranchKey' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BranchKey", 1013, G__MiniFWLiteDict_488_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_488_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchKey), -1, 1, 1, 1, 1, 0, "u 'edm::BranchKey' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventAuxiliary(void) {
   /* edm::EventAuxiliary */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary));
   // automatic default constructor
   G__memfunc_setup("EventAuxiliary", 1466, G__MiniFWLiteDict_489_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EventAuxiliary", 1466, G__MiniFWLiteDict_489_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary), -1, 0, 1, 1, 1, 0, "u 'edm::EventAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EventAuxiliary", 1592, G__MiniFWLiteDict_489_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_489_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary), -1, 1, 1, 1, 1, 0, "u 'edm::EventAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLFileFormatVersion(void) {
   /* edm::FileFormatVersion */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion));
   // automatic default constructor
   G__memfunc_setup("FileFormatVersion", 1743, G__MiniFWLiteDict_490_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FileFormatVersion", 1743, G__MiniFWLiteDict_490_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion), -1, 0, 1, 1, 1, 0, "u 'edm::FileFormatVersion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FileFormatVersion", 1869, G__MiniFWLiteDict_490_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_490_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion), -1, 1, 1, 1, 1, 0, "u 'edm::FileFormatVersion' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLLuminosityBlockAuxiliary(void) {
   /* edm::LuminosityBlockAuxiliary */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary));
   // automatic default constructor
   G__memfunc_setup("LuminosityBlockAuxiliary", 2528, G__MiniFWLiteDict_491_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LuminosityBlockAuxiliary", 2528, G__MiniFWLiteDict_491_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary), -1, 0, 1, 1, 1, 0, "u 'edm::LuminosityBlockAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LuminosityBlockAuxiliary", 2654, G__MiniFWLiteDict_491_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_491_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary), -1, 1, 1, 1, 1, 0, "u 'edm::LuminosityBlockAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLParameterSetBlob(void) {
   /* edm::ParameterSetBlob */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob));
   // automatic default constructor
   G__memfunc_setup("ParameterSetBlob", 1612, G__MiniFWLiteDict_492_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ParameterSetBlob", 1612, G__MiniFWLiteDict_492_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob), -1, 0, 1, 1, 1, 0, "u 'edm::ParameterSetBlob' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ParameterSetBlob", 1738, G__MiniFWLiteDict_492_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_492_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob), -1, 1, 1, 1, 1, 0, "u 'edm::ParameterSetBlob' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLRunAuxiliary(void) {
   /* edm::RunAuxiliary */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary));
   // automatic default constructor
   G__memfunc_setup("RunAuxiliary", 1261, G__MiniFWLiteDict_493_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RunAuxiliary", 1261, G__MiniFWLiteDict_493_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary), -1, 0, 1, 1, 1, 0, "u 'edm::RunAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RunAuxiliary", 1387, G__MiniFWLiteDict_493_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_493_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary), -1, 1, 1, 1, 1, 0, "u 'edm::RunAuxiliary' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLBranchChildren(void) {
   /* edm::BranchChildren */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren));
   // automatic default constructor
   G__memfunc_setup("BranchChildren", 1399, G__MiniFWLiteDict_494_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BranchChildren", 1399, G__MiniFWLiteDict_494_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren), -1, 0, 1, 1, 1, 0, "u 'edm::BranchChildren' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BranchChildren", 1525, G__MiniFWLiteDict_494_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_494_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchChildren), -1, 1, 1, 1, 1, 0, "u 'edm::BranchChildren' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLBranchDescription(void) {
   /* edm::BranchDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription));
   // automatic default constructor
   G__memfunc_setup("BranchDescription", 1746, G__MiniFWLiteDict_495_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BranchDescription", 1746, G__MiniFWLiteDict_495_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription), -1, 0, 1, 1, 1, 0, "u 'edm::BranchDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BranchDescription", 1872, G__MiniFWLiteDict_495_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_495_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescription), -1, 1, 1, 1, 1, 0, "u 'edm::BranchDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLBranchDescriptioncLcLTransients(void) {
   /* edm::BranchDescription::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_496_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_496_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::BranchDescription::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_496_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_496_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::BranchDescription::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLBranchID(void) {
   /* edm::BranchID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID));
   G__memfunc_setup("operator<",936,G__MiniFWLiteDict_497_0_1, 103, -1, -1, 0, 1, 1, 1, 8, "u 'edm::BranchID' - 41 - rhs", (char*)NULL, (void*) NULL, 0);
   // automatic default constructor
   G__memfunc_setup("BranchID", 731, G__MiniFWLiteDict_497_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("BranchID", 731, G__MiniFWLiteDict_497_0_3, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID), -1, 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~BranchID", 857, G__MiniFWLiteDict_497_0_4, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_497_0_5, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLBranchID), -1, 1, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventEntryDescription(void) {
   /* edm::EventEntryDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription));
   // automatic default constructor
   G__memfunc_setup("EventEntryDescription", 2200, G__MiniFWLiteDict_498_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EventEntryDescription", 2200, G__MiniFWLiteDict_498_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription), -1, 0, 1, 1, 1, 0, "u 'edm::EventEntryDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EventEntryDescription", 2326, G__MiniFWLiteDict_498_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_498_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription), -1, 1, 1, 1, 1, 0, "u 'edm::EventEntryDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventEntryDescriptioncLcLTransients(void) {
   /* edm::EventEntryDescription::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_499_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_499_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::EventEntryDescription::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_499_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_499_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::EventEntryDescription::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventEntryInfo(void) {
   /* edm::EventEntryInfo */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo));
   // automatic default constructor
   G__memfunc_setup("EventEntryInfo", 1440, G__MiniFWLiteDict_500_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EventEntryInfo", 1440, G__MiniFWLiteDict_500_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo), -1, 0, 1, 1, 1, 0, "u 'edm::EventEntryInfo' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EventEntryInfo", 1566, G__MiniFWLiteDict_500_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_500_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo), -1, 1, 1, 1, 1, 0, "u 'edm::EventEntryInfo' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventEntryInfocLcLTransients(void) {
   /* edm::EventEntryInfo::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_501_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_501_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::EventEntryInfo::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_501_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_501_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::EventEntryInfo::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLEventID(void) {
   /* edm::EventID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID));
   // automatic default constructor
   G__memfunc_setup("EventID", 655, G__MiniFWLiteDict_502_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("EventID", 655, G__MiniFWLiteDict_502_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID), -1, 0, 1, 1, 1, 0, "u 'edm::EventID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~EventID", 781, G__MiniFWLiteDict_502_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_502_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLEventID), -1, 1, 1, 1, 1, 0, "u 'edm::EventID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLFileID(void) {
   /* edm::FileID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID));
   // automatic default constructor
   G__memfunc_setup("FileID", 525, G__MiniFWLiteDict_503_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FileID", 525, G__MiniFWLiteDict_503_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID), -1, 0, 1, 1, 1, 0, "u 'edm::FileID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FileID", 651, G__MiniFWLiteDict_503_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_503_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileID), -1, 1, 1, 1, 1, 0, "u 'edm::FileID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLFileIndex(void) {
   /* edm::FileIndex */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex));
   // automatic default constructor
   G__memfunc_setup("FileIndex", 888, G__MiniFWLiteDict_504_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("FileIndex", 888, G__MiniFWLiteDict_504_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex), -1, 0, 1, 1, 1, 0, "u 'edm::FileIndex' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~FileIndex", 1014, G__MiniFWLiteDict_504_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_504_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndex), -1, 1, 1, 1, 1, 0, "u 'edm::FileIndex' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLFileIndexcLcLElement(void) {
   /* edm::FileIndex::Element */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement));
   // automatic default constructor
   G__memfunc_setup("Element", 714, G__MiniFWLiteDict_505_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Element", 714, G__MiniFWLiteDict_505_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement), -1, 0, 1, 1, 1, 0, "u 'edm::FileIndex::Element' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Element", 840, G__MiniFWLiteDict_505_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_505_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement), -1, 1, 1, 1, 1, 0, "u 'edm::FileIndex::Element' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLFileIndexcLcLTransients(void) {
   /* edm::FileIndex::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_506_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_506_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::FileIndex::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_506_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_506_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::FileIndex::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHistory(void) {
   /* edm::History */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory));
   // automatic default constructor
   G__memfunc_setup("History", 754, G__MiniFWLiteDict_507_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("History", 754, G__MiniFWLiteDict_507_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory), -1, 0, 1, 1, 1, 0, "u 'edm::History' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~History", 880, G__MiniFWLiteDict_507_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_507_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHistory), -1, 1, 1, 1, 1, 0, "u 'edm::History' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLLuminosityBlockID(void) {
   /* edm::LuminosityBlockID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID));
   // automatic default constructor
   G__memfunc_setup("LuminosityBlockID", 1717, G__MiniFWLiteDict_508_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LuminosityBlockID", 1717, G__MiniFWLiteDict_508_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID), -1, 0, 1, 1, 1, 0, "u 'edm::LuminosityBlockID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LuminosityBlockID", 1843, G__MiniFWLiteDict_508_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_508_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID), -1, 1, 1, 1, 1, 0, "u 'edm::LuminosityBlockID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLModuleDescription(void) {
   /* edm::ModuleDescription */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription));
   // automatic default constructor
   G__memfunc_setup("ModuleDescription", 1770, G__MiniFWLiteDict_509_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ModuleDescription", 1770, G__MiniFWLiteDict_509_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription), -1, 0, 1, 1, 1, 0, "u 'edm::ModuleDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ModuleDescription", 1896, G__MiniFWLiteDict_509_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_509_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLModuleDescription), -1, 1, 1, 1, 1, 0, "u 'edm::ModuleDescription' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLParentage(void) {
   /* edm::Parentage */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage));
   // automatic default constructor
   G__memfunc_setup("Parentage", 919, G__MiniFWLiteDict_510_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Parentage", 919, G__MiniFWLiteDict_510_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage), -1, 0, 1, 1, 1, 0, "u 'edm::Parentage' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Parentage", 1045, G__MiniFWLiteDict_510_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_510_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentage), -1, 1, 1, 1, 1, 0, "u 'edm::Parentage' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLParentagecLcLTransients(void) {
   /* edm::Parentage::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_511_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_511_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::Parentage::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_511_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_511_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::Parentage::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProcessConfiguration(void) {
   /* edm::ProcessConfiguration */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration));
   // automatic default constructor
   G__memfunc_setup("ProcessConfiguration", 2103, G__MiniFWLiteDict_512_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProcessConfiguration", 2103, G__MiniFWLiteDict_512_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration), -1, 0, 1, 1, 1, 0, "u 'edm::ProcessConfiguration' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProcessConfiguration", 2229, G__MiniFWLiteDict_512_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_512_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration), -1, 1, 1, 1, 1, 0, "u 'edm::ProcessConfiguration' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProcessConfigurationcLcLTransients(void) {
   /* edm::ProcessConfiguration::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_513_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_513_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::ProcessConfiguration::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_513_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_513_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::ProcessConfiguration::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProcessHistory(void) {
   /* edm::ProcessHistory */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory));
   // automatic default constructor
   G__memfunc_setup("ProcessHistory", 1489, G__MiniFWLiteDict_514_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProcessHistory", 1489, G__MiniFWLiteDict_514_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory), -1, 0, 1, 1, 1, 0, "u 'edm::ProcessHistory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProcessHistory", 1615, G__MiniFWLiteDict_514_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_514_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistory), -1, 1, 1, 1, 1, 0, "u 'edm::ProcessHistory' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProcessHistorycLcLTransients(void) {
   /* edm::ProcessHistory::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_515_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_515_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::ProcessHistory::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_515_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_515_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::ProcessHistory::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProductID(void) {
   /* edm::ProductID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID));
   // automatic default constructor
   G__memfunc_setup("ProductID", 878, G__MiniFWLiteDict_516_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProductID", 878, G__MiniFWLiteDict_516_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID), -1, 0, 1, 1, 1, 0, "u 'edm::ProductID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProductID", 1004, G__MiniFWLiteDict_516_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_516_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductID), -1, 1, 1, 1, 1, 0, "u 'edm::ProductID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLStoredProductProvenance(void) {
   /* edm::StoredProductProvenance */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance));
   // automatic default constructor
   G__memfunc_setup("StoredProductProvenance", 2403, G__MiniFWLiteDict_517_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("StoredProductProvenance", 2403, G__MiniFWLiteDict_517_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance), -1, 0, 1, 1, 1, 0, "u 'edm::StoredProductProvenance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~StoredProductProvenance", 2529, G__MiniFWLiteDict_517_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_517_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance), -1, 1, 1, 1, 1, 0, "u 'edm::StoredProductProvenance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProductProvenance(void) {
   /* edm::ProductProvenance */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance));
   // automatic default constructor
   G__memfunc_setup("ProductProvenance", 1778, G__MiniFWLiteDict_519_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProductProvenance", 1778, G__MiniFWLiteDict_519_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance), -1, 0, 1, 1, 1, 0, "u 'edm::ProductProvenance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProductProvenance", 1904, G__MiniFWLiteDict_519_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_519_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductProvenance), -1, 1, 1, 1, 1, 0, "u 'edm::ProductProvenance' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProductRegistry(void) {
   /* edm::ProductRegistry */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry));
   // automatic default constructor
   G__memfunc_setup("ProductRegistry", 1594, G__MiniFWLiteDict_521_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("ProductRegistry", 1594, G__MiniFWLiteDict_521_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry), -1, 0, 1, 1, 1, 0, "u 'edm::ProductRegistry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~ProductRegistry", 1720, G__MiniFWLiteDict_521_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_521_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistry), -1, 1, 1, 1, 1, 0, "u 'edm::ProductRegistry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLProductRegistrycLcLTransients(void) {
   /* edm::ProductRegistry::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_522_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_522_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::ProductRegistry::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_522_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_522_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::ProductRegistry::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLRunID(void) {
   /* edm::RunID */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID));
   // automatic default constructor
   G__memfunc_setup("RunID", 450, G__MiniFWLiteDict_523_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RunID", 450, G__MiniFWLiteDict_523_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID), -1, 0, 1, 1, 1, 0, "u 'edm::RunID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RunID", 576, G__MiniFWLiteDict_523_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_523_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLRunID), -1, 1, 1, 1, 1, 0, "u 'edm::RunID' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTimestamp(void) {
   /* edm::Timestamp */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp));
   // automatic default constructor
   G__memfunc_setup("Timestamp", 948, G__MiniFWLiteDict_524_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Timestamp", 948, G__MiniFWLiteDict_524_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp), -1, 0, 1, 1, 1, 0, "u 'edm::Timestamp' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Timestamp", 1074, G__MiniFWLiteDict_524_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_524_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTimestamp), -1, 1, 1, 1, 1, 0, "u 'edm::Timestamp' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLIndexIntoFile(void) {
   /* edm::IndexIntoFile */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile));
   // automatic default constructor
   G__memfunc_setup("IndexIntoFile", 1298, G__MiniFWLiteDict_525_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("IndexIntoFile", 1298, G__MiniFWLiteDict_525_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile), -1, 0, 1, 1, 1, 0, "u 'edm::IndexIntoFile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~IndexIntoFile", 1424, G__MiniFWLiteDict_525_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_525_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile), -1, 1, 1, 1, 1, 0, "u 'edm::IndexIntoFile' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLIndexIntoFilecLcLTransients(void) {
   /* edm::IndexIntoFile::Transients */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients));
   // automatic default constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_526_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transients", 1067, G__MiniFWLiteDict_526_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients), -1, 0, 1, 1, 1, 0, "u 'edm::IndexIntoFile::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transients", 1193, G__MiniFWLiteDict_526_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_526_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients), -1, 1, 1, 1, 1, 0, "u 'edm::IndexIntoFile::Transients' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLIndexIntoFilecLcLRunOrLumiEntry(void) {
   /* edm::IndexIntoFile::RunOrLumiEntry */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry));
   // automatic default constructor
   G__memfunc_setup("RunOrLumiEntry", 1439, G__MiniFWLiteDict_527_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("RunOrLumiEntry", 1439, G__MiniFWLiteDict_527_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry), -1, 0, 1, 1, 1, 0, "u 'edm::IndexIntoFile::RunOrLumiEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~RunOrLumiEntry", 1565, G__MiniFWLiteDict_527_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_527_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry), -1, 1, 1, 1, 1, 0, "u 'edm::IndexIntoFile::RunOrLumiEntry' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLPxPyPzE4DlEfloatgR(void) {
   /* ROOT::Math::PxPyPzE4D<float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR));
   G__memfunc_setup("PxPyPzE4D<float>",1448,G__MiniFWLiteDict_528_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PxPyPzE4D<float>",1448,G__MiniFWLiteDict_528_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 0, 4, 1, 1, 0, 
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - px f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - py "
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - pz f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PxPyPzE4D<float>",1448,G__MiniFWLiteDict_528_0_3, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::PxPyPzE4D<float>' - 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_528_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::PxPyPzE4D<float>' - 11 - v", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_528_0_5, 121, -1, -1, 0, 1, 1, 1, 0, "F - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 10 - src", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_528_0_6, 121, -1, -1, 0, 1, 1, 1, 8, "F - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - dest", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_528_0_7, 121, -1, -1, 0, 4, 1, 1, 0, 
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - px f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - py "
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - pz f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_528_0_8, 121, -1, -1, 0, 4, 1, 1, 8, 
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 1 - px f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 1 - py "
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 1 - pz f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 1 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Px",200,G__MiniFWLiteDict_528_0_9, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Py",201,G__MiniFWLiteDict_528_0_10, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pz",202,G__MiniFWLiteDict_528_0_11, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("E",69,G__MiniFWLiteDict_528_0_12, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__MiniFWLiteDict_528_0_13, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Y",89,G__MiniFWLiteDict_528_0_14, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Z",90,G__MiniFWLiteDict_528_0_15, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("T",84,G__MiniFWLiteDict_528_0_16, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("P2",130,G__MiniFWLiteDict_528_0_17, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("P",80,G__MiniFWLiteDict_528_0_18, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("R",82,G__MiniFWLiteDict_528_0_19, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("M2",127,G__MiniFWLiteDict_528_0_20, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mag2",327,G__MiniFWLiteDict_528_0_21, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("M",77,G__MiniFWLiteDict_528_0_22, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mag",277,G__MiniFWLiteDict_528_0_23, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pt2",246,G__MiniFWLiteDict_528_0_24, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Perp2",457,G__MiniFWLiteDict_528_0_25, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pt",196,G__MiniFWLiteDict_528_0_26, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Perp",407,G__MiniFWLiteDict_528_0_27, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rho",297,G__MiniFWLiteDict_528_0_28, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mt2",243,G__MiniFWLiteDict_528_0_29, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mt",193,G__MiniFWLiteDict_528_0_30, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Et2",235,G__MiniFWLiteDict_528_0_31, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Et",185,G__MiniFWLiteDict_528_0_32, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Phi",289,G__MiniFWLiteDict_528_0_33, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Theta",502,G__MiniFWLiteDict_528_0_34, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eta",282,G__MiniFWLiteDict_528_0_35, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPx",500,G__MiniFWLiteDict_528_0_36, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - px", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPy",501,G__MiniFWLiteDict_528_0_37, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - py", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPz",502,G__MiniFWLiteDict_528_0_38, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - pz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetE",369,G__MiniFWLiteDict_528_0_39, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPxPyPzE",972,G__MiniFWLiteDict_528_0_40, 121, -1, -1, 0, 4, 1, 1, 0, 
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - px f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - py "
"f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - pz f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - e", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Negate",596,G__MiniFWLiteDict_528_0_41, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Scale",488,G__MiniFWLiteDict_528_0_42, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 11 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__MiniFWLiteDict_528_0_43, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::PxPyPzE4D<float>' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__MiniFWLiteDict_528_0_44, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::PxPyPzE4D<float>' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("x",120,G__MiniFWLiteDict_528_0_45, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("y",121,G__MiniFWLiteDict_528_0_46, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("z",122,G__MiniFWLiteDict_528_0_47, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("t",116,G__MiniFWLiteDict_528_0_48, 102, -1, G__defined_typename("ROOT::Math::PxPyPzE4D<float>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPt",496,G__MiniFWLiteDict_528_0_49, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - pt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetEta",582,G__MiniFWLiteDict_528_0_50, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - eta", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPhi",589,G__MiniFWLiteDict_528_0_51, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - phi", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetM",377,G__MiniFWLiteDict_528_0_52, 121, -1, -1, 0, 1, 1, 1, 0, "f - 'ROOT::Math::PxPyPzE4D<float>::Scalar' 0 - m", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PxPyPzE4D<float>", 1574, G__MiniFWLiteDict_528_0_53, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR(void) {
   /* ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR));
   G__memfunc_setup("LorentzVector<ROOT::Math::PxPyPzE4D<float> >",3929,G__MiniFWLiteDict_529_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 0, 5, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("LorentzVector<ROOT::Math::PxPyPzE4D<float> >",3929,G__MiniFWLiteDict_529_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 4, 1, 1, 0, 
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - a f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - b "
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - c f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Coordinates",1147,G__MiniFWLiteDict_529_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_529_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "F - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 10 - src", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_529_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 4, 1, 1, 0, 
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - b "
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - c f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_529_0_6, 121, -1, -1, 0, 4, 1, 1, 8, 
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 1 - a f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 1 - b "
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 1 - c f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 1 - d", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_529_0_7, 121, -1, -1, 0, 1, 1, 1, 8, "F - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - dest", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetXYZT",651,G__MiniFWLiteDict_529_0_8, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 4, 1, 1, 0, 
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - xx f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - yy "
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - zz f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - tt", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPxPyPzE",972,G__MiniFWLiteDict_529_0_9, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 4, 1, 1, 0, 
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - xx f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - yy "
"f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - zz f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - ee", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__MiniFWLiteDict_529_0_10, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__MiniFWLiteDict_529_0_11, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Px",200,G__MiniFWLiteDict_529_0_12, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__MiniFWLiteDict_529_0_13, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Py",201,G__MiniFWLiteDict_529_0_14, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Y",89,G__MiniFWLiteDict_529_0_15, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pz",202,G__MiniFWLiteDict_529_0_16, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Z",90,G__MiniFWLiteDict_529_0_17, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("E",69,G__MiniFWLiteDict_529_0_18, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("T",84,G__MiniFWLiteDict_529_0_19, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("M2",127,G__MiniFWLiteDict_529_0_20, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("M",77,G__MiniFWLiteDict_529_0_21, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("R",82,G__MiniFWLiteDict_529_0_22, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("P",80,G__MiniFWLiteDict_529_0_23, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("P2",130,G__MiniFWLiteDict_529_0_24, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Perp2",457,G__MiniFWLiteDict_529_0_25, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Pt",196,G__MiniFWLiteDict_529_0_26, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rho",297,G__MiniFWLiteDict_529_0_27, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mt2",243,G__MiniFWLiteDict_529_0_28, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mt",193,G__MiniFWLiteDict_529_0_29, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Et2",235,G__MiniFWLiteDict_529_0_30, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Et",185,G__MiniFWLiteDict_529_0_31, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Phi",289,G__MiniFWLiteDict_529_0_32, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Theta",502,G__MiniFWLiteDict_529_0_33, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eta",282,G__MiniFWLiteDict_529_0_34, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Vect",402,G__MiniFWLiteDict_529_0_35, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 5, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*=",979,G__MiniFWLiteDict_529_0_36, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator/=",984,G__MiniFWLiteDict_529_0_37, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__MiniFWLiteDict_529_0_38, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 1, 1, 1, 8, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator/",923,G__MiniFWLiteDict_529_0_39, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 1, 1, 1, 8, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 11 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator-",921,G__MiniFWLiteDict_529_0_40, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator+",919,G__MiniFWLiteDict_529_0_41, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rapidity",838,G__MiniFWLiteDict_529_0_42, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("ColinearRapidity",1651,G__MiniFWLiteDict_529_0_43, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isTimelike",1040,G__MiniFWLiteDict_529_0_44, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isLightlike",1145,G__MiniFWLiteDict_529_0_45, 103, -1, -1, 0, 1, 1, 1, 8, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 '100*std::numeric_limits<Scalar>::epsilon()' tolerance", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("isSpacelike",1133,G__MiniFWLiteDict_529_0_46, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("BoostToCM",858,G__MiniFWLiteDict_529_0_47, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::BetaVector"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Beta",380,G__MiniFWLiteDict_529_0_48, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Gamma",483,G__MiniFWLiteDict_529_0_49, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("x",120,G__MiniFWLiteDict_529_0_50, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("y",121,G__MiniFWLiteDict_529_0_51, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("z",122,G__MiniFWLiteDict_529_0_52, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("t",116,G__MiniFWLiteDict_529_0_53, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("px",232,G__MiniFWLiteDict_529_0_54, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("py",233,G__MiniFWLiteDict_529_0_55, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pz",234,G__MiniFWLiteDict_529_0_56, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("e",101,G__MiniFWLiteDict_529_0_57, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("r",114,G__MiniFWLiteDict_529_0_58, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("theta",534,G__MiniFWLiteDict_529_0_59, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("phi",321,G__MiniFWLiteDict_529_0_60, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rho",329,G__MiniFWLiteDict_529_0_61, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("eta",314,G__MiniFWLiteDict_529_0_62, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pt",228,G__MiniFWLiteDict_529_0_63, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("perp2",489,G__MiniFWLiteDict_529_0_64, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mag2",359,G__MiniFWLiteDict_529_0_65, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mag",309,G__MiniFWLiteDict_529_0_66, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mt",225,G__MiniFWLiteDict_529_0_67, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mt2",275,G__MiniFWLiteDict_529_0_68, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("energy",650,G__MiniFWLiteDict_529_0_69, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mass",436,G__MiniFWLiteDict_529_0_70, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mass2",486,G__MiniFWLiteDict_529_0_71, 102, -1, G__defined_typename("ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetE",369,G__MiniFWLiteDict_529_0_72, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetEta",582,G__MiniFWLiteDict_529_0_73, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetM",377,G__MiniFWLiteDict_529_0_74, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPhi",589,G__MiniFWLiteDict_529_0_75, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPt",496,G__MiniFWLiteDict_529_0_76, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPx",500,G__MiniFWLiteDict_529_0_77, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPy",501,G__MiniFWLiteDict_529_0_78, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPz",502,G__MiniFWLiteDict_529_0_79, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("LorentzVector<ROOT::Math::PxPyPzE4D<float> >", 3929, G__MiniFWLiteDict_529_0_80, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~LorentzVector<ROOT::Math::PxPyPzE4D<float> >", 4055, G__MiniFWLiteDict_529_0_81, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_529_0_82, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR(void) {
   /* ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR));
   G__memfunc_setup("PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>",8032,G__MiniFWLiteDict_532_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 5, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>",8032,G__MiniFWLiteDict_532_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 3, 1, 1, 0, 
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 11 - a f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 11 - b "
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 11 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Coordinates",1147,G__MiniFWLiteDict_532_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR), -1, 1, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_532_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "F - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 10 - src", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetCoordinates",1447,G__MiniFWLiteDict_532_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 3, 1, 1, 0, 
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - b "
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_532_0_6, 121, -1, -1, 0, 3, 1, 1, 8, 
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 1 - a f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 1 - b "
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 1 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("GetCoordinates",1435,G__MiniFWLiteDict_532_0_7, 121, -1, -1, 0, 1, 1, 1, 8, "F - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - dest", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetXYZ",567,G__MiniFWLiteDict_532_0_8, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 3, 1, 1, 0, 
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - b "
"f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator==",998,G__MiniFWLiteDict_532_0_9, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator!=",970,G__MiniFWLiteDict_532_0_10, 103, -1, -1, 0, 1, 1, 1, 8, "u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - rhs", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("X",88,G__MiniFWLiteDict_532_0_11, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Y",89,G__MiniFWLiteDict_532_0_12, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Z",90,G__MiniFWLiteDict_532_0_13, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("R",82,G__MiniFWLiteDict_532_0_14, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Theta",502,G__MiniFWLiteDict_532_0_15, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Phi",289,G__MiniFWLiteDict_532_0_16, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Eta",282,G__MiniFWLiteDict_532_0_17, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Rho",297,G__MiniFWLiteDict_532_0_18, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Mag2",327,G__MiniFWLiteDict_532_0_19, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("Perp2",457,G__MiniFWLiteDict_532_0_20, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetX",388,G__MiniFWLiteDict_532_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - xx", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetY",389,G__MiniFWLiteDict_532_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - yy", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetZ",390,G__MiniFWLiteDict_532_0_23, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - zz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetR",382,G__MiniFWLiteDict_532_0_24, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - rr", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetTheta",802,G__MiniFWLiteDict_532_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - ang", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetPhi",589,G__MiniFWLiteDict_532_0_26, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - ang", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetRho",597,G__MiniFWLiteDict_532_0_27, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - rr", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("SetEta",582,G__MiniFWLiteDict_532_0_28, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - etaval", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*=",979,G__MiniFWLiteDict_532_0_29, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator/=",984,G__MiniFWLiteDict_532_0_30, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator*",918,G__MiniFWLiteDict_532_0_31, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 1, 1, 1, 8, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator/",923,G__MiniFWLiteDict_532_0_32, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 1, 1, 1, 8, "f - 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar' 0 - a", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("x",120,G__MiniFWLiteDict_532_0_33, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("y",121,G__MiniFWLiteDict_532_0_34, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("z",122,G__MiniFWLiteDict_532_0_35, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("r",114,G__MiniFWLiteDict_532_0_36, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("theta",534,G__MiniFWLiteDict_532_0_37, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("phi",321,G__MiniFWLiteDict_532_0_38, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("eta",314,G__MiniFWLiteDict_532_0_39, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rho",329,G__MiniFWLiteDict_532_0_40, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("mag2",359,G__MiniFWLiteDict_532_0_41, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("perp2",489,G__MiniFWLiteDict_532_0_42, 102, -1, G__defined_typename("ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>", 8032, G__MiniFWLiteDict_532_0_43, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>", 8158, G__MiniFWLiteDict_532_0_44, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_532_0_45, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 1, 1, 1, 0, "u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void) {
   /* vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_534_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_534_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_534_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_534_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_534_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_534_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_534_0_7, 107, -1, G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_534_0_8, 107, -1, G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_534_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_534_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - sz u 'ROOT::Math::PxPyPzE4D<float>' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_534_0_11, 107, -1, G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_534_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_534_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_534_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), G__defined_typename("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >",6768,G__MiniFWLiteDict_534_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >",6768,G__MiniFWLiteDict_534_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n u 'ROOT::Math::PxPyPzE4D<float>' - 11 '(ROOT::Math::PxPyPzE4D<float>)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >",6768,G__MiniFWLiteDict_534_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >",6768,G__MiniFWLiteDict_534_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator' 10 - first u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_534_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_534_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_534_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_534_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_534_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::PxPyPzE4D<float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_534_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_534_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - position u 'ROOT::Math::PxPyPzE4D<float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_534_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - position u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator' 10 - first "
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_534_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - position k - 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::size_type' 0 - n "
"u 'ROOT::Math::PxPyPzE4D<float>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_534_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_534_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_534_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - first u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_534_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >", 6894, G__MiniFWLiteDict_534_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR(void) {
   /* vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_538_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_538_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_538_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_538_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_538_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_538_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_538_0_7, 107, -1, G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_538_0_8, 107, -1, G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_538_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_538_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - sz u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_538_0_11, 107, -1, G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_538_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_538_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_538_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), G__defined_typename("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",11730,G__MiniFWLiteDict_538_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",11730,G__MiniFWLiteDict_538_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 '(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",11730,G__MiniFWLiteDict_538_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >",11730,G__MiniFWLiteDict_538_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator' 10 - first u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_538_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_538_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_538_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_538_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_538_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_538_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_538_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - position u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_538_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - position u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator' 10 - first "
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_538_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - position k - 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::size_type' 0 - n "
"u 'ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_538_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_538_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_538_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - first u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_538_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >", 11856, G__MiniFWLiteDict_538_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR(void) {
   /* vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_542_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_542_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_542_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_542_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_542_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_542_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_542_0_7, 107, -1, G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_542_0_8, 107, -1, G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_542_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_542_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - sz u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_542_0_11, 107, -1, G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_542_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_542_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_542_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), G__defined_typename("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",19936,G__MiniFWLiteDict_542_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",19936,G__MiniFWLiteDict_542_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 '(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",19936,G__MiniFWLiteDict_542_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >",19936,G__MiniFWLiteDict_542_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator' 10 - first u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_542_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_542_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_542_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_542_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_542_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_542_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_542_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - position u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_542_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - position u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator' 10 - first "
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_542_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - position k - 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::size_type' 0 - n "
"u 'ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_542_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_542_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_542_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - first u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_542_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >", 20062, G__MiniFWLiteDict_542_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void) {
   /* vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_546_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_546_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_546_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_546_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_546_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_546_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_546_0_7, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_546_0_8, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_546_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_546_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - sz u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_546_0_11, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_546_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_546_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_546_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >",15508,G__MiniFWLiteDict_546_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >",15508,G__MiniFWLiteDict_546_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 '(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >",15508,G__MiniFWLiteDict_546_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >",15508,G__MiniFWLiteDict_546_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator' 10 - first u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_546_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_546_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_546_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_546_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_546_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_546_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_546_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - position u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_546_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - position u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator' 10 - first "
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_546_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - position k - 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::size_type' 0 - n "
"u 'vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_546_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_546_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_546_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - first u 'vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_546_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >", 15634, G__MiniFWLiteDict_546_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR(void) {
   /* vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_550_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_550_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_550_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_550_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_550_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_550_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_550_0_7, 107, -1, G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_550_0_8, 107, -1, G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_550_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_550_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - sz u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_550_0_11, 107, -1, G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_550_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_550_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_550_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >",25432,G__MiniFWLiteDict_550_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >",25432,G__MiniFWLiteDict_550_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 '(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >",25432,G__MiniFWLiteDict_550_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >",25432,G__MiniFWLiteDict_550_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator' 10 - first u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_550_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_550_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_550_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_550_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_550_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_550_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_550_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - position u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_550_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - position u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator' 10 - first "
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_550_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - position k - 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::size_type' 0 - n "
"u 'vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_550_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_550_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_550_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - first u 'vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_550_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >", 25558, G__MiniFWLiteDict_550_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR(void) {
   /* vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("at",213,G__MiniFWLiteDict_554_0_1, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("at",213,G__MiniFWLiteDict_554_0_2, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_554_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_554_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_554_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_554_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reverse_iterator"), 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_554_0_7, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_554_0_8, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_554_0_9, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - sz", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("resize",658,G__MiniFWLiteDict_554_0_10, 121, -1, -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - sz u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 0 - c", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("capacity",846,G__MiniFWLiteDict_554_0_11, 107, -1, G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_554_0_12, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_554_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::reference"), 1, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_554_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), G__defined_typename("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_reference"), 1, 1, 1, 1, 8, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >",41844,G__MiniFWLiteDict_554_0_15, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >",41844,G__MiniFWLiteDict_554_0_16, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 '(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >)()' value", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >",41844,G__MiniFWLiteDict_554_0_17, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >",41844,G__MiniFWLiteDict_554_0_18, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator' 10 - first u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_554_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("reserve",764,G__MiniFWLiteDict_554_0_20, 121, -1, -1, 0, 1, 1, 1, 0, "k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("front",553,G__MiniFWLiteDict_554_0_21, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("back",401,G__MiniFWLiteDict_554_0_22, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 1, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("push_back",944,G__MiniFWLiteDict_554_0_23, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_554_0_24, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >' - 1 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_554_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - position u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_554_0_26, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - position u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator' 10 - first "
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::const_iterator' 10 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_554_0_27, 121, -1, -1, 0, 3, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - position k - 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::size_type' 0 - n "
"u 'vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pop_back",831,G__MiniFWLiteDict_554_0_28, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_554_0_29, 121, -1, -1, 0, 1, 1, 1, 0, "u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_554_0_30, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - first u 'vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_554_0_31, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >", 41970, G__MiniFWLiteDict_554_0_32, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlETStringgR(void) {
   /* edm::Wrapper<TString> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR));
   G__memfunc_setup("Wrapper<TString>",1574,G__MiniFWLiteDict_557_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_557_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_557_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_TString), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_557_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<TString>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_557_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<TString>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<TString>",1574,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<TString>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<TString>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<TString>", 1700, G__MiniFWLiteDict_557_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEdoublegR(void) {
   /* edm::Wrapper<double> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR));
   G__memfunc_setup("Wrapper<double>",1494,G__MiniFWLiteDict_558_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_558_0_2, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_558_0_3, 68, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_558_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<double>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_558_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<double>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<double>",1494,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<double>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<double>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<double>", 1620, G__MiniFWLiteDict_558_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEfloatgR(void) {
   /* edm::Wrapper<float> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR));
   G__memfunc_setup("Wrapper<float>",1393,G__MiniFWLiteDict_559_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_559_0_2, 70, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_559_0_3, 70, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_559_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<float>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_559_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<float>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<float>",1393,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<float>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<float>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<float>", 1519, G__MiniFWLiteDict_559_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEintgR(void) {
   /* edm::Wrapper<int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR));
   G__memfunc_setup("Wrapper<int>",1190,G__MiniFWLiteDict_560_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_560_0_2, 73, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_560_0_3, 73, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_560_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<int>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_560_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<int>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<int>",1190,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<int>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<int>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<int>", 1316, G__MiniFWLiteDict_560_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEunsignedsPintgR(void) {
   /* edm::Wrapper<unsigned int> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR));
   G__memfunc_setup("Wrapper<unsigned int>",2083,G__MiniFWLiteDict_561_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_561_0_2, 72, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_561_0_3, 72, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_561_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<unsigned int>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_561_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<unsigned int>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<unsigned int>",2083,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<unsigned int>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<unsigned int>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<unsigned int>", 2209, G__MiniFWLiteDict_561_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR(void) {
   /* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR));
   G__memfunc_setup("Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >",5871,G__MiniFWLiteDict_566_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR), -1, 0, 0, 5, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_566_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_566_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_566_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_566_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >",5871,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >", 5997, G__MiniFWLiteDict_566_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR(void) {
   /* edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR));
   G__memfunc_setup("Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >",5770,G__MiniFWLiteDict_567_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_567_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_567_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_567_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_567_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >",5770,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >", 5896, G__MiniFWLiteDict_567_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void) {
   /* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   G__memfunc_setup("Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >",9974,G__MiniFWLiteDict_569_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 0, 0, 5, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_569_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_569_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_569_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_569_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >",9974,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >", 10100, G__MiniFWLiteDict_569_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR(void) {
   /* edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR));
   G__memfunc_setup("Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >",9873,G__MiniFWLiteDict_570_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_570_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_570_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_570_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_570_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >",9873,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >", 9999, G__MiniFWLiteDict_570_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<TString,allocator<TString> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<TString,allocator<TString> > >",4261,G__MiniFWLiteDict_575_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_575_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_575_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_575_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<TString,allocator<TString> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_575_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<TString,allocator<TString> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<TString,allocator<TString> > >",4261,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<TString,allocator<TString> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<TString,allocator<TString> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<TString,allocator<TString> > >", 4387, G__MiniFWLiteDict_575_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR(void) {
   /* edm::Wrapper<vector<double,allocator<double> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<double,allocator<double> > >",4101,G__MiniFWLiteDict_576_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_576_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_576_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_576_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<double,allocator<double> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_576_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<double,allocator<double> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<double,allocator<double> > >",4101,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<double,allocator<double> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<double,allocator<double> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<double,allocator<double> > >", 4227, G__MiniFWLiteDict_576_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<float,allocator<float> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<float,allocator<float> > >",3899,G__MiniFWLiteDict_577_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_577_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_577_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_577_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<float,allocator<float> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_577_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<float,allocator<float> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<float,allocator<float> > >",3899,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<float,allocator<float> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<float,allocator<float> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<float,allocator<float> > >", 4025, G__MiniFWLiteDict_577_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<int,allocator<int> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<int,allocator<int> > >",3493,G__MiniFWLiteDict_581_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_581_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_581_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_581_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<int,allocator<int> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_581_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<int,allocator<int> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<int,allocator<int> > >",3493,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<int,allocator<int> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<int,allocator<int> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<int,allocator<int> > >", 3619, G__MiniFWLiteDict_581_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<unsigned int,allocator<unsigned int> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<unsigned int,allocator<unsigned int> > >",5279,G__MiniFWLiteDict_582_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_582_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_582_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_582_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_582_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<unsigned int,allocator<unsigned int> > >",5279,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<unsigned int,allocator<unsigned int> > >", 5405, G__MiniFWLiteDict_582_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >",12823,G__MiniFWLiteDict_587_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_587_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_587_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_587_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_587_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >",12823,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >", 12949, G__MiniFWLiteDict_587_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >",12621,G__MiniFWLiteDict_588_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_588_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_588_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_588_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_588_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >",12621,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >", 12747, G__MiniFWLiteDict_588_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >",21029,G__MiniFWLiteDict_593_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_593_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_593_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_593_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_593_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >",21029,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >", 21155, G__MiniFWLiteDict_593_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >",20827,G__MiniFWLiteDict_594_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_594_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_594_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_594_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_594_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >",20827,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >", 20953, G__MiniFWLiteDict_594_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >",9603,G__MiniFWLiteDict_599_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_599_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_599_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_599_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_599_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >",9603,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >", 9729, G__MiniFWLiteDict_599_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >",9283,G__MiniFWLiteDict_604_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_604_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_604_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_604_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_604_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >",9283,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >", 9409, G__MiniFWLiteDict_604_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >",8879,G__MiniFWLiteDict_609_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_609_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_609_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_609_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_609_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >",8879,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >", 9005, G__MiniFWLiteDict_609_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >",8067,G__MiniFWLiteDict_614_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_614_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_614_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_614_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_614_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >",8067,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >", 8193, G__MiniFWLiteDict_614_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >",11639,G__MiniFWLiteDict_619_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_619_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_619_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_619_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_619_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >",11639,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >", 11765, G__MiniFWLiteDict_619_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >",26727,G__MiniFWLiteDict_624_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_624_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_624_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_624_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_624_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >",26727,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >", 26853, G__MiniFWLiteDict_624_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >",26323,G__MiniFWLiteDict_625_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_625_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_625_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_625_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_625_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >",26323,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >", 26449, G__MiniFWLiteDict_625_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >",43139,G__MiniFWLiteDict_630_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_630_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_630_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_630_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_630_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >",43139,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >", 43265, G__MiniFWLiteDict_630_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >",42735,G__MiniFWLiteDict_631_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_631_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_631_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_631_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_631_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >",42735,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >", 42861, G__MiniFWLiteDict_631_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE0gR(void) {
   /* edm::Hash<0> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR));
   // automatic default constructor
   G__memfunc_setup("Hash<0>", 558, G__MiniFWLiteDict_632_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<0>", 558, G__MiniFWLiteDict_632_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<0>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<0>", 684, G__MiniFWLiteDict_632_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_632_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<0>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE1gR(void) {
   /* edm::Hash<1> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR));
   // automatic default constructor
   G__memfunc_setup("Hash<1>", 559, G__MiniFWLiteDict_633_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<1>", 559, G__MiniFWLiteDict_633_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<1>", 685, G__MiniFWLiteDict_633_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_633_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<1>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE2gR(void) {
   /* edm::Hash<2> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR));
   // automatic default constructor
   G__memfunc_setup("Hash<2>", 560, G__MiniFWLiteDict_634_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<2>", 560, G__MiniFWLiteDict_634_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<2>", 686, G__MiniFWLiteDict_634_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_634_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<2>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE3gR(void) {
   /* edm::Hash<3> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR));
   // automatic default constructor
   G__memfunc_setup("Hash<3>", 561, G__MiniFWLiteDict_635_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<3>", 561, G__MiniFWLiteDict_635_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<3>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<3>", 687, G__MiniFWLiteDict_635_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_635_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<3>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE4gR(void) {
   /* edm::Hash<4> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR));
   // automatic default constructor
   G__memfunc_setup("Hash<4>", 562, G__MiniFWLiteDict_636_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<4>", 562, G__MiniFWLiteDict_636_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<4>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<4>", 688, G__MiniFWLiteDict_636_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_636_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<4>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLHashlE5gR(void) {
   /* edm::Hash<5> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR));
   // automatic default constructor
   G__memfunc_setup("Hash<5>", 563, G__MiniFWLiteDict_637_0_1, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Hash<5>", 563, G__MiniFWLiteDict_637_0_2, (int) ('i'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR), -1, 0, 1, 1, 1, 0, "u 'edm::Hash<5>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Hash<5>", 689, G__MiniFWLiteDict_637_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_637_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR), -1, 1, 1, 1, 1, 0, "u 'edm::Hash<5>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR(void) {
   /* edm::Transient<edm::BranchDescription::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::BranchDescription::Transients>", 4429, G__MiniFWLiteDict_638_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::BranchDescription::Transients>", 4429, G__MiniFWLiteDict_638_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::BranchDescription::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::BranchDescription::Transients>", 4555, G__MiniFWLiteDict_638_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_638_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::BranchDescription::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR(void) {
   /* edm::Transient<edm::EventEntryDescription::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::EventEntryDescription::Transients>", 4883, G__MiniFWLiteDict_639_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::EventEntryDescription::Transients>", 4883, G__MiniFWLiteDict_639_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::EventEntryDescription::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::EventEntryDescription::Transients>", 5009, G__MiniFWLiteDict_639_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_639_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::EventEntryDescription::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR(void) {
   /* edm::Transient<edm::EventEntryInfo::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::EventEntryInfo::Transients>", 4123, G__MiniFWLiteDict_640_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::EventEntryInfo::Transients>", 4123, G__MiniFWLiteDict_640_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::EventEntryInfo::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::EventEntryInfo::Transients>", 4249, G__MiniFWLiteDict_640_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_640_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::EventEntryInfo::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR(void) {
   /* edm::Transient<edm::FileIndex::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::FileIndex::Transients>", 3571, G__MiniFWLiteDict_641_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::FileIndex::Transients>", 3571, G__MiniFWLiteDict_641_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::FileIndex::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::FileIndex::Transients>", 3697, G__MiniFWLiteDict_641_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_641_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::FileIndex::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLParentagecLcLTransientsgR(void) {
   /* edm::Transient<edm::Parentage::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::Parentage::Transients>", 3602, G__MiniFWLiteDict_642_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::Parentage::Transients>", 3602, G__MiniFWLiteDict_642_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::Parentage::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::Parentage::Transients>", 3728, G__MiniFWLiteDict_642_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_642_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::Parentage::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR(void) {
   /* edm::Transient<edm::ProcessConfiguration::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::ProcessConfiguration::Transients>", 4786, G__MiniFWLiteDict_643_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::ProcessConfiguration::Transients>", 4786, G__MiniFWLiteDict_643_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::ProcessConfiguration::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::ProcessConfiguration::Transients>", 4912, G__MiniFWLiteDict_643_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_643_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::ProcessConfiguration::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR(void) {
   /* edm::Transient<edm::ProcessHistory::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::ProcessHistory::Transients>", 4172, G__MiniFWLiteDict_644_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::ProcessHistory::Transients>", 4172, G__MiniFWLiteDict_644_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::ProcessHistory::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::ProcessHistory::Transients>", 4298, G__MiniFWLiteDict_644_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_644_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::ProcessHistory::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR(void) {
   /* edm::Transient<edm::ProductProvenance::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::ProductProvenance::Transients>", 4461, G__MiniFWLiteDict_645_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::ProductProvenance::Transients>", 4461, G__MiniFWLiteDict_645_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::ProductProvenance::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::ProductProvenance::Transients>", 4587, G__MiniFWLiteDict_645_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_645_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::ProductProvenance::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR(void) {
   /* edm::Transient<edm::ProductRegistry::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::ProductRegistry::Transients>", 4277, G__MiniFWLiteDict_646_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::ProductRegistry::Transients>", 4277, G__MiniFWLiteDict_646_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::ProductRegistry::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::ProductRegistry::Transients>", 4403, G__MiniFWLiteDict_646_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_646_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::ProductRegistry::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR(void) {
   /* edm::Transient<edm::IndexIntoFile::Transients> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR));
   // automatic default constructor
   G__memfunc_setup("Transient<edm::IndexIntoFile::Transients>", 3981, G__MiniFWLiteDict_647_0_1, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR), -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("Transient<edm::IndexIntoFile::Transients>", 3981, G__MiniFWLiteDict_647_0_2, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR), -1, 0, 1, 1, 1, 0, "u 'edm::Transient<edm::IndexIntoFile::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Transient<edm::IndexIntoFile::Transients>", 4107, G__MiniFWLiteDict_647_0_3, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   // automatic assignment operator
   G__memfunc_setup("operator=", 937, G__MiniFWLiteDict_647_0_4, (int) ('u'), G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR), -1, 1, 1, 1, 1, 0, "u 'edm::Transient<edm::IndexIntoFile::Transients>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR(void) {
   /* pair<edm::BranchKey,edm::BranchDescription> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR));
   G__memfunc_setup("pair<edm::BranchKey,edm::BranchDescription>",4079,G__MiniFWLiteDict_648_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<edm::BranchKey,edm::BranchDescription>",4079,G__MiniFWLiteDict_648_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR), -1, 0, 2, 1, 1, 0, 
"u 'edm::BranchKey' - 11 - a u 'edm::BranchDescription' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR), -1, 1, 1, 1, 4, 0, "u 'pair<edm::BranchKey,edm::BranchDescription>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<edm::BranchKey,edm::BranchDescription>", 4079, G__MiniFWLiteDict_648_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR), -1, 0, 1, 1, 1, 0, "u 'pair<edm::BranchKey,edm::BranchDescription>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<edm::BranchKey,edm::BranchDescription>", 4205, G__MiniFWLiteDict_648_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR(void) {
   /* pair<edm::Hash<1>,edm::ParameterSetBlob> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR));
   G__memfunc_setup("pair<edm::Hash<1>,edm::ParameterSetBlob>",3617,G__MiniFWLiteDict_649_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<edm::Hash<1>,edm::ParameterSetBlob>",3617,G__MiniFWLiteDict_649_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR), -1, 0, 2, 1, 1, 0, 
"u 'edm::Hash<1>' - 11 - a u 'edm::ParameterSetBlob' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR), -1, 1, 1, 1, 4, 0, "u 'pair<edm::Hash<1>,edm::ParameterSetBlob>' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<edm::Hash<1>,edm::ParameterSetBlob>", 3617, G__MiniFWLiteDict_649_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR), -1, 0, 1, 1, 1, 0, "u 'pair<edm::Hash<1>,edm::ParameterSetBlob>' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<edm::Hash<1>,edm::ParameterSetBlob>", 3743, G__MiniFWLiteDict_649_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEboolgR(void) {
   /* edm::Wrapper<bool> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR));
   G__memfunc_setup("Wrapper<bool>",1287,G__MiniFWLiteDict_650_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_650_0_2, 71, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_650_0_3, 71, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_650_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<bool>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_650_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<bool>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<bool>",1287,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<bool>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<bool>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<bool>", 1413, G__MiniFWLiteDict_650_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR(void) {
   /* edm::Wrapper<vector<bool,allocator<bool> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR));
   G__memfunc_setup("Wrapper<vector<bool,allocator<bool> > >",3687,G__MiniFWLiteDict_651_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_651_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_651_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_651_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<bool,allocator<bool> > >::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_651_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<vector<bool,allocator<bool> > >::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<vector<bool,allocator<bool> > >",3687,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<vector<bool,allocator<bool> > >' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<vector<bool,allocator<bool> > >' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<vector<bool,allocator<bool> > >", 3813, G__MiniFWLiteDict_651_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlEunsignedsPlongsPlonggR(void) {
   /* edm::Wrapper<unsigned long long> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR));
   G__memfunc_setup("Wrapper<unsigned long long>",2648,G__MiniFWLiteDict_652_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_652_0_2, 77, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_652_0_3, 77, -1, -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_652_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<unsigned long long>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_652_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<unsigned long long>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<unsigned long long>",2648,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<unsigned long long>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<unsigned long long>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<unsigned long long>", 2774, G__MiniFWLiteDict_652_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncedmcLcLWrapperlETBitsgR(void) {
   /* edm::Wrapper<TBits> */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR));
   G__memfunc_setup("Wrapper<TBits>",1345,G__MiniFWLiteDict_653_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("product",769,G__MiniFWLiteDict_653_0_2, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_TBits), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator->",983,G__MiniFWLiteDict_653_0_3, 85, G__get_linked_tagnum(&G__MiniFWLiteDictLN_TBits), -1, 0, 0, 1, 1, 9, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("productTypeInfo",1583,G__MiniFWLiteDict_653_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<TBits>::productTypeInfo) ), 0);
   G__memfunc_setup("typeInfo",846,G__MiniFWLiteDict_653_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_type_info), -1, 1, 0, 3, 1, 1, "", (char*)NULL, (void*) G__func2void( (const type_info& (*)())(&edm::Wrapper<TBits>::typeInfo) ), 0);
   G__memfunc_setup("Wrapper<TBits>",1345,(G__InterfaceMethod) NULL, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR), -1, 0, 1, 1, 4, 0, "u 'edm::Wrapper<TBits>' - 41 - rh", "disallow copy construction", (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR), -1, 1, 1, 1, 4, 0, "u 'edm::Wrapper<TBits>' - 41 - -", "disallow assignment", (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~Wrapper<TBits>", 1471, G__MiniFWLiteDict_653_0_8, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 1);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR(void) {
   /* set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR));
   G__memfunc_setup("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >",5689,G__MiniFWLiteDict_657_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >",5689,G__MiniFWLiteDict_657_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR), -1, 0, 1, 1, 1, 0, "u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_657_0_3, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR), -1, 1, 1, 1, 1, 0, "u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_657_0_4, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_657_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_657_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_657_0_7, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_657_0_8, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_657_0_9, 107, -1, G__defined_typename("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_657_0_10, 107, -1, G__defined_typename("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_657_0_11, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiteratorcOboolgR), -1, 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_657_0_12, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator' - 0 - position u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_657_0_13, 121, -1, -1, 0, 1, 1, 1, 0, "u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_657_0_14, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator' - 0 - first u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_657_0_15, 121, -1, -1, 0, 1, 1, 1, 0, "u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >' - 1 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_657_0_16, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("find",417,G__MiniFWLiteDict_657_0_17, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("count",553,G__MiniFWLiteDict_657_0_18, 107, -1, G__defined_typename("set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::size_type"), 0, 1, 1, 1, 8, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("lower_bound",1184,G__MiniFWLiteDict_657_0_19, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("upper_bound",1187,G__MiniFWLiteDict_657_0_20, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 8, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >", 5815, G__MiniFWLiteDict_657_0_21, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR(void) {
   /* pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR));
   G__memfunc_setup("pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >",7472,G__MiniFWLiteDict_661_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >",7472,G__MiniFWLiteDict_661_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'edm::BranchID' - 11 - a u 'set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >' - 11 - b", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,(G__InterfaceMethod) NULL, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR), -1, 1, 1, 1, 4, 0, "u 'pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic copy constructor
   G__memfunc_setup("pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >", 7472, G__MiniFWLiteDict_661_0_4, (int) ('i'), 
G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >' - 11 - -", (char*) NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >", 7598, G__MiniFWLiteDict_661_0_5, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}

static void G__setup_memfuncmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR(void) {
   /* map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > > */
   G__tag_memfunc_setup(G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR));
   G__memfunc_setup("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >",18338,G__MiniFWLiteDict_664_0_1, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >",18338,G__MiniFWLiteDict_664_0_2, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - first u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >",18338,G__MiniFWLiteDict_664_0_3, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR), -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator' - 0 - first u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >",18338,G__MiniFWLiteDict_664_0_4, 105, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR), -1, 0, 1, 1, 1, 0, "u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator=",937,G__MiniFWLiteDict_664_0_5, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR), -1, 1, 1, 1, 1, 0, "u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("begin",517,G__MiniFWLiteDict_664_0_6, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("end",311,G__MiniFWLiteDict_664_0_7, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rbegin",631,G__MiniFWLiteDict_664_0_8, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("rend",425,G__MiniFWLiteDict_664_0_9, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator), -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("empty",559,G__MiniFWLiteDict_664_0_10, 103, -1, -1, 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("size",443,G__MiniFWLiteDict_664_0_11, 107, -1, G__defined_typename("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("max_size",864,G__MiniFWLiteDict_664_0_12, 107, -1, G__defined_typename("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::size_type"), 0, 0, 1, 1, 8, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("operator[]",1060,G__MiniFWLiteDict_664_0_13, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR), -1, 1, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_664_0_14, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_pairlEmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiteratorcOboolgR), -1, 0, 1, 1, 1, 0, "u 'pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >' 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_664_0_15, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - position u 'pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >' 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::value_type' 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_664_0_16, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - first u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("insert",661,G__MiniFWLiteDict_664_0_17, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator' - 0 - first u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_664_0_18, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - position", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_664_0_19, 107, -1, G__defined_typename("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::size_type"), 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("erase",528,G__MiniFWLiteDict_664_0_20, 121, -1, -1, 0, 2, 1, 1, 0, 
"u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - first u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator' - 0 - last", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("swap",443,G__MiniFWLiteDict_664_0_21, 121, -1, -1, 0, 1, 1, 1, 0, "u 'map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >' - 1 - -", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("clear",519,G__MiniFWLiteDict_664_0_22, 121, -1, -1, 0, 0, 1, 1, 0, "", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("find",417,G__MiniFWLiteDict_664_0_23, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("count",553,G__MiniFWLiteDict_664_0_24, 107, -1, G__defined_typename("map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::size_type"), 0, 1, 1, 1, 8, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("lower_bound",1184,G__MiniFWLiteDict_664_0_25, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   G__memfunc_setup("upper_bound",1187,G__MiniFWLiteDict_664_0_26, 117, G__get_linked_tagnum(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator), -1, 0, 1, 1, 1, 0, "u 'edm::BranchID' - 11 - x", (char*)NULL, (void*) NULL, 0);
   // automatic destructor
   G__memfunc_setup("~map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >", 18464, G__MiniFWLiteDict_664_0_27, (int) ('y'), -1, -1, 0, 0, 1, 1, 0, "", (char*) NULL, (void*) NULL, 0);
   G__tag_memfunc_reset();
}


/*********************************************************
* Member function information setup
*********************************************************/
extern "C" void G__cpp_setup_memfuncMiniFWLiteDict() {
}

/*********************************************************
* Global variable information setup for each class
*********************************************************/
static void G__cpp_setup_global0() {

   /* Setting up global variables */
   G__resetplocal();

}

static void G__cpp_setup_global1() {

   G__resetglobalenv();
}
extern "C" void G__cpp_setup_globalMiniFWLiteDict() {
  G__cpp_setup_global0();
  G__cpp_setup_global1();
}

/*********************************************************
* Global function information setup for each class
*********************************************************/
static void G__cpp_setup_func0() {
   G__lastifuncposition();

}

static void G__cpp_setup_func1() {
}

static void G__cpp_setup_func2() {
}

static void G__cpp_setup_func3() {
}

static void G__cpp_setup_func4() {
}

static void G__cpp_setup_func5() {
}

static void G__cpp_setup_func6() {
}

static void G__cpp_setup_func7() {
}

static void G__cpp_setup_func8() {
}

static void G__cpp_setup_func9() {
}

static void G__cpp_setup_func10() {
}

static void G__cpp_setup_func11() {
}

static void G__cpp_setup_func12() {
}

static void G__cpp_setup_func13() {
}

static void G__cpp_setup_func14() {
}

static void G__cpp_setup_func15() {
}

static void G__cpp_setup_func16() {
}

static void G__cpp_setup_func17() {
}

static void G__cpp_setup_func18() {
}

static void G__cpp_setup_func19() {
}

static void G__cpp_setup_func20() {
}

static void G__cpp_setup_func21() {
}

static void G__cpp_setup_func22() {
}

static void G__cpp_setup_func23() {
}

static void G__cpp_setup_func24() {
}

static void G__cpp_setup_func25() {
}

static void G__cpp_setup_func26() {
}

static void G__cpp_setup_func27() {
}

static void G__cpp_setup_func28() {
}

static void G__cpp_setup_func29() {
}

static void G__cpp_setup_func30() {

   G__resetifuncposition();
}

extern "C" void G__cpp_setup_funcMiniFWLiteDict() {
  G__cpp_setup_func0();
  G__cpp_setup_func1();
  G__cpp_setup_func2();
  G__cpp_setup_func3();
  G__cpp_setup_func4();
  G__cpp_setup_func5();
  G__cpp_setup_func6();
  G__cpp_setup_func7();
  G__cpp_setup_func8();
  G__cpp_setup_func9();
  G__cpp_setup_func10();
  G__cpp_setup_func11();
  G__cpp_setup_func12();
  G__cpp_setup_func13();
  G__cpp_setup_func14();
  G__cpp_setup_func15();
  G__cpp_setup_func16();
  G__cpp_setup_func17();
  G__cpp_setup_func18();
  G__cpp_setup_func19();
  G__cpp_setup_func20();
  G__cpp_setup_func21();
  G__cpp_setup_func22();
  G__cpp_setup_func23();
  G__cpp_setup_func24();
  G__cpp_setup_func25();
  G__cpp_setup_func26();
  G__cpp_setup_func27();
  G__cpp_setup_func28();
  G__cpp_setup_func29();
  G__cpp_setup_func30();
}

/*********************************************************
* Class,struct,union,enum tag information setup
*********************************************************/
/* Setup class/struct taginfo */
G__linked_taginfo G__MiniFWLiteDictLN_type_info = { "type_info" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_TString = { "TString" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOT = { "ROOT" , 110 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR = { "vector<unsigned int,allocator<unsigned int> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR = { "vector<float,allocator<float> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR = { "vector<double,allocator<double> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR = { "vector<bool,allocator<bool> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR = { "vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::TSchemaHelper,allocator<ROOT::TSchemaHelper> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR = { "vector<TVirtualArray*,allocator<TVirtualArray*> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<TVirtualArray*,allocator<TVirtualArray*> >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edm = { "edm" , 110 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEDProduct = { "edm::EDProduct" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMath = { "ROOT::Math" , 110 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDefaultCoordinateSystemTag = { "ROOT::Math::DefaultCoordinateSystemTag" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_TBits = { "TBits" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLBranchKey = { "edm::BranchKey" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventAuxiliary = { "edm::EventAuxiliary" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLFileFormatVersion = { "edm::FileFormatVersion" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary = { "edm::LuminosityBlockAuxiliary" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLParameterSetBlob = { "edm::ParameterSetBlob" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLRunAuxiliary = { "edm::RunAuxiliary" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLBranchChildren = { "edm::BranchChildren" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLBranchDescription = { "edm::BranchDescription" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients = { "edm::BranchDescription::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLBranchID = { "edm::BranchID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventEntryDescription = { "edm::EventEntryDescription" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients = { "edm::EventEntryDescription::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventEntryInfo = { "edm::EventEntryInfo" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients = { "edm::EventEntryInfo::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLEventID = { "edm::EventID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLFileID = { "edm::FileID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLFileIndex = { "edm::FileIndex" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement = { "edm::FileIndex::Element" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients = { "edm::FileIndex::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHistory = { "edm::History" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID = { "edm::LuminosityBlockID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLModuleDescription = { "edm::ModuleDescription" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLParentage = { "edm::Parentage" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients = { "edm::Parentage::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProcessConfiguration = { "edm::ProcessConfiguration" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients = { "edm::ProcessConfiguration::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProcessHistory = { "edm::ProcessHistory" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients = { "edm::ProcessHistory::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProductID = { "edm::ProductID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance = { "edm::StoredProductProvenance" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProductProvenance = { "edm::ProductProvenance" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProductRegistry = { "edm::ProductRegistry" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients = { "edm::ProductRegistry::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLRunID = { "edm::RunID" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTimestamp = { "edm::Timestamp" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLIndexIntoFile = { "edm::IndexIntoFile" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients = { "edm::IndexIntoFile::Transients" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry = { "edm::IndexIntoFile::RunOrLumiEntry" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR = { "ROOT::Math::PxPyPzE4D<float>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR = { "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR = { "ROOT::Math::Cartesian3D<float>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR = { "vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator = { "vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR = { "vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator = { "vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR = { "vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator = { "vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR = { "vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator = { "vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR = { "vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator = { "vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR = { "vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator = { "vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR = { "reverse_iterator<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >::iterator>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR = { "edm::Wrapper<TString>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR = { "edm::Wrapper<double>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR = { "edm::Wrapper<float>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR = { "edm::Wrapper<int>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR = { "edm::Wrapper<unsigned int>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR = { "ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR = { "edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR = { "edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR = { "ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR = { "edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR = { "edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR = { "vector<TString,allocator<TString> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR = { "edm::Wrapper<vector<TString,allocator<TString> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR = { "edm::Wrapper<vector<double,allocator<double> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR = { "edm::Wrapper<vector<float,allocator<float> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR = { "vector<int,allocator<int> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR = { "edm::Wrapper<vector<int,allocator<int> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR = { "edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR = { "vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR = { "vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR = { "edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR = { "edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR = { "vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR = { "vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR = { "vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR = { "vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR = { "vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR = { "vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR = { "vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR = { "edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE0gR = { "edm::Hash<0>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE1gR = { "edm::Hash<1>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE2gR = { "edm::Hash<2>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE3gR = { "edm::Hash<3>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE4gR = { "edm::Hash<4>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLHashlE5gR = { "edm::Hash<5>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR = { "edm::Transient<edm::BranchDescription::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR = { "edm::Transient<edm::EventEntryDescription::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR = { "edm::Transient<edm::EventEntryInfo::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR = { "edm::Transient<edm::FileIndex::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR = { "edm::Transient<edm::Parentage::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR = { "edm::Transient<edm::ProcessConfiguration::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR = { "edm::Transient<edm::ProcessHistory::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR = { "edm::Transient<edm::ProductProvenance::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR = { "edm::Transient<edm::ProductRegistry::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR = { "edm::Transient<edm::IndexIntoFile::Transients>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR = { "pair<edm::BranchKey,edm::BranchDescription>" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR = { "pair<edm::Hash<1>,edm::ParameterSetBlob>" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR = { "edm::Wrapper<bool>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR = { "edm::Wrapper<vector<bool,allocator<bool> > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR = { "edm::Wrapper<unsigned long long>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR = { "edm::Wrapper<TBits>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR = { "less<edm::BranchID>" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_allocatorlEedmcLcLBranchIDgR = { "allocator<edm::BranchID>" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR = { "set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator = { "set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator = { "set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::reverse_iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_pairlEsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiteratorcOboolgR = { "pair<set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >::iterator,bool>" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR = { "pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >" , 115 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_allocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgR = { "allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR = { "map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator = { "map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator = { "map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::reverse_iterator" , 99 , -1 };
G__linked_taginfo G__MiniFWLiteDictLN_pairlEmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiteratorcOboolgR = { "pair<map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >::iterator,bool>" , 115 , -1 };

/* Reset class/struct taginfo */
extern "C" void G__cpp_reset_tagtableMiniFWLiteDict() {
  G__MiniFWLiteDictLN_type_info.tagnum = -1 ;
  G__MiniFWLiteDictLN_TString.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOT.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edm.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEDProduct.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMath.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDefaultCoordinateSystemTag.tagnum = -1 ;
  G__MiniFWLiteDictLN_TBits.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLBranchKey.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventAuxiliary.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLFileFormatVersion.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLParameterSetBlob.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLRunAuxiliary.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLBranchChildren.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLBranchDescription.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLBranchID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventEntryDescription.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventEntryInfo.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLEventID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLFileID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLFileIndex.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHistory.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLModuleDescription.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLParentage.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProcessConfiguration.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProcessHistory.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProductID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProductProvenance.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProductRegistry.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLRunID.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTimestamp.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLIndexIntoFile.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE0gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE1gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE2gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE3gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE4gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLHashlE5gR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR.tagnum = -1 ;
  G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR.tagnum = -1 ;
  G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_allocatorlEedmcLcLBranchIDgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_pairlEsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiteratorcOboolgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_allocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR.tagnum = -1 ;
  G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator.tagnum = -1 ;
  G__MiniFWLiteDictLN_pairlEmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiteratorcOboolgR.tagnum = -1 ;
}


extern "C" void G__cpp_setup_tagtableMiniFWLiteDict() {

   /* Setting up class,struct,union tag entry */
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_type_info);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_TString);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOT);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEfloatcOallocatorlEfloatgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEdoublecOallocatorlEdoublegRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEboolcOallocatorlEboolgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLTSchemaHelpercOallocatorlEROOTcLcLTSchemaHelpergRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlETVirtualArraymUcOallocatorlETVirtualArraymUgRsPgRcLcLiteratorgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edm);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEDProduct),sizeof(edm::EDProduct),-1,263424,(char*)NULL,G__setup_memvaredmcLcLEDProduct,G__setup_memfuncedmcLcLEDProduct);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMath);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDefaultCoordinateSystemTag);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_TBits);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLBranchKey),sizeof(edm::BranchKey),-1,262144,(char*)NULL,G__setup_memvaredmcLcLBranchKey,G__setup_memfuncedmcLcLBranchKey);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventAuxiliary),sizeof(edm::EventAuxiliary),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventAuxiliary,G__setup_memfuncedmcLcLEventAuxiliary);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLFileFormatVersion),sizeof(edm::FileFormatVersion),-1,262144,(char*)NULL,G__setup_memvaredmcLcLFileFormatVersion,G__setup_memfuncedmcLcLFileFormatVersion);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockAuxiliary),sizeof(edm::LuminosityBlockAuxiliary),-1,262144,(char*)NULL,G__setup_memvaredmcLcLLuminosityBlockAuxiliary,G__setup_memfuncedmcLcLLuminosityBlockAuxiliary);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLParameterSetBlob),sizeof(edm::ParameterSetBlob),-1,262144,(char*)NULL,G__setup_memvaredmcLcLParameterSetBlob,G__setup_memfuncedmcLcLParameterSetBlob);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLRunAuxiliary),sizeof(edm::RunAuxiliary),-1,262144,(char*)NULL,G__setup_memvaredmcLcLRunAuxiliary,G__setup_memfuncedmcLcLRunAuxiliary);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLBranchChildren),sizeof(edm::BranchChildren),-1,262144,(char*)NULL,G__setup_memvaredmcLcLBranchChildren,G__setup_memfuncedmcLcLBranchChildren);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLBranchDescription),sizeof(edm::BranchDescription),-1,262144,(char*)NULL,G__setup_memvaredmcLcLBranchDescription,G__setup_memfuncedmcLcLBranchDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLBranchDescriptioncLcLTransients),sizeof(edm::BranchDescription::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLBranchDescriptioncLcLTransients,G__setup_memfuncedmcLcLBranchDescriptioncLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLBranchID),sizeof(edm::BranchID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLBranchID,G__setup_memfuncedmcLcLBranchID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescription),sizeof(edm::EventEntryDescription),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventEntryDescription,G__setup_memfuncedmcLcLEventEntryDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventEntryDescriptioncLcLTransients),sizeof(edm::EventEntryDescription::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventEntryDescriptioncLcLTransients,G__setup_memfuncedmcLcLEventEntryDescriptioncLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfo),sizeof(edm::EventEntryInfo),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventEntryInfo,G__setup_memfuncedmcLcLEventEntryInfo);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventEntryInfocLcLTransients),sizeof(edm::EventEntryInfo::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventEntryInfocLcLTransients,G__setup_memfuncedmcLcLEventEntryInfocLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLEventID),sizeof(edm::EventID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLEventID,G__setup_memfuncedmcLcLEventID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLFileID),sizeof(edm::FileID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLFileID,G__setup_memfuncedmcLcLFileID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLFileIndex),sizeof(edm::FileIndex),-1,262144,(char*)NULL,G__setup_memvaredmcLcLFileIndex,G__setup_memfuncedmcLcLFileIndex);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLElement),sizeof(edm::FileIndex::Element),-1,262144,(char*)NULL,G__setup_memvaredmcLcLFileIndexcLcLElement,G__setup_memfuncedmcLcLFileIndexcLcLElement);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLFileIndexcLcLTransients),sizeof(edm::FileIndex::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLFileIndexcLcLTransients,G__setup_memfuncedmcLcLFileIndexcLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHistory),sizeof(edm::History),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHistory,G__setup_memfuncedmcLcLHistory);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLLuminosityBlockID),sizeof(edm::LuminosityBlockID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLLuminosityBlockID,G__setup_memfuncedmcLcLLuminosityBlockID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLModuleDescription),sizeof(edm::ModuleDescription),-1,262144,(char*)NULL,G__setup_memvaredmcLcLModuleDescription,G__setup_memfuncedmcLcLModuleDescription);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLParentage),sizeof(edm::Parentage),-1,262144,(char*)NULL,G__setup_memvaredmcLcLParentage,G__setup_memfuncedmcLcLParentage);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLParentagecLcLTransients),sizeof(edm::Parentage::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLParentagecLcLTransients,G__setup_memfuncedmcLcLParentagecLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProcessConfiguration),sizeof(edm::ProcessConfiguration),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProcessConfiguration,G__setup_memfuncedmcLcLProcessConfiguration);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProcessConfigurationcLcLTransients),sizeof(edm::ProcessConfiguration::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProcessConfigurationcLcLTransients,G__setup_memfuncedmcLcLProcessConfigurationcLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProcessHistory),sizeof(edm::ProcessHistory),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProcessHistory,G__setup_memfuncedmcLcLProcessHistory);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProcessHistorycLcLTransients),sizeof(edm::ProcessHistory::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProcessHistorycLcLTransients,G__setup_memfuncedmcLcLProcessHistorycLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProductID),sizeof(edm::ProductID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProductID,G__setup_memfuncedmcLcLProductID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLStoredProductProvenance),sizeof(edm::StoredProductProvenance),-1,262144,(char*)NULL,G__setup_memvaredmcLcLStoredProductProvenance,G__setup_memfuncedmcLcLStoredProductProvenance);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProductProvenance),sizeof(edm::ProductProvenance),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProductProvenance,G__setup_memfuncedmcLcLProductProvenance);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProductRegistry),sizeof(edm::ProductRegistry),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProductRegistry,G__setup_memfuncedmcLcLProductRegistry);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLProductRegistrycLcLTransients),sizeof(edm::ProductRegistry::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLProductRegistrycLcLTransients,G__setup_memfuncedmcLcLProductRegistrycLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLRunID),sizeof(edm::RunID),-1,262144,(char*)NULL,G__setup_memvaredmcLcLRunID,G__setup_memfuncedmcLcLRunID);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTimestamp),sizeof(edm::Timestamp),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTimestamp,G__setup_memfuncedmcLcLTimestamp);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFile),sizeof(edm::IndexIntoFile),-1,262144,(char*)NULL,G__setup_memvaredmcLcLIndexIntoFile,G__setup_memfuncedmcLcLIndexIntoFile);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLTransients),sizeof(edm::IndexIntoFile::Transients),-1,262144,(char*)NULL,G__setup_memvaredmcLcLIndexIntoFilecLcLTransients,G__setup_memfuncedmcLcLIndexIntoFilecLcLTransients);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLIndexIntoFilecLcLRunOrLumiEntry),sizeof(edm::IndexIntoFile::RunOrLumiEntry),-1,262144,(char*)NULL,G__setup_memvaredmcLcLIndexIntoFilecLcLRunOrLumiEntry,G__setup_memfuncedmcLcLIndexIntoFilecLcLRunOrLumiEntry);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPxPyPzE4DlEfloatgR),sizeof(ROOT::Math::PxPyPzE4D<float>),-1,297728,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLPxPyPzE4DlEfloatgR,G__setup_memfuncROOTcLcLMathcLcLPxPyPzE4DlEfloatgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR),sizeof(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR,G__setup_memfuncROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLCartesian3DlEfloatgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLDisplacementVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR),sizeof(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>),-1,295168,(char*)NULL,G__setup_memvarROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR,G__setup_memfuncROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),sizeof(vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR,G__setup_memfuncvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR),sizeof(vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR,G__setup_memfuncvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR),sizeof(vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR,G__setup_memfuncvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),sizeof(vector<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > >,allocator<vector<ROOT::Math::PxPyPzE4D<float>,allocator<ROOT::Math::PxPyPzE4D<float> > > > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR,G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRcOallocatorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR),sizeof(vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR,G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR),sizeof(vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > >),-1,298752,(char*)NULL,G__setup_memvarvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR,G__setup_memfuncvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_reverse_iteratorlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRcLcLiteratorgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlETStringgR),sizeof(edm::Wrapper<TString>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlETStringgR,G__setup_memfuncedmcLcLWrapperlETStringgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEdoublegR),sizeof(edm::Wrapper<double>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEdoublegR,G__setup_memfuncedmcLcLWrapperlEdoublegR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEfloatgR),sizeof(edm::Wrapper<float>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEfloatgR,G__setup_memfuncedmcLcLWrapperlEfloatgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEintgR),sizeof(edm::Wrapper<int>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEintgR,G__setup_memfuncedmcLcLWrapperlEintgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPintgR),sizeof(edm::Wrapper<unsigned int>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEunsignedsPintgR,G__setup_memfuncedmcLcLWrapperlEunsignedsPintgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR),sizeof(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR),sizeof(edm::Wrapper<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_ROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR),sizeof(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR,G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR),sizeof(edm::Wrapper<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR,G__setup_memfuncedmcLcLWrapperlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlETStringcOallocatorlETStringgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR),sizeof(edm::Wrapper<vector<TString,allocator<TString> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlETStringcOallocatorlETStringgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR),sizeof(edm::Wrapper<vector<double,allocator<double> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR),sizeof(edm::Wrapper<vector<float,allocator<float> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEintcOallocatorlEintgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR),sizeof(edm::Wrapper<vector<int,allocator<int> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEintcOallocatorlEintgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR),sizeof(edm::Wrapper<vector<unsigned int,allocator<unsigned int> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<TString,allocator<TString> >,allocator<vector<TString,allocator<TString> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlETStringcOallocatorlETStringgRsPgRcOallocatorlEvectorlETStringcOallocatorlETStringgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<double,allocator<double> >,allocator<vector<double,allocator<double> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEdoublecOallocatorlEdoublegRsPgRcOallocatorlEvectorlEdoublecOallocatorlEdoublegRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<float,allocator<float> >,allocator<vector<float,allocator<float> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEfloatcOallocatorlEfloatgRsPgRcOallocatorlEvectorlEfloatcOallocatorlEfloatgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<int,allocator<int> >,allocator<vector<int,allocator<int> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEintcOallocatorlEintgRsPgRcOallocatorlEvectorlEintcOallocatorlEintgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<unsigned int,allocator<unsigned int> >,allocator<vector<unsigned int,allocator<unsigned int> > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRcOallocatorlEvectorlEunsignedsPintcOallocatorlEunsignedsPintgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> > > > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEdoublegRsPgRsPgRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > >,allocator<vector<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> >,allocator<ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<float> > > > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRcOallocatorlEROOTcLcLMathcLcLLorentzVectorlEROOTcLcLMathcLcLPxPyPzE4DlEfloatgRsPgRsPgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_vectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEdoublegRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR),sizeof(edm::Wrapper<vector<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > >,allocator<vector<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag>,allocator<ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<float>,ROOT::Math::DefaultCoordinateSystemTag> > > > > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRcOallocatorlEvectorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRcOallocatorlEROOTcLcLMathcLcLPositionVector3DlEROOTcLcLMathcLcLCartesian3DlEfloatgRcOROOTcLcLMathcLcLDefaultCoordinateSystemTaggRsPgRsPgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE0gR),sizeof(edm::Hash<0>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE0gR,G__setup_memfuncedmcLcLHashlE0gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE1gR),sizeof(edm::Hash<1>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE1gR,G__setup_memfuncedmcLcLHashlE1gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE2gR),sizeof(edm::Hash<2>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE2gR,G__setup_memfuncedmcLcLHashlE2gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE3gR),sizeof(edm::Hash<3>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE3gR,G__setup_memfuncedmcLcLHashlE3gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE4gR),sizeof(edm::Hash<4>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE4gR,G__setup_memfuncedmcLcLHashlE4gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLHashlE5gR),sizeof(edm::Hash<5>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLHashlE5gR,G__setup_memfuncedmcLcLHashlE5gR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR),sizeof(edm::Transient<edm::BranchDescription::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLBranchDescriptioncLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR),sizeof(edm::Transient<edm::EventEntryDescription::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLEventEntryDescriptioncLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR),sizeof(edm::Transient<edm::EventEntryInfo::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLEventEntryInfocLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR),sizeof(edm::Transient<edm::FileIndex::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLFileIndexcLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLParentagecLcLTransientsgR),sizeof(edm::Transient<edm::Parentage::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLParentagecLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLParentagecLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR),sizeof(edm::Transient<edm::ProcessConfiguration::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLProcessConfigurationcLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR),sizeof(edm::Transient<edm::ProcessHistory::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLProcessHistorycLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR),sizeof(edm::Transient<edm::ProductProvenance::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLProductProvenancecLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR),sizeof(edm::Transient<edm::ProductRegistry::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLProductRegistrycLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR),sizeof(edm::Transient<edm::IndexIntoFile::Transients>),-1,262144,(char*)NULL,G__setup_memvaredmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR,G__setup_memfuncedmcLcLTransientlEedmcLcLIndexIntoFilecLcLTransientsgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR),sizeof(pair<edm::BranchKey,edm::BranchDescription>),-1,297216,(char*)NULL,G__setup_memvarpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR,G__setup_memfuncpairlEedmcLcLBranchKeycOedmcLcLBranchDescriptiongR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_pairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR),sizeof(pair<edm::Hash<1>,edm::ParameterSetBlob>),-1,297216,(char*)NULL,G__setup_memvarpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR,G__setup_memfuncpairlEedmcLcLHashlE1gRcOedmcLcLParameterSetBlobgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEboolgR),sizeof(edm::Wrapper<bool>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEboolgR,G__setup_memfuncedmcLcLWrapperlEboolgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR),sizeof(edm::Wrapper<vector<bool,allocator<bool> > >),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR,G__setup_memfuncedmcLcLWrapperlEvectorlEboolcOallocatorlEboolgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlEunsignedsPlongsPlonggR),sizeof(edm::Wrapper<unsigned long long>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlEunsignedsPlongsPlonggR,G__setup_memfuncedmcLcLWrapperlEunsignedsPlongsPlonggR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_edmcLcLWrapperlETBitsgR),sizeof(edm::Wrapper<TBits>),-1,265984,(char*)NULL,G__setup_memvaredmcLcLWrapperlETBitsgR,G__setup_memfuncedmcLcLWrapperlETBitsgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_lesslEedmcLcLBranchIDgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_allocatorlEedmcLcLBranchIDgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR),sizeof(set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >),-1,265984,(char*)NULL,G__setup_memvarsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR,G__setup_memfuncsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_setlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLreverse_iterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_pairlEsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcLcLiteratorcOboolgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_pairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR),sizeof(pair<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > >),-1,297216,(char*)NULL,G__setup_memvarpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR,G__setup_memfuncpairlEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_allocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgR);
   G__tagtable_setup(G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR),sizeof(map<edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> >,less<edm::BranchID>,allocator<pair<const edm::BranchID,set<edm::BranchID,less<edm::BranchID>,allocator<edm::BranchID> > > > >),-1,298752,(char*)NULL,G__setup_memvarmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR,G__setup_memfuncmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgR);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_maplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLreverse_iterator);
   G__get_linked_tagnum_fwd(&G__MiniFWLiteDictLN_pairlEmaplEedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRcOlesslEedmcLcLBranchIDgRcOallocatorlEpairlEconstsPedmcLcLBranchIDcOsetlEedmcLcLBranchIDcOlesslEedmcLcLBranchIDgRcOallocatorlEedmcLcLBranchIDgRsPgRsPgRsPgRsPgRcLcLiteratorcOboolgR);
}
extern "C" void G__cpp_setupMiniFWLiteDict(void) {
  G__check_setup_version(30051515,"G__cpp_setupMiniFWLiteDict()");
  G__set_cpp_environmentMiniFWLiteDict();
  G__cpp_setup_tagtableMiniFWLiteDict();

  G__cpp_setup_inheritanceMiniFWLiteDict();

  G__cpp_setup_typetableMiniFWLiteDict();

  G__cpp_setup_memvarMiniFWLiteDict();

  G__cpp_setup_memfuncMiniFWLiteDict();
  G__cpp_setup_globalMiniFWLiteDict();
  G__cpp_setup_funcMiniFWLiteDict();

   if(0==G__getsizep2memfunc()) G__get_sizep2memfuncMiniFWLiteDict();
  return;
}
class G__cpp_setup_initMiniFWLiteDict {
  public:
    G__cpp_setup_initMiniFWLiteDict() { G__add_setup_func("MiniFWLiteDict",(G__incsetup)(&G__cpp_setupMiniFWLiteDict)); G__call_setup_funcs(); }
   ~G__cpp_setup_initMiniFWLiteDict() { G__remove_setup_func("MiniFWLiteDict"); }
};
G__cpp_setup_initMiniFWLiteDict G__cpp_setup_initializerMiniFWLiteDict;

